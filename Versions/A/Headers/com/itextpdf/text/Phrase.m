//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/Phrase.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/Phrase.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "com/itextpdf/text/BaseColor.h"
#include "com/itextpdf/text/Chunk.h"
#include "com/itextpdf/text/DocumentException.h"
#include "com/itextpdf/text/Element.h"
#include "com/itextpdf/text/ElementListener.h"
#include "com/itextpdf/text/Font.h"
#include "com/itextpdf/text/Phrase.h"
#include "com/itextpdf/text/SpecialSymbol.h"
#include "com/itextpdf/text/TabSettings.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/pdf/BaseFont.h"
#include "com/itextpdf/text/pdf/HyphenationEvent.h"
#include "com/itextpdf/text/pdf/PdfName.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/Float.h"
#include "java/lang/StringBuffer.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"


#line 81
@implementation ComItextpdfTextPhrase


#line 112
- (instancetype)init {
  return
#line 113
  [self initComItextpdfTextPhraseWithFloat:16];
}


#line 120
- (instancetype)initWithComItextpdfTextPhrase:(ComItextpdfTextPhrase *)phrase {
  if (self =
#line 121
  [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
    
#line 122
    [self addAllWithJavaUtilCollection:phrase];
    
#line 123
    [self setLeadingWithFloat:[((ComItextpdfTextPhrase *) nil_chk(phrase)) getLeading] withFloat:[phrase getMultipliedLeading]];
    
#line 124
    font_ = [phrase getFont];
    
#line 125
    tabSettings_ = [phrase getTabSettings];
    
#line 126
    [self setHyphenationWithComItextpdfTextPdfHyphenationEvent:[phrase getHyphenation]];
  }
  return self;
}


#line 134
- (instancetype)initComItextpdfTextPhraseWithFloat:(jfloat)leading {
  if (self = [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
    
#line 135
    self->leading_ = leading;
    
#line 136
    font_ = [[ComItextpdfTextFont alloc] init];
  }
  return self;
}

- (instancetype)initWithFloat:(jfloat)leading {
  return [self initComItextpdfTextPhraseWithFloat:
#line 134
leading];
}


#line 144
- (instancetype)initWithComItextpdfTextChunk:(ComItextpdfTextChunk *)chunk {
  if (self = [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
    
#line 145
    [super addWithId:chunk];
    
#line 146
    font_ = [((ComItextpdfTextChunk *) nil_chk(chunk)) getFont];
    
#line 147
    [self setHyphenationWithComItextpdfTextPdfHyphenationEvent:[chunk getHyphenation]];
  }
  return self;
}


#line 157
- (instancetype)initWithFloat:(jfloat)leading
     withComItextpdfTextChunk:(ComItextpdfTextChunk *)chunk {
  if (self = [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
    
#line 158
    self->leading_ = leading;
    
#line 159
    [super addWithId:chunk];
    
#line 160
    font_ = [((ComItextpdfTextChunk *) nil_chk(chunk)) getFont];
    
#line 161
    [self setHyphenationWithComItextpdfTextPdfHyphenationEvent:[chunk getHyphenation]];
  }
  return self;
}


#line 169
- (instancetype)initWithNSString:(NSString *)string {
  return
#line 170
  [self initComItextpdfTextPhraseWithFloat:JavaLangFloat_NaN withNSString:string withComItextpdfTextFont:[[ComItextpdfTextFont alloc] init]];
}


#line 179
- (instancetype)initWithNSString:(NSString *)string
         withComItextpdfTextFont:(ComItextpdfTextFont *)font {
  return
#line 180
  [self initComItextpdfTextPhraseWithFloat:JavaLangFloat_NaN withNSString:string withComItextpdfTextFont:font];
}


#line 189
- (instancetype)initWithFloat:(jfloat)leading
                 withNSString:(NSString *)string {
  return
#line 190
  [self initComItextpdfTextPhraseWithFloat:leading withNSString:string withComItextpdfTextFont:[[ComItextpdfTextFont alloc] init]];
}


#line 201
- (instancetype)initComItextpdfTextPhraseWithFloat:(jfloat)leading
                                      withNSString:(NSString *)string
                           withComItextpdfTextFont:(ComItextpdfTextFont *)font {
  if (self = [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
    
#line 202
    self->leading_ = leading;
    
#line 203
    self->font_ = font;
    
#line 205
    if (string != nil && ((jint) [string length]) != 0) {
      [super addWithId:[[ComItextpdfTextChunk alloc] initWithNSString:string withComItextpdfTextFont:font]];
    }
  }
  return self;
}

- (instancetype)initWithFloat:(jfloat)leading
                 withNSString:(NSString *)string
      withComItextpdfTextFont:(ComItextpdfTextFont *)font {
  return [self initComItextpdfTextPhraseWithFloat:
#line 201
leading withNSString:string withComItextpdfTextFont:font];
}


#line 219
- (jboolean)processWithComItextpdfTextElementListener:(id<ComItextpdfTextElementListener>)listener {
  
#line 220
  @try {
    for (id __strong element in self) {
      [((id<ComItextpdfTextElementListener>) nil_chk(listener)) addWithComItextpdfTextElement:(id<ComItextpdfTextElement>) check_protocol_cast(element, @protocol(ComItextpdfTextElement))];
    }
    return YES;
  }
  @catch (ComItextpdfTextDocumentException *de) {
    return NO;
  }
}


#line 236
- (jint)type {
  
#line 237
  return ComItextpdfTextElement_PHRASE;
}


#line 245
- (id<JavaUtilList>)getChunks {
  
#line 246
  id<JavaUtilList> tmp = [[JavaUtilArrayList alloc] init];
  for (id<ComItextpdfTextElement> __strong element in self) {
    [tmp addAllWithJavaUtilCollection:[((id<ComItextpdfTextElement>) nil_chk(element)) getChunks]];
  }
  return tmp;
}


#line 257
- (jboolean)isContent {
  
#line 258
  return YES;
}


#line 265
- (jboolean)isNestable {
  
#line 266
  return YES;
}


#line 281
- (void)addWithInt:(jint)index
            withId:(id<ComItextpdfTextElement>)element {
  
#line 282
  if (element == nil) return;
  {
    
#line 285
    ComItextpdfTextChunk *chunk;
    
#line 283
    switch ([((id<ComItextpdfTextElement>) nil_chk(element)) type]) {
      case ComItextpdfTextElement_CHUNK:
      chunk = (ComItextpdfTextChunk *) check_class_cast(element, [ComItextpdfTextChunk class]);
      if (![((ComItextpdfTextFont *) nil_chk(font_)) isStandardFont]) {
        [chunk setFontWithComItextpdfTextFont:[font_ differenceWithComItextpdfTextFont:[chunk getFont]]];
      }
      if (hyphenation_ != nil && [chunk getHyphenation] == nil && ![chunk isEmpty]) {
        (void) [chunk setHyphenationWithComItextpdfTextPdfHyphenationEvent:hyphenation_];
      }
      [super addWithInt:index withId:chunk];
      return;
      case ComItextpdfTextElement_PHRASE:
      case ComItextpdfTextElement_PARAGRAPH:
      case ComItextpdfTextElement_MARKED:
      case ComItextpdfTextElement_DIV:
      case ComItextpdfTextElement_ANCHOR:
      case ComItextpdfTextElement_ANNOTATION:
      case ComItextpdfTextElement_PTABLE:
      case ComItextpdfTextElement_LIST:
      case ComItextpdfTextElement_YMARK:
      case ComItextpdfTextElement_WRITABLE_DIRECT:
      [super addWithInt:index withId:element];
      return;
      default:
      @throw [[JavaLangClassCastException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"insertion.of.illegal.element.1" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [[element getClass] getName] } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
  }
}


#line 318
- (jboolean)addWithNSString:(NSString *)s {
  
#line 319
  if (s == nil) {
    return NO;
  }
  return [super addWithId:[[ComItextpdfTextChunk alloc] initWithNSString:s withComItextpdfTextFont:font_]];
}


#line 335
- (jboolean)addWithId:(id<ComItextpdfTextElement>)element {
  
#line 336
  if (element == nil) return NO;
  @try {
    {
      
#line 344
      ComItextpdfTextPhrase *phrase;
      jboolean success;
      id<ComItextpdfTextElement> e;
      
#line 339
      switch ([((id<ComItextpdfTextElement>) nil_chk(element)) type]) {
        case ComItextpdfTextElement_CHUNK:
        return [self addChunkWithComItextpdfTextChunk:(ComItextpdfTextChunk *) check_class_cast(element, [ComItextpdfTextChunk class])];
        case ComItextpdfTextElement_PHRASE:
        case ComItextpdfTextElement_PARAGRAPH:
        phrase = (ComItextpdfTextPhrase *) check_class_cast(element, [ComItextpdfTextPhrase class]);
        success = YES;
        
#line 347
        for (id __strong element2 in phrase) {
          e = (id<ComItextpdfTextElement>) check_protocol_cast(element2, @protocol(ComItextpdfTextElement));
          if ([(id) e isKindOfClass:[ComItextpdfTextChunk class]]) {
            success &= [self addChunkWithComItextpdfTextChunk:(ComItextpdfTextChunk *) check_class_cast(e, [ComItextpdfTextChunk class])];
          }
          else {
            success &= [self addWithId:e];
          }
        }
        return success;
        case ComItextpdfTextElement_MARKED:
        case ComItextpdfTextElement_DIV:
        case ComItextpdfTextElement_ANCHOR:
        case ComItextpdfTextElement_ANNOTATION:
        case ComItextpdfTextElement_PTABLE:
        case ComItextpdfTextElement_LIST:
        case ComItextpdfTextElement_YMARK:
        case ComItextpdfTextElement_WRITABLE_DIRECT:
        return [super addWithId:element];
        default:
        @throw [[JavaLangClassCastException alloc] initWithNSString:[NSString valueOfInt:[element type]]];
      }
    }
  }
  @catch (
#line 370
  JavaLangClassCastException *cce) {
    @throw [[JavaLangClassCastException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"insertion.of.illegal.element.1" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaLangClassCastException *) nil_chk(cce)) getMessage] } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
}


#line 384
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection {
  
#line 385
  for (id<ComItextpdfTextElement> __strong e in nil_chk(collection)) {
    [self addWithId:e];
  }
  return YES;
}


#line 399
- (jboolean)addChunkWithComItextpdfTextChunk:(ComItextpdfTextChunk *)chunk {
  
#line 400
  ComItextpdfTextFont *f = [((ComItextpdfTextChunk *) nil_chk(chunk)) getFont];
  NSString *c = [chunk getContent];
  if (font_ != nil && ![font_ isStandardFont]) {
    f = [font_ differenceWithComItextpdfTextFont:[chunk getFont]];
  }
  if ([self size] > 0 && ![chunk hasAttributes]) {
    @try {
      ComItextpdfTextChunk *previous = (ComItextpdfTextChunk *) check_class_cast([self getWithInt:[self size] - 1], [ComItextpdfTextChunk class]);
      if (![((ComItextpdfTextChunk *) nil_chk(previous)) hasAttributes] &&
#line 409
      (f == nil ||
#line 410
      [f compareToWithId:[previous getFont]] == 0) &&
#line 411
      ![@"" isEqual:[((NSString *) nil_chk([previous getContent])) trim]] &&
#line 412
      ![@"" isEqual:[((NSString *) nil_chk(c)) trim]]) {
        (void) [previous appendWithNSString:c];
        return YES;
      }
    }
    @catch (JavaLangClassCastException *cce) {
    }
  }
  ComItextpdfTextChunk *newChunk = [[ComItextpdfTextChunk alloc] initWithNSString:c withComItextpdfTextFont:f];
  [newChunk setAttributesWithJavaUtilHashMap:[chunk getAttributes]];
  newChunk->role_ = [chunk getRole];
  newChunk->accessibleAttributes_ = [chunk getAccessibleAttributes];
  if (hyphenation_ != nil && [newChunk getHyphenation] == nil && ![newChunk isEmpty]) {
    (void) [newChunk setHyphenationWithComItextpdfTextPdfHyphenationEvent:hyphenation_];
  }
  return [super addWithId:newChunk];
}


#line 435
- (void)addSpecialWithComItextpdfTextElement:(id<ComItextpdfTextElement>)object {
  [super addWithId:object];
}


#line 448
- (void)setLeadingWithFloat:(jfloat)fixedLeading
                  withFloat:(jfloat)multipliedLeading {
  
#line 449
  self->leading_ = fixedLeading;
  self->multipliedLeading_ = multipliedLeading;
}

- (void)setLeadingWithFloat:(jfloat)fixedLeading {
  
#line 457
  self->leading_ = fixedLeading;
  self->multipliedLeading_ = 0;
}


#line 467
- (void)setMultipliedLeadingWithFloat:(jfloat)multipliedLeading {
  
#line 468
  self->leading_ = 0;
  self->multipliedLeading_ = multipliedLeading;
}


#line 476
- (void)setFontWithComItextpdfTextFont:(ComItextpdfTextFont *)font {
  
#line 477
  self->font_ = font;
}


#line 487
- (jfloat)getLeading {
  
#line 488
  if ([JavaLangFloat isNaNWithFloat:leading_] && font_ != nil) {
    return [font_ getCalculatedLeadingWithFloat:1.5f];
  }
  return leading_;
}


#line 498
- (jfloat)getMultipliedLeading {
  
#line 499
  return multipliedLeading_;
}


#line 510
- (jfloat)getTotalLeading {
  
#line 511
  jfloat m = font_ == nil ?
#line 512
  ComItextpdfTextFont_DEFAULTSIZE * multipliedLeading_ : [font_ getCalculatedLeadingWithFloat:multipliedLeading_];
  if (m > 0 && ![self hasLeading]) {
    return m;
  }
  return [self getLeading] + m;
}


#line 524
- (jboolean)hasLeading {
  
#line 525
  if ([JavaLangFloat isNaNWithFloat:leading_]) {
    return NO;
  }
  return YES;
}


#line 536
- (ComItextpdfTextFont *)getFont {
  
#line 537
  return font_;
}


#line 545
- (NSString *)getContent {
  
#line 546
  JavaLangStringBuffer *buf = [[JavaLangStringBuffer alloc] init];
  for (ComItextpdfTextChunk * __strong c in nil_chk([self getChunks])) {
    (void) [buf appendWithNSString:[((ComItextpdfTextChunk *) nil_chk(c)) description]];
  }
  return [buf description];
}


#line 560
- (jboolean)isEmpty {
  {
    
#line 565
    id<ComItextpdfTextElement> element;
    
#line 561
    switch ([self size]) {
      case 0:
      return YES;
      case 1:
      element = [self getWithInt:0];
      if ([((id<ComItextpdfTextElement>) nil_chk(element)) type] == ComItextpdfTextElement_CHUNK && [((ComItextpdfTextChunk *) check_class_cast(element, [ComItextpdfTextChunk class])) isEmpty]) {
        return YES;
      }
      return NO;
      default:
      return NO;
    }
  }
}


#line 580
- (id<ComItextpdfTextPdfHyphenationEvent>)getHyphenation {
  
#line 581
  return hyphenation_;
}


#line 589
- (void)setHyphenationWithComItextpdfTextPdfHyphenationEvent:(id<ComItextpdfTextPdfHyphenationEvent>)hyphenation {
  
#line 590
  self->hyphenation_ = hyphenation;
}


#line 598
- (ComItextpdfTextTabSettings *)getTabSettings {
  
#line 599
  return tabSettings_;
}


#line 607
- (void)setTabSettingsWithComItextpdfTextTabSettings:(ComItextpdfTextTabSettings *)tabSettings {
  
#line 608
  self->tabSettings_ = tabSettings;
}


#line 618
- (instancetype)initWithBoolean:(jboolean)dummy {
  if (self = [super init]) {
    leading_ =
#line 88
    JavaLangFloat_NaN;
    multipliedLeading_ =
#line 91
    0;
    hyphenation_ =
#line 99
    nil;
    tabSettings_ =
#line 105
    nil;
  }
  return self;
}


#line 626
+ (ComItextpdfTextPhrase *)getInstanceWithNSString:(NSString *)string {
  
#line 627
  return [ComItextpdfTextPhrase getInstanceWithInt:16 withNSString:string withComItextpdfTextFont:[[ComItextpdfTextFont alloc] init]];
}


#line 636
+ (ComItextpdfTextPhrase *)getInstanceWithInt:(jint)leading
                                 withNSString:(NSString *)string {
  
#line 637
  return [ComItextpdfTextPhrase getInstanceWithInt:leading withNSString:string withComItextpdfTextFont:[[ComItextpdfTextFont alloc] init]];
}


#line 647
+ (ComItextpdfTextPhrase *)getInstanceWithInt:(jint)leading
                                 withNSString:(NSString *)string
                      withComItextpdfTextFont:(ComItextpdfTextFont *)font {
  
#line 648
  ComItextpdfTextPhrase *p = [[ComItextpdfTextPhrase alloc] initWithBoolean:YES];
  [p setLeadingWithFloat:leading];
  p->font_ = font;
  if ([((ComItextpdfTextFont *) nil_chk(font)) getFamily] != ComItextpdfTextFont_FontFamilyEnum_get_SYMBOL() && [font getFamily] != ComItextpdfTextFont_FontFamilyEnum_get_ZAPFDINGBATS() && [font getBaseFont] == nil) {
    jint index;
    while ((index = [ComItextpdfTextSpecialSymbol indexWithNSString:string]) > -1) {
      if (index > 0) {
        NSString *firstPart = [((NSString *) nil_chk(string)) substring:0 endIndex:index];
        [p addWithId:[[ComItextpdfTextChunk alloc] initWithNSString:firstPart withComItextpdfTextFont:font]];
        string = [string substring:index];
      }
      ComItextpdfTextFont *symbol = [[ComItextpdfTextFont alloc] initWithComItextpdfTextFont_FontFamilyEnum:ComItextpdfTextFont_FontFamilyEnum_get_SYMBOL() withFloat:[font getSize] withInt:[font getStyle] withComItextpdfTextBaseColor:[font getColor]];
      JavaLangStringBuffer *buf = [[JavaLangStringBuffer alloc] init];
      (void) [buf appendWithChar:[ComItextpdfTextSpecialSymbol getCorrespondingSymbolWithChar:[((NSString *) nil_chk(string)) charAtWithInt:0]]];
      string = [string substring:1];
      while ([ComItextpdfTextSpecialSymbol indexWithNSString:string] == 0) {
        (void) [buf appendWithChar:[ComItextpdfTextSpecialSymbol getCorrespondingSymbolWithChar:[((NSString *) nil_chk(string)) charAtWithInt:0]]];
        string = [string substring:1];
      }
      [p addWithId:[[ComItextpdfTextChunk alloc] initWithNSString:[buf description] withComItextpdfTextFont:symbol]];
    }
  }
  if (string != nil && ((jint) [string length]) != 0) {
    [p addWithId:[[ComItextpdfTextChunk alloc] initWithNSString:string withComItextpdfTextFont:font]];
  }
  return p;
}


#line 676
- (jboolean)trim {
  
#line 677
  while ([self size] > 0) {
    id<ComItextpdfTextElement> firstChunk = [self getWithInt:0];
    if ([(id) firstChunk isKindOfClass:[ComItextpdfTextChunk class]] && [((ComItextpdfTextChunk *) nil_chk(((ComItextpdfTextChunk *) check_class_cast(firstChunk, [ComItextpdfTextChunk class])))) isWhitespace]) {
      [self removeWithId:firstChunk];
    }
    else {
      
#line 682
      break;
    }
  }
  while ([self size] > 0) {
    id<ComItextpdfTextElement> lastChunk = [self getWithInt:[self size] - 1];
    if ([(id) lastChunk isKindOfClass:[ComItextpdfTextChunk class]] && [((ComItextpdfTextChunk *) nil_chk(((ComItextpdfTextChunk *) check_class_cast(lastChunk, [ComItextpdfTextChunk class])))) isWhitespace]) {
      [self removeWithId:lastChunk];
    }
    else {
      
#line 690
      break;
    }
  }
  return [self size] > 0;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPhrase *)other {
  [super copyAllFieldsTo:other];
  other->font_ = font_;
  other->hyphenation_ = hyphenation_;
  other->leading_ = leading_;
  other->multipliedLeading_ = multipliedLeading_;
  other->tabSettings_ = tabSettings_;
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Phrase", NULL, 0x1, NULL },
    { "initWithComItextpdfTextPhrase:", "Phrase", NULL, 0x1, NULL },
    { "initWithFloat:", "Phrase", NULL, 0x1, NULL },
    { "initWithComItextpdfTextChunk:", "Phrase", NULL, 0x1, NULL },
    { "initWithFloat:withComItextpdfTextChunk:", "Phrase", NULL, 0x1, NULL },
    { "initWithNSString:", "Phrase", NULL, 0x1, NULL },
    { "initWithNSString:withComItextpdfTextFont:", "Phrase", NULL, 0x1, NULL },
    { "initWithFloat:withNSString:", "Phrase", NULL, 0x1, NULL },
    { "initWithFloat:withNSString:withComItextpdfTextFont:", "Phrase", NULL, 0x1, NULL },
    { "processWithComItextpdfTextElementListener:", "process", "Z", 0x1, NULL },
    { "type", NULL, "I", 0x1, NULL },
    { "getChunks", NULL, "Ljava.util.List;", 0x1, NULL },
    { "isContent", NULL, "Z", 0x1, NULL },
    { "isNestable", NULL, "Z", 0x1, NULL },
    { "addWithInt:withComItextpdfTextElement:", "add", "V", 0x1, NULL },
    { "addWithNSString:", "add", "Z", 0x1, NULL },
    { "addWithComItextpdfTextElement:", "add", "Z", 0x1, NULL },
    { "addAllWithJavaUtilCollection:", "addAll", "Z", 0x1, NULL },
    { "addChunkWithComItextpdfTextChunk:", "addChunk", "Z", 0x4, NULL },
    { "addSpecialWithComItextpdfTextElement:", "addSpecial", "V", 0x4, NULL },
    { "setLeadingWithFloat:withFloat:", "setLeading", "V", 0x1, NULL },
    { "setLeadingWithFloat:", "setLeading", "V", 0x1, NULL },
    { "setMultipliedLeadingWithFloat:", "setMultipliedLeading", "V", 0x1, NULL },
    { "setFontWithComItextpdfTextFont:", "setFont", "V", 0x1, NULL },
    { "getLeading", NULL, "F", 0x1, NULL },
    { "getMultipliedLeading", NULL, "F", 0x1, NULL },
    { "getTotalLeading", NULL, "F", 0x1, NULL },
    { "hasLeading", NULL, "Z", 0x1, NULL },
    { "getFont", NULL, "Lcom.itextpdf.text.Font;", 0x1, NULL },
    { "getContent", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "getHyphenation", NULL, "Lcom.itextpdf.text.pdf.HyphenationEvent;", 0x1, NULL },
    { "setHyphenationWithComItextpdfTextPdfHyphenationEvent:", "setHyphenation", "V", 0x1, NULL },
    { "getTabSettings", NULL, "Lcom.itextpdf.text.TabSettings;", 0x1, NULL },
    { "setTabSettingsWithComItextpdfTextTabSettings:", "setTabSettings", "V", 0x1, NULL },
    { "initWithBoolean:", "Phrase", NULL, 0x2, NULL },
    { "getInstanceWithNSString:", "getInstance", "Lcom.itextpdf.text.Phrase;", 0x19, NULL },
    { "getInstanceWithInt:withNSString:", "getInstance", "Lcom.itextpdf.text.Phrase;", 0x19, NULL },
    { "getInstanceWithInt:withNSString:withComItextpdfTextFont:", "getInstance", "Lcom.itextpdf.text.Phrase;", 0x19, NULL },
    { "trim", NULL, "Z", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x1a, "J", NULL, .constantValue.asLong = ComItextpdfTextPhrase_serialVersionUID },
    { "leading_", NULL, 0x4, "F", NULL,  },
    { "multipliedLeading_", NULL, 0x4, "F", NULL,  },
    { "font_", NULL, 0x4, "Lcom.itextpdf.text.Font;", NULL,  },
    { "hyphenation_", NULL, 0x4, "Lcom.itextpdf.text.pdf.HyphenationEvent;", NULL,  },
    { "tabSettings_", NULL, 0x4, "Lcom.itextpdf.text.TabSettings;", NULL,  },
  };
  static const char *superclass_type_args[] = {"Lcom.itextpdf.text.Element;"};
  static const J2ObjcClassInfo _ComItextpdfTextPhrase = { "Phrase", "com.itextpdf.text", NULL, 0x1, 40, methods, 6, fields, 1, superclass_type_args};
  return &_ComItextpdfTextPhrase;
}

@end

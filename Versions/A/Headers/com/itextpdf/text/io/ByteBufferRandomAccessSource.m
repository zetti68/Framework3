//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/io/ByteBufferRandomAccessSource.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/io/ByteBufferRandomAccessSource.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/io/ByteBufferRandomAccessSource.h"
#include "java/io/IOException.h"
#include "java/lang/Boolean.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/reflect/Method.h"
#include "java/nio/Buffer.h"
#include "java/nio/BufferUnderflowException.h"
#include "java/nio/ByteBuffer.h"
#include "java/security/AccessController.h"


#line 57
@implementation ComItextpdfTextIoByteBufferRandomAccessSource


#line 68
- (instancetype)initWithJavaNioByteBuffer:(JavaNioByteBuffer *)byteBuffer {
  if (self = [super init]) {
    
#line 69
    self->byteBuffer_ = byteBuffer;
  }
  return self;
}


#line 78
- (jint)getWithLong:(jlong)position {
  
#line 79
  if (position > JavaLangInteger_MAX_VALUE)
#line 80
  @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Position must be less than Integer.MAX_VALUE"];
  
#line 82
  @try {
    
#line 84
    if (position >= [((JavaNioByteBuffer *) nil_chk(byteBuffer_)) limit])
#line 85
    return -1;
    
#line 87
    jbyte b = [byteBuffer_ getWithInt:(jint) position];
    
#line 89
    jint n = b & (jint) 0xff;
    
#line 91
    return n;
  }
  @catch (
#line 92
  JavaNioBufferUnderflowException *e) {
    return -1;
  }
}


#line 103
- (jint)getWithLong:(jlong)position
      withByteArray:(IOSByteArray *)bytes
            withInt:(jint)off
            withInt:(jint)len {
  
#line 104
  if (position > JavaLangInteger_MAX_VALUE)
#line 105
  @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Position must be less than Integer.MAX_VALUE"];
  
#line 107
  if (position >= [((JavaNioByteBuffer *) nil_chk(byteBuffer_)) limit])
#line 108
  return -1;
  
#line 110
  (void) [byteBuffer_ positionWithInt:(jint) position];
  jint bytesFromThisBuffer = [JavaLangMath minWithInt:len withInt:[byteBuffer_ remaining]];
  (void) [byteBuffer_ getWithByteArray:bytes withInt:off withInt:bytesFromThisBuffer];
  
#line 114
  return bytesFromThisBuffer;
}


#line 122
- (jlong)length {
  
#line 123
  return [((JavaNioByteBuffer *) nil_chk(byteBuffer_)) limit];
}


#line 130
- (void)close {
  
#line 131
  [ComItextpdfTextIoByteBufferRandomAccessSource cleanWithJavaNioByteBuffer:byteBuffer_];
}


#line 139
+ (jboolean)cleanWithJavaNioByteBuffer:(JavaNioByteBuffer *)buffer {
  
#line 140
  if (buffer == nil || ![buffer isDirect])
#line 141
  return NO;
  
#line 143
  JavaLangBoolean *b = (JavaLangBoolean *) check_class_cast([JavaSecurityAccessController doPrivilegedWithJavaSecurityPrivilegedAction:[[ComItextpdfTextIoByteBufferRandomAccessSource_$1 alloc] initWithJavaNioByteBuffer:buffer]], [JavaLangBoolean class]);
  
#line 161
  return [((JavaLangBoolean *) nil_chk(b)) booleanValue];
}

- (void)copyAllFieldsTo:(ComItextpdfTextIoByteBufferRandomAccessSource *)other {
  [super copyAllFieldsTo:other];
  other->byteBuffer_ = byteBuffer_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithJavaNioByteBuffer:", "ByteBufferRandomAccessSource", NULL, 0x1, NULL },
    { "getWithLong:", "get", "I", 0x1, "Ljava.io.IOException;" },
    { "getWithLong:withByteArray:withInt:withInt:", "get", "I", 0x1, "Ljava.io.IOException;" },
    { "length", NULL, "J", 0x1, NULL },
    { "close", NULL, "V", 0x1, "Ljava.io.IOException;" },
    { "cleanWithJavaNioByteBuffer:", "clean", "Z", 0xa, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "byteBuffer_", NULL, 0x12, "Ljava.nio.ByteBuffer;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextIoByteBufferRandomAccessSource = { "ByteBufferRandomAccessSource", "com.itextpdf.text.io", NULL, 0x0, 6, methods, 1, fields, 0, NULL};
  return &_ComItextpdfTextIoByteBufferRandomAccessSource;
}

@end

@implementation ComItextpdfTextIoByteBufferRandomAccessSource_$1


#line 144
- (JavaLangBoolean *)run {
  
#line 145
  JavaLangBoolean *success = JavaLangBoolean_get_FALSE__();
  @try {
    JavaLangReflectMethod *getCleanerMethod = [[((JavaNioByteBuffer *) nil_chk(val$buffer_)) getClass] getMethod:@"cleaner" parameterTypes:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    [((JavaLangReflectMethod *) nil_chk(getCleanerMethod)) setAccessibleWithBoolean:YES];
    id cleaner = [getCleanerMethod invokeWithId:val$buffer_ withNSObjectArray:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    JavaLangReflectMethod *clean = [[nil_chk(cleaner) getClass] getMethod:@"clean" parameterTypes:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    (void) [((JavaLangReflectMethod *) nil_chk(clean)) invokeWithId:cleaner withNSObjectArray:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    success = JavaLangBoolean_get_TRUE__();
  }
  @catch (
#line 153
  JavaLangException *e) {
  }
  
#line 157
  return success;
}

- (instancetype)initWithJavaNioByteBuffer:(JavaNioByteBuffer *)capture$0 {
  val$buffer_ = capture$0;
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "run", NULL, "Ljava.lang.Boolean;", 0x1, NULL },
    { "initWithJavaNioByteBuffer:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$buffer_", NULL, 0x1012, "Ljava.nio.ByteBuffer;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextIoByteBufferRandomAccessSource_$1 = { "$1", "com.itextpdf.text.io", "ByteBufferRandomAccessSource", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_ComItextpdfTextIoByteBufferRandomAccessSource_$1;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/io/PagedChannelRandomAccessSource.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/io/PagedChannelRandomAccessSource.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "com/itextpdf/text/io/MappedChannelRandomAccessSource.h"
#include "com/itextpdf/text/io/PagedChannelRandomAccessSource.h"
#include "com/itextpdf/text/io/RandomAccessSource.h"
#include "java/io/IOException.h"
#include "java/lang/Math.h"
#include "java/nio/channels/FileChannel.h"
#include "java/util/Iterator.h"
#include "java/util/LinkedList.h"


#line 56
@implementation ComItextpdfTextIoPagedChannelRandomAccessSource


#line 84
- (instancetype)initWithJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)channel {
  return
#line 85
  [self initComItextpdfTextIoPagedChannelRandomAccessSourceWithJavaNioChannelsFileChannel:channel withInt:ComItextpdfTextIoPagedChannelRandomAccessSource_DEFAULT_TOTAL_BUFSIZE withInt:ComItextpdfTextIoPagedChannelRandomAccessSource_DEFAULT_MAX_OPEN_BUFFERS];
}


#line 94
- (instancetype)initComItextpdfTextIoPagedChannelRandomAccessSourceWithJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)channel
                                                                                          withInt:(jint)totalBufferSize
                                                                                          withInt:(jint)maxOpenBuffers {
  if (self =
#line 95
  [super initWithComItextpdfTextIoRandomAccessSourceArray:[ComItextpdfTextIoPagedChannelRandomAccessSource buildSourcesWithJavaNioChannelsFileChannel:channel withInt:totalBufferSize / maxOpenBuffers]]) {
    
#line 96
    self->channel_ = channel;
    
#line 97
    self->bufferSize_ = totalBufferSize / maxOpenBuffers;
    
#line 98
    self->mru_ = [[ComItextpdfTextIoPagedChannelRandomAccessSource_MRU alloc] initWithInt:maxOpenBuffers];
  }
  return self;
}

- (instancetype)initWithJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)channel
                                           withInt:(jint)totalBufferSize
                                           withInt:(jint)maxOpenBuffers {
  return [self initComItextpdfTextIoPagedChannelRandomAccessSourceWithJavaNioChannelsFileChannel:
#line 94
channel withInt:totalBufferSize withInt:maxOpenBuffers];
}


#line 108
+ (IOSObjectArray *)buildSourcesWithJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)channel
                                                       withInt:(jint)bufferSize {
  
#line 109
  jlong size = [((JavaNioChannelsFileChannel *) nil_chk(channel)) size];
  if (size <= 0)
#line 111
  @throw [[JavaIoIOException alloc] initWithNSString:@"File size must be greater than zero"];
  
#line 113
  jint bufferCount = (jint) (size / bufferSize) + (size % bufferSize == 0 ? 0 : 1);
  
#line 115
  IOSObjectArray *sources = [IOSObjectArray arrayWithLength:bufferCount type:[IOSClass classWithClass:[ComItextpdfTextIoMappedChannelRandomAccessSource class]]];
  for (jint i = 0; i < bufferCount; i++) {
    jlong pageOffset = (jlong) i * bufferSize;
    jlong pageLength = [JavaLangMath minWithLong:size - pageOffset withLong:bufferSize];
    IOSObjectArray_SetAndConsume(sources, i, [[ComItextpdfTextIoMappedChannelRandomAccessSource alloc] initWithJavaNioChannelsFileChannel:channel withLong:pageOffset withLong:pageLength]);
  }
  return sources;
}


#line 129
- (jint)getStartingSourceIndexWithLong:(jlong)offset {
  return (jint) (offset / bufferSize_);
}


#line 138
- (void)sourceReleasedWithComItextpdfTextIoRandomAccessSource:(id<ComItextpdfTextIoRandomAccessSource>)source {
  
#line 139
  id<ComItextpdfTextIoRandomAccessSource> old = [((ComItextpdfTextIoPagedChannelRandomAccessSource_MRU *) nil_chk(mru_)) enqueueWithId:source];
  if (old != nil)
#line 141
  [old close];
}


#line 149
- (void)sourceInUseWithComItextpdfTextIoRandomAccessSource:(id<ComItextpdfTextIoRandomAccessSource>)source {
  
#line 150
  [((ComItextpdfTextIoMappedChannelRandomAccessSource *) nil_chk(((ComItextpdfTextIoMappedChannelRandomAccessSource *) check_class_cast(source, [ComItextpdfTextIoMappedChannelRandomAccessSource class])))) open];
}


#line 158
- (void)close {
  
#line 159
  [super close];
  [((JavaNioChannelsFileChannel *) nil_chk(channel_)) close];
}

- (void)copyAllFieldsTo:(ComItextpdfTextIoPagedChannelRandomAccessSource *)other {
  [super copyAllFieldsTo:other];
  other->bufferSize_ = bufferSize_;
  other->channel_ = channel_;
  other->mru_ = mru_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithJavaNioChannelsFileChannel:", "PagedChannelRandomAccessSource", NULL, 0x1, "Ljava.io.IOException;" },
    { "initWithJavaNioChannelsFileChannel:withInt:withInt:", "PagedChannelRandomAccessSource", NULL, 0x1, "Ljava.io.IOException;" },
    { "buildSourcesWithJavaNioChannelsFileChannel:withInt:", "buildSources", "[Lcom.itextpdf.text.io.RandomAccessSource;", 0xa, "Ljava.io.IOException;" },
    { "getStartingSourceIndexWithLong:", "getStartingSourceIndex", "I", 0x4, NULL },
    { "sourceReleasedWithComItextpdfTextIoRandomAccessSource:", "sourceReleased", "V", 0x4, "Ljava.io.IOException;" },
    { "sourceInUseWithComItextpdfTextIoRandomAccessSource:", "sourceInUse", "V", 0x4, "Ljava.io.IOException;" },
    { "close", NULL, "V", 0x1, "Ljava.io.IOException;" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_TOTAL_BUFSIZE_", NULL, 0x19, "I", NULL, .constantValue.asInt = ComItextpdfTextIoPagedChannelRandomAccessSource_DEFAULT_TOTAL_BUFSIZE },
    { "DEFAULT_MAX_OPEN_BUFFERS_", NULL, 0x19, "I", NULL, .constantValue.asInt = ComItextpdfTextIoPagedChannelRandomAccessSource_DEFAULT_MAX_OPEN_BUFFERS },
    { "bufferSize_", NULL, 0x12, "I", NULL,  },
    { "channel_", NULL, 0x12, "Ljava.nio.channels.FileChannel;", NULL,  },
    { "mru_", NULL, 0x12, "Lcom.itextpdf.text.io.PagedChannelRandomAccessSource$MRU;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextIoPagedChannelRandomAccessSource = { "PagedChannelRandomAccessSource", "com.itextpdf.text.io", NULL, 0x0, 7, methods, 5, fields, 0, NULL};
  return &_ComItextpdfTextIoPagedChannelRandomAccessSource;
}

@end


#line 163
@implementation ComItextpdfTextIoPagedChannelRandomAccessSource_MRU


#line 178
- (instancetype)initWithInt:(jint)limit {
  if (self = [super init]) {
    queue_ =
#line 172
    [[JavaUtilLinkedList alloc] init];
    
#line 179
    self->limit_ = limit;
  }
  return self;
}


#line 187
- (id)enqueueWithId:(id)newElement {
  
#line 189
  if ([((JavaUtilLinkedList *) nil_chk(queue_)) size] > 0 && [queue_ getFirst] == newElement)
#line 190
  return nil;
  
#line 192
  for (id<JavaUtilIterator> it = [queue_ iterator]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
    id element = [it next];
    if (newElement == element) {
      [it remove];
      [queue_ addFirstWithId:newElement];
      return nil;
    }
  }
  [queue_ addFirstWithId:newElement];
  
#line 202
  if ([queue_ size] > limit_)
#line 203
  return [queue_ removeLast];
  
#line 205
  return nil;
}

- (void)copyAllFieldsTo:(ComItextpdfTextIoPagedChannelRandomAccessSource_MRU *)other {
  [super copyAllFieldsTo:other];
  other->limit_ = limit_;
  other->queue_ = queue_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:", "MRU", NULL, 0x1, NULL },
    { "enqueueWithId:", "enqueue", "TE;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "limit_", NULL, 0x12, "I", NULL,  },
    { "queue_", NULL, 0x2, "Ljava.util.LinkedList;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextIoPagedChannelRandomAccessSource_MRU = { "MRU", "com.itextpdf.text.io", "PagedChannelRandomAccessSource", 0xa, 2, methods, 2, fields, 0, NULL};
  return &_ComItextpdfTextIoPagedChannelRandomAccessSource_MRU;
}

@end

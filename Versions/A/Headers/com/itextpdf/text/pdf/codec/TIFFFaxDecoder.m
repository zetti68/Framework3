//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/codec/TIFFFaxDecoder.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/codec/TIFFFaxDecoder.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/exceptions/InvalidImageException.h"
#include "com/itextpdf/text/pdf/codec/TIFFFaxDecoder.h"
#include "java/lang/RuntimeException.h"

BOOL ComItextpdfTextPdfCodecTIFFFaxDecoder_initialized = NO;


#line 54
@implementation ComItextpdfTextPdfCodecTIFFFaxDecoder

IOSIntArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_;
IOSIntArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_;
IOSByteArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_white_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_initBlack_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_twoBitBlack_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_black_;
IOSByteArray * ComItextpdfTextPdfCodecTIFFFaxDecoder_twoDCodes_;


#line 591
- (instancetype)initWithInt:(jint)fillOrder
                    withInt:(jint)w
                    withInt:(jint)h {
  if (self = [super init]) {
    changingElemSize_ =
#line 63
    0;
    lastChangingElement_ =
#line 68
    0;
    compression_ =
#line 70
    2;
    uncompressedMode_ =
#line 73
    0;
    fillBits_ =
#line 74
    0;
    
#line 592
    self->fillOrder_ = fillOrder;
    
#line 593
    self->w_ = w;
    
#line 594
    self->h_ = h;
    
#line 596
    self->bitPointer_ = 0;
    
#line 597
    self->bytePointer_ = 0;
    
#line 598
    self->prevChangingElems_ = [IOSIntArray arrayWithLength:2 * w];
    
#line 599
    self->currChangingElems_ = [IOSIntArray arrayWithLength:2 * w];
  }
  return self;
}


#line 608
+ (void)reverseBitsWithByteArray:(IOSByteArray *)b {
  
#line 609
  for (jint k = 0; k < ((IOSByteArray *) nil_chk(b))->size_; ++k)
#line 610
  *IOSByteArray_GetRef(b, k) = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_), IOSByteArray_Get(b, k) & (jint) 0xff);
}


#line 615
- (void)decode1DWithByteArray:(IOSByteArray *)buffer
                withByteArray:(IOSByteArray *)compData
                      withInt:(jint)startX
                      withInt:(jint)height {
  self->data_ = compData;
  
#line 618
  jint lineOffset = 0;
  jint scanlineStride = (w_ + 7) / 8;
  
#line 621
  bitPointer_ = 0;
  bytePointer_ = 0;
  
#line 624
  for (jint i = 0; i < height; i++) {
    [self decodeNextScanlineWithByteArray:buffer withInt:lineOffset withInt:startX];
    lineOffset += scanlineStride;
  }
}


#line 630
- (void)decodeNextScanlineWithByteArray:(IOSByteArray *)buffer
                                withInt:(jint)lineOffset
                                withInt:(jint)bitOffset {
  
#line 631
  jint bits = 0, code = 0, isT = 0;
  jint current, entry_, twoBits;
  jboolean isWhite = YES;
  
#line 636
  changingElemSize_ = 0;
  
#line 639
  while (bitOffset < w_) {
    while (isWhite) {
      
#line 642
      current = [self nextNBitsWithInt:10];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_white_), current);
      
#line 646
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x0f;
      
#line 649
      if (bits == 12) {
        
#line 651
        twoBits = [self nextLesserThan8BitsWithInt:2];
        
#line 653
        current = ((LShift32(current, 2)) & (jint) 0x000c) | twoBits;
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_), current);
        bits = (URShift32(entry_, 1)) & (jint) 0x07;
        code = (URShift32(entry_, 4)) & (jint) 0x0fff;
        bitOffset += code;
        
#line 659
        [self updatePointerWithInt:4 - bits];
      }
      else
#line 660
      if (bits == 0) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"invalid.code.encountered" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
      }
      else
#line 662
      if (bits == 15) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"eol.code.word.encountered.in.white.run" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
      }
      else {
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        bitOffset += code;
        
#line 669
        [self updatePointerWithInt:10 - bits];
        if (isT == 0) {
          isWhite = NO;
          *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
        }
      }
    }
    
#line 679
    if (bitOffset == w_) {
      if (compression_ == 2) {
        [self advancePointer];
      }
      break;
    }
    
#line 686
    while (!isWhite) {
      
#line 688
      current = [self nextLesserThan8BitsWithInt:4];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_initBlack_), current);
      
#line 692
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x000f;
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      
#line 696
      if (code == 100) {
        current = [self nextNBitsWithInt:9];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_black_), current);
        
#line 701
        isT = entry_ & (jint) 0x0001;
        bits = (URShift32(entry_, 1)) & (jint) 0x000f;
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        
#line 705
        if (bits == 12) {
          
#line 707
          [self updatePointerWithInt:5];
          current = [self nextLesserThan8BitsWithInt:4];
          entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_), current);
          bits = (URShift32(entry_, 1)) & (jint) 0x07;
          code = (URShift32(entry_, 4)) & (jint) 0x0fff;
          
#line 713
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:code];
          bitOffset += code;
          
#line 716
          [self updatePointerWithInt:4 - bits];
        }
        else
#line 717
        if (bits == 15) {
          
#line 719
          @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"eol.code.word.encountered.in.black.run" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
        }
        else {
          
#line 721
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:code];
          bitOffset += code;
          
#line 724
          [self updatePointerWithInt:9 - bits];
          if (isT == 0) {
            isWhite = YES;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
          }
        }
      }
      else
#line 730
      if (code == 200) {
        
#line 732
        current = [self nextLesserThan8BitsWithInt:2];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_twoBitBlack_), current);
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        bits = (URShift32(entry_, 1)) & (jint) 0x0f;
        
#line 737
        [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:code];
        bitOffset += code;
        
#line 740
        [self updatePointerWithInt:2 - bits];
        isWhite = YES;
        *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
      }
      else {
        [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:code];
        bitOffset += code;
        
#line 748
        [self updatePointerWithInt:4 - bits];
        isWhite = YES;
        *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
      }
    }
    
#line 755
    if (bitOffset == w_) {
      if (compression_ == 2) {
        [self advancePointer];
      }
      break;
    }
  }
  
#line 763
  *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
}


#line 768
- (void)decode2DWithByteArray:(IOSByteArray *)buffer
                withByteArray:(IOSByteArray *)compData
                      withInt:(jint)startX
                      withInt:(jint)height
                     withLong:(jlong)tiffT4Options {
  
#line 769
  self->data_ = compData;
  compression_ = 3;
  
#line 772
  bitPointer_ = 0;
  bytePointer_ = 0;
  
#line 775
  jint scanlineStride = (w_ + 7) / 8;
  
#line 777
  jint a0, a1, b1, b2;
  IOSIntArray *b = [IOSIntArray arrayWithLength:2];
  jint entry_, code, bits;
  jboolean isWhite;
  jint currIndex = 0;
  IOSIntArray *temp;
  
#line 790
  oneD_ = (jint) (tiffT4Options & (jint) 0x01);
  uncompressedMode_ = (jint) (RShift64((tiffT4Options & (jint) 0x02), 1));
  fillBits_ = (jint) (RShift64((tiffT4Options & (jint) 0x04), 2));
  
#line 795
  if ([self readEOLWithBoolean:YES] != 1) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"first.scanline.must.be.1d.encoded" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  
#line 799
  jint lineOffset = 0;
  jint bitOffset;
  
#line 804
  [self decodeNextScanlineWithByteArray:buffer withInt:lineOffset withInt:startX];
  lineOffset += scanlineStride;
  
#line 807
  for (jint lines = 1; lines < height; lines++) {
    
#line 811
    if ([self readEOLWithBoolean:NO] == 0) {
      
#line 816
      temp = prevChangingElems_;
      prevChangingElems_ = currChangingElems_;
      currChangingElems_ = temp;
      currIndex = 0;
      
#line 822
      a0 = -1;
      isWhite = YES;
      bitOffset = startX;
      
#line 826
      lastChangingElement_ = 0;
      
#line 828
      while (bitOffset < w_) {
        
#line 830
        [self getNextChangingElementWithInt:a0 withBoolean:isWhite withIntArray:b];
        
#line 832
        b1 = IOSIntArray_Get(b, 0);
        b2 = IOSIntArray_Get(b, 1);
        
#line 836
        entry_ = [self nextLesserThan8BitsWithInt:7];
        
#line 839
        entry_ = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_twoDCodes_), entry_) & (jint) 0xff;
        
#line 842
        code = URShift32((entry_ & (jint) 0x78), 3);
        bits = entry_ & (jint) 0x07;
        
#line 845
        if (code == 0) {
          if (!isWhite) {
            [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:
#line 848
            b2 - bitOffset];
          }
          bitOffset = a0 = b2;
          
#line 853
          [self updatePointerWithInt:7 - bits];
        }
        else
#line 854
        if (code == 1) {
          
#line 856
          [self updatePointerWithInt:7 - bits];
          
#line 859
          jint number;
          if (isWhite) {
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
            
#line 865
            number = [self decodeBlackCodeWord];
            [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(currChangingElems_, currIndex++) = bitOffset;
          }
          else {
            
#line 870
            number = [self decodeBlackCodeWord];
            [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
            
#line 875
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(currChangingElems_, currIndex++) = bitOffset;
          }
          
#line 880
          a0 = bitOffset;
        }
        else
#line 881
        if (code <= 8) {
          
#line 883
          a1 = b1 + (code - 5);
          
#line 885
          *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = a1;
          
#line 889
          if (!isWhite) {
            [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:
#line 891
            a1 - bitOffset];
          }
          bitOffset = a0 = a1;
          isWhite = !isWhite;
          
#line 896
          [self updatePointerWithInt:7 - bits];
        }
        else {
          
#line 898
          @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"invalid.code.encountered.while.decoding.2d.group.3.compressed.data" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
        }
      }
      
#line 904
      *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
      changingElemSize_ = currIndex;
    }
    else {
      [self decodeNextScanlineWithByteArray:buffer withInt:lineOffset withInt:startX];
    }
    
#line 911
    lineOffset += scanlineStride;
  }
}


#line 915
- (void)decodeT6WithByteArray:(IOSByteArray *)buffer
                withByteArray:(IOSByteArray *)compData
                      withInt:(jint)startX
                      withInt:(jint)height
                     withLong:(jlong)tiffT6Options {
  
#line 920
  self->data_ = compData;
  compression_ = 4;
  
#line 923
  bitPointer_ = 0;
  bytePointer_ = 0;
  
#line 926
  jint scanlineStride = (w_ + 7) / 8;
  
#line 928
  jint a0, a1, b1, b2;
  jint entry_, code, bits;
  jboolean isWhite;
  jint currIndex;
  IOSIntArray *temp;
  
#line 935
  IOSIntArray *b = [IOSIntArray arrayWithLength:2];
  
#line 940
  uncompressedMode_ = (jint) (RShift64((tiffT6Options & (jint) 0x02), 1));
  
#line 943
  IOSIntArray *cce = currChangingElems_;
  
#line 948
  changingElemSize_ = 0;
  *IOSIntArray_GetRef(nil_chk(cce), changingElemSize_++) = w_;
  *IOSIntArray_GetRef(cce, changingElemSize_++) = w_;
  
#line 952
  jint lineOffset = 0;
  jint bitOffset;
  
#line 955
  for (jint lines = 0; lines < height; lines++) {
    
#line 957
    a0 = -1;
    isWhite = YES;
    
#line 963
    temp = prevChangingElems_;
    prevChangingElems_ = currChangingElems_;
    cce = currChangingElems_ = temp;
    currIndex = 0;
    
#line 969
    bitOffset = startX;
    
#line 972
    lastChangingElement_ = 0;
    
#line 975
    escape:
#line 976
    while (bitOffset < w_) {
      
#line 978
      [self getNextChangingElementWithInt:a0 withBoolean:isWhite withIntArray:b];
      b1 = IOSIntArray_Get(b, 0);
      b2 = IOSIntArray_Get(b, 1);
      
#line 983
      entry_ = [self nextLesserThan8BitsWithInt:7];
      
#line 985
      entry_ = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_twoDCodes_), entry_) & (jint) 0xff;
      
#line 988
      code = URShift32((entry_ & (jint) 0x78), 3);
      bits = entry_ & (jint) 0x07;
      
#line 991
      if (code == 0) {
        
#line 993
        if (!isWhite) {
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:
#line 995
          b2 - bitOffset];
        }
        bitOffset = a0 = b2;
        
#line 1000
        [self updatePointerWithInt:7 - bits];
      }
      else
#line 1001
      if (code == 1) {
        
#line 1003
        [self updatePointerWithInt:7 - bits];
        
#line 1006
        jint number;
        if (isWhite) {
          
#line 1009
          number = [self decodeWhiteCodeWord];
          bitOffset += number;
          *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
          
#line 1013
          number = [self decodeBlackCodeWord];
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:number];
          bitOffset += number;
          *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
        }
        else {
          number = [self decodeBlackCodeWord];
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:number];
          bitOffset += number;
          *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
          
#line 1024
          number = [self decodeWhiteCodeWord];
          bitOffset += number;
          *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
        }
        
#line 1029
        a0 = bitOffset;
      }
      else
#line 1030
      if (code <= 8) {
        a1 = b1 + (code - 5);
        *IOSIntArray_GetRef(cce, currIndex++) = a1;
        
#line 1036
        if (!isWhite) {
          [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:
#line 1038
          a1 - bitOffset];
        }
        bitOffset = a0 = a1;
        isWhite = !isWhite;
        
#line 1043
        [self updatePointerWithInt:7 - bits];
      }
      else
#line 1044
      if (code == 11) {
        if ([self nextLesserThan8BitsWithInt:3] != 7) {
          @throw [[ComItextpdfTextExceptionsInvalidImageException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"invalid.code.encountered.while.decoding.2d.group.4.compressed.data" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
        }
        
#line 1049
        jint zeros = 0;
        jboolean exit = NO;
        
#line 1052
        while (!exit) {
          while ([self nextLesserThan8BitsWithInt:1] != 1) {
            zeros++;
          }
          
#line 1057
          if (zeros > 5) {
            
#line 1061
            zeros = zeros - 6;
            
#line 1063
            if (!isWhite && (zeros > 0)) {
              *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
            }
            
#line 1068
            bitOffset += zeros;
            if (zeros > 0) {
              
#line 1071
              isWhite = YES;
            }
            
#line 1076
            if ([self nextLesserThan8BitsWithInt:1] == 0) {
              if (!isWhite) {
                *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
              }
              isWhite = YES;
            }
            else {
              
#line 1082
              if (isWhite) {
                *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
              }
              isWhite = NO;
            }
            
#line 1088
            exit = YES;
          }
          
#line 1091
          if (zeros == 5) {
            if (!isWhite) {
              *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
            }
            bitOffset += zeros;
            
#line 1098
            isWhite = YES;
          }
          else {
            
#line 1100
            bitOffset += zeros;
            
#line 1102
            *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
            [self setToBlackWithByteArray:buffer withInt:lineOffset withInt:bitOffset withInt:1];
            ++bitOffset;
            
#line 1107
            isWhite = NO;
          }
        }
      }
      else {
        
#line 1116
        bitOffset = w_;
        [self updatePointerWithInt:7 - bits];
      }
    }
    
#line 1124
    if (currIndex < cce->size_)
#line 1125
    *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
    
#line 1128
    changingElemSize_ = currIndex;
    
#line 1130
    lineOffset += scanlineStride;
  }
}


#line 1134
- (void)setToBlackWithByteArray:(IOSByteArray *)buffer
                        withInt:(jint)lineOffset
                        withInt:(jint)bitOffset
                        withInt:(jint)numBits {
  
#line 1137
  jint bitNum = 8 * lineOffset + bitOffset;
  jint lastBit = bitNum + numBits;
  
#line 1140
  jint byteNum = RShift32(bitNum, 3);
  
#line 1143
  jint shift = bitNum & (jint) 0x7;
  if (shift > 0) {
    jint maskVal = LShift32(1, (7 - shift));
    jbyte val = IOSByteArray_Get(nil_chk(buffer), byteNum);
    while (maskVal > 0 && bitNum < lastBit) {
      val |= maskVal;
      RShiftAssignInt(&maskVal, 1);
      ++bitNum;
    }
    *IOSByteArray_GetRef(buffer, byteNum) = val;
  }
  
#line 1156
  byteNum = RShift32(bitNum, 3);
  while (bitNum < lastBit - 7) {
    *IOSByteArray_GetRef(nil_chk(buffer), byteNum++) = (jbyte) 255;
    bitNum += 8;
  }
  
#line 1163
  while (bitNum < lastBit) {
    byteNum = RShift32(bitNum, 3);
    if (recoverFromImageError_ && !(byteNum < ((IOSByteArray *) nil_chk(buffer))->size_)) {
    }
    else {
      *IOSByteArray_GetRef(nil_chk(buffer), byteNum) |= LShift32(1, (7 - (bitNum & (jint) 0x7)));
    }
    ++bitNum;
  }
}


#line 1175
- (jint)decodeWhiteCodeWord {
  
#line 1176
  jint current, entry_, bits, isT, twoBits, code = -1;
  jint runLength = 0;
  jboolean isWhite = YES;
  
#line 1180
  while (isWhite) {
    current = [self nextNBitsWithInt:10];
    entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_white_), current);
    
#line 1185
    isT = entry_ & (jint) 0x0001;
    bits = (URShift32(entry_, 1)) & (jint) 0x0f;
    
#line 1188
    if (bits == 12) {
      
#line 1190
      twoBits = [self nextLesserThan8BitsWithInt:2];
      
#line 1192
      current = ((LShift32(current, 2)) & (jint) 0x000c) | twoBits;
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_), current);
      bits = (URShift32(entry_, 1)) & (jint) 0x07;
      code = (URShift32(entry_, 4)) & (jint) 0x0fff;
      runLength += code;
      [self updatePointerWithInt:4 - bits];
    }
    else
#line 1198
    if (bits == 0) {
      @throw [[ComItextpdfTextExceptionsInvalidImageException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"invalid.code.encountered" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
    else
#line 1200
    if (bits == 15) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"eol.code.word.encountered.in.white.run" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
    else {
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      runLength += code;
      [self updatePointerWithInt:10 - bits];
      if (isT == 0) {
        isWhite = NO;
      }
    }
  }
  
#line 1213
  return runLength;
}


#line 1217
- (jint)decodeBlackCodeWord {
  
#line 1218
  jint current, entry_, bits, isT, code = -1;
  jint runLength = 0;
  jboolean isWhite = NO;
  
#line 1222
  while (!isWhite) {
    current = [self nextLesserThan8BitsWithInt:4];
    entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_initBlack_), current);
    
#line 1227
    isT = entry_ & (jint) 0x0001;
    bits = (URShift32(entry_, 1)) & (jint) 0x000f;
    code = (URShift32(entry_, 5)) & (jint) 0x07ff;
    
#line 1231
    if (code == 100) {
      current = [self nextNBitsWithInt:9];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_black_), current);
      
#line 1236
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x000f;
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      
#line 1240
      if (bits == 12) {
        
#line 1242
        [self updatePointerWithInt:5];
        current = [self nextLesserThan8BitsWithInt:4];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_), current);
        bits = (URShift32(entry_, 1)) & (jint) 0x07;
        code = (URShift32(entry_, 4)) & (jint) 0x0fff;
        runLength += code;
        
#line 1249
        [self updatePointerWithInt:4 - bits];
      }
      else
#line 1250
      if (bits == 15) {
        
#line 1252
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"eol.code.word.encountered.in.black.run" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
      }
      else {
        
#line 1254
        runLength += code;
        [self updatePointerWithInt:9 - bits];
        if (isT == 0) {
          isWhite = YES;
        }
      }
    }
    else
#line 1260
    if (code == 200) {
      
#line 1262
      current = [self nextLesserThan8BitsWithInt:2];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_twoBitBlack_), current);
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      runLength += code;
      bits = (URShift32(entry_, 1)) & (jint) 0x0f;
      [self updatePointerWithInt:2 - bits];
      isWhite = YES;
    }
    else {
      runLength += code;
      [self updatePointerWithInt:4 - bits];
      isWhite = YES;
    }
  }
  
#line 1277
  return runLength;
}


#line 1280
- (jint)readEOLWithBoolean:(jboolean)isFirstEOL {
  
#line 1281
  if (fillBits_ == 0) {
    jint next12Bits = [self nextNBitsWithInt:12];
    if (isFirstEOL && next12Bits == 0) {
      
#line 1290
      if ([self nextNBitsWithInt:4] == 1) {
        
#line 1294
        fillBits_ = 1;
        return 1;
      }
    }
    if (next12Bits != 1) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"scanline.must.begin.with.eol.code.word" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
  }
  else
#line 1301
  if (fillBits_ == 1) {
    
#line 1307
    jint bitsLeft = 8 - bitPointer_;
    
#line 1309
    if ([self nextNBitsWithInt:bitsLeft] != 0) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"all.fill.bits.preceding.eol.code.must.be.0" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
    
#line 1317
    if (bitsLeft < 4) {
      if ([self nextNBitsWithInt:8] != 0) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"all.fill.bits.preceding.eol.code.must.be.0" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
      }
    }
    
#line 1326
    jint n;
    while ((n = [self nextNBitsWithInt:8]) != 1) {
      
#line 1329
      if (n != 0) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"all.fill.bits.preceding.eol.code.must.be.0" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
      }
    }
  }
  
#line 1336
  if (oneD_ == 0) {
    return 1;
  }
  else {
    
#line 1341
    return [self nextLesserThan8BitsWithInt:1];
  }
}


#line 1345
- (void)getNextChangingElementWithInt:(jint)a0
                          withBoolean:(jboolean)isWhite
                         withIntArray:(IOSIntArray *)ret {
  
#line 1347
  IOSIntArray *pce = self->prevChangingElems_;
  jint ces = self->changingElemSize_;
  
#line 1353
  jint start = lastChangingElement_ > 0 ? lastChangingElement_ - 1 : 0;
  if (isWhite) {
    start &= ~(jint) 0x1;
  }
  else {
    
#line 1357
    start |= (jint) 0x1;
  }
  
#line 1360
  jint i = start;
  for (; i < ces; i += 2) {
    jint temp = IOSIntArray_Get(nil_chk(pce), i);
    if (temp > a0) {
      lastChangingElement_ = i;
      *IOSIntArray_GetRef(nil_chk(ret), 0) = temp;
      break;
    }
  }
  
#line 1370
  if (i + 1 < ces) {
    *IOSIntArray_GetRef(nil_chk(ret), 1) = IOSIntArray_Get(nil_chk(pce), i + 1);
  }
}


#line 1375
- (jint)nextNBitsWithInt:(jint)bitsToGet {
  
#line 1376
  jbyte b, next, next2next;
  jint l = ((IOSByteArray *) nil_chk(data_))->size_ - 1;
  jint bp = self->bytePointer_;
  
#line 1380
  if (fillOrder_ == 1) {
    b = IOSByteArray_Get(data_, bp);
    
#line 1383
    if (bp == l) {
      next = (jint) 0x00;
      next2next = (jint) 0x00;
    }
    else
#line 1386
    if ((bp + 1) == l) {
      next = IOSByteArray_Get(data_, bp + 1);
      next2next = (jint) 0x00;
    }
    else {
      
#line 1390
      next = IOSByteArray_Get(data_, bp + 1);
      next2next = IOSByteArray_Get(data_, bp + 2);
    }
  }
  else
#line 1393
  if (fillOrder_ == 2) {
    b = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_), IOSByteArray_Get(data_, bp) & (jint) 0xff);
    
#line 1396
    if (bp == l) {
      next = (jint) 0x00;
      next2next = (jint) 0x00;
    }
    else
#line 1399
    if ((bp + 1) == l) {
      next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
      next2next = (jint) 0x00;
    }
    else {
      
#line 1403
      next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
      next2next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_, IOSByteArray_Get(data_, bp + 2) & (jint) 0xff);
    }
  }
  else {
    
#line 1407
    @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"tiff.fill.order.tag.must.be.either.1.or.2" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  
#line 1410
  jint bitsLeft = 8 - bitPointer_;
  jint bitsFromNextByte = bitsToGet - bitsLeft;
  jint bitsFromNext2NextByte = 0;
  if (bitsFromNextByte > 8) {
    bitsFromNext2NextByte = bitsFromNextByte - 8;
    bitsFromNextByte = 8;
  }
  
#line 1418
  bytePointer_++;
  
#line 1420
  jint i1 = LShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_), bitsLeft)), (bitsToGet - bitsLeft));
  jint i2 = URShift32((next & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_), bitsFromNextByte)), (8 - bitsFromNextByte));
  
#line 1423
  jint i3 = 0;
  if (bitsFromNext2NextByte != 0) {
    LShiftAssignInt(&i2, bitsFromNext2NextByte);
    i3 = URShift32((next2next & IOSIntArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_, bitsFromNext2NextByte)),
#line 1427
    (8 - bitsFromNext2NextByte));
    i2 |= i3;
    bytePointer_++;
    bitPointer_ = bitsFromNext2NextByte;
  }
  else {
    
#line 1432
    if (bitsFromNextByte == 8) {
      bitPointer_ = 0;
      bytePointer_++;
    }
    else {
      
#line 1436
      bitPointer_ = bitsFromNextByte;
    }
  }
  
#line 1440
  jint i = i1 | i2;
  return i;
}


#line 1444
- (jint)nextLesserThan8BitsWithInt:(jint)bitsToGet {
  
#line 1445
  jbyte b = 0, next = 0;
  jint l = ((IOSByteArray *) nil_chk(data_))->size_ - 1;
  jint bp = self->bytePointer_;
  
#line 1449
  if (fillOrder_ == 1) {
    b = IOSByteArray_Get(data_, bp);
    if (bp == l) {
      next = (jint) 0x00;
    }
    else {
      
#line 1454
      next = IOSByteArray_Get(data_, bp + 1);
    }
  }
  else
#line 1456
  if (fillOrder_ == 2) {
    if (recoverFromImageError_ && !(bp < data_->size_)) {
    }
    else {
      b = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_), IOSByteArray_Get(data_, bp) & (jint) 0xff);
      if (bp == l) {
        next = (jint) 0x00;
      }
      else {
        
#line 1464
        next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
      }
    }
  }
  else {
    
#line 1468
    @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"tiff.fill.order.tag.must.be.either.1.or.2" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  
#line 1471
  jint bitsLeft = 8 - bitPointer_;
  jint bitsFromNextByte = bitsToGet - bitsLeft;
  
#line 1474
  jint shift = bitsLeft - bitsToGet;
  jint i1, i2;
  if (shift >= 0) {
    i1 = URShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_), bitsLeft)), shift);
    bitPointer_ += bitsToGet;
    if (bitPointer_ == 8) {
      bitPointer_ = 0;
      bytePointer_++;
    }
  }
  else {
    
#line 1484
    i1 = LShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_), bitsLeft)), (-shift));
    i2 = URShift32((next & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_), bitsFromNextByte)), (8 - bitsFromNextByte));
    
#line 1487
    i1 |= i2;
    bytePointer_++;
    bitPointer_ = bitsFromNextByte;
  }
  
#line 1492
  return i1;
}


#line 1496
- (void)updatePointerWithInt:(jint)bitsToMoveBack {
  
#line 1497
  jint i = bitPointer_ - bitsToMoveBack;
  
#line 1499
  if (i < 0) {
    bytePointer_--;
    bitPointer_ = 8 + i;
  }
  else {
    
#line 1503
    bitPointer_ = i;
  }
}


#line 1508
- (jboolean)advancePointer {
  
#line 1509
  if (bitPointer_ != 0) {
    bytePointer_++;
    bitPointer_ = 0;
  }
  
#line 1514
  return YES;
}


#line 1517
- (void)setRecoverFromImageErrorWithBoolean:(jboolean)recoverFromImageError {
  
#line 1518
  self->recoverFromImageError_ = recoverFromImageError;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfCodecTIFFFaxDecoder *)other {
  [super copyAllFieldsTo:other];
  other->bitPointer_ = bitPointer_;
  other->bytePointer_ = bytePointer_;
  other->changingElemSize_ = changingElemSize_;
  other->compression_ = compression_;
  other->currChangingElems_ = currChangingElems_;
  other->data_ = data_;
  other->fillBits_ = fillBits_;
  other->fillOrder_ = fillOrder_;
  other->h_ = h_;
  other->lastChangingElement_ = lastChangingElement_;
  other->oneD_ = oneD_;
  other->prevChangingElems_ = prevChangingElems_;
  other->recoverFromImageError_ = recoverFromImageError_;
  other->uncompressedMode_ = uncompressedMode_;
  other->w_ = w_;
}

+ (void)initialize {
  if (self == [ComItextpdfTextPdfCodecTIFFFaxDecoder class]) {
    ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_ = [IOSIntArray arrayWithInts:(jint[]){
#line 81
      (jint) 0x00,
#line 82
      (jint) 0x01,
#line 83
      (jint) 0x03,
#line 84
      (jint) 0x07,
#line 85
      (jint) 0x0f,
#line 86
      (jint) 0x1f,
#line 87
      (jint) 0x3f,
#line 88
      (jint) 0x7f,
#line 89
      (jint) 0xff } count:9];
      ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_ = [IOSIntArray arrayWithInts:(jint[]){
#line 93
        (jint) 0x00,
#line 94
        (jint) 0x80,
#line 95
        (jint) 0xc0,
#line 96
        (jint) 0xe0,
#line 97
        (jint) 0xf0,
#line 98
        (jint) 0xf8,
#line 99
        (jint) 0xfc,
#line 100
        (jint) 0xfe,
#line 101
        (jint) 0xff } count:9];
        ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_ = [IOSByteArray arrayWithBytes:(jbyte[]){
#line 106
          0, -128, 64, -64, 32, -96, 96, -32,
#line 107
          16, -112, 80, -48, 48, -80, 112, -16,
#line 108
          8, -120, 72, -56, 40, -88, 104, -24,
#line 109
          24, -104, 88, -40, 56, -72, 120, -8,
#line 110
          4, -124, 68, -60, 36, -92, 100, -28,
#line 111
          20, -108, 84, -44, 52, -76, 116, -12,
#line 112
          12, -116, 76, -52, 44, -84, 108, -20,
#line 113
          28, -100, 92, -36, 60, -68, 124, -4,
#line 114
          2, -126, 66, -62, 34, -94, 98, -30,
#line 115
          18, -110, 82, -46, 50, -78, 114, -14,
#line 116
          10, -118, 74, -54, 42, -86, 106, -22,
#line 117
          26, -102, 90, -38, 58, -70, 122, -6,
#line 118
          6, -122, 70, -58, 38, -90, 102, -26,
#line 119
          22, -106, 86, -42, 54, -74, 118, -10,
#line 120
          14, -114, 78, -50, 46, -82, 110, -18,
#line 121
          30, -98, 94, -34, 62, -66, 126, -2,
#line 122
          1, -127, 65, -63, 33, -95, 97, -31,
#line 123
          17, -111, 81, -47, 49, -79, 113, -15,
#line 124
          9, -119, 73, -55, 41, -87, 105, -23,
#line 125
          25, -103, 89, -39, 57, -71, 121, -7,
#line 126
          5, -123, 69, -59, 37, -91, 101, -27,
#line 127
          21, -107, 85, -43, 53, -75, 117, -11,
#line 128
          13, -115, 77, -51, 45, -83, 109, -19,
#line 129
          29, -99, 93, -35, 61, -67, 125, -3,
#line 130
          3, -125, 67, -61, 35, -93, 99, -29,
#line 131
          19, -109, 83, -45, 51, -77, 115, -13,
#line 132
          11, -117, 75, -53, 43, -85, 107, -21,
#line 133
          27, -101, 91, -37, 59, -69, 123, -5,
#line 134
          7, -121, 71, -57, 39, -89, 103, -25,
#line 135
          23, -105, 87, -41, 55, -73, 119, -9,
#line 136
          15, -113, 79, -49, 47, -81, 111, -17,
#line 137
          31, -97, 95, -33, 63, -65, 127, -1 } count:256];
          ComItextpdfTextPdfCodecTIFFFaxDecoder_white_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 143
            6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
#line 145
            944, 944, 944, 944, 976, 976, 976, 976,
#line 147
            1456, 1456, 1456, 1456, 1488, 1488, 1488, 1488,
#line 149
            718, 718, 718, 718, 718, 718, 718, 718,
#line 151
            750, 750, 750, 750, 750, 750, 750, 750,
#line 153
            1520, 1520, 1520, 1520, 1552, 1552, 1552, 1552,
#line 155
            428, 428, 428, 428, 428, 428, 428, 428,
#line 157
            428, 428, 428, 428, 428, 428, 428, 428,
#line 159
            654, 654, 654, 654, 654, 654, 654, 654,
#line 161
            1072, 1072, 1072, 1072, 1104, 1104, 1104, 1104,
#line 163
            1136, 1136, 1136, 1136, 1168, 1168, 1168, 1168,
#line 165
            1200, 1200, 1200, 1200, 1232, 1232, 1232, 1232,
#line 167
            622, 622, 622, 622, 622, 622, 622, 622,
#line 169
            1008, 1008, 1008, 1008, 1040, 1040, 1040, 1040,
#line 171
            44, 44, 44, 44, 44, 44, 44, 44,
#line 173
            44, 44, 44, 44, 44, 44, 44, 44,
#line 175
            396, 396, 396, 396, 396, 396, 396, 396,
#line 177
            396, 396, 396, 396, 396, 396, 396, 396,
#line 179
            1712, 1712, 1712, 1712, 1744, 1744, 1744, 1744,
#line 181
            846, 846, 846, 846, 846, 846, 846, 846,
#line 183
            1264, 1264, 1264, 1264, 1296, 1296, 1296, 1296,
#line 185
            1328, 1328, 1328, 1328, 1360, 1360, 1360, 1360,
#line 187
            1392, 1392, 1392, 1392, 1424, 1424, 1424, 1424,
#line 189
            686, 686, 686, 686, 686, 686, 686, 686,
#line 191
            910, 910, 910, 910, 910, 910, 910, 910,
#line 193
            1968, 1968, 1968, 1968, 2000, 2000, 2000, 2000,
#line 195
            2032, 2032, 2032, 2032, 16, 16, 16, 16,
#line 197
            10257, 10257, 10257, 10257, 12305, 12305, 12305, 12305,
#line 199
            330, 330, 330, 330, 330, 330, 330, 330,
#line 201
            330, 330, 330, 330, 330, 330, 330, 330,
#line 203
            330, 330, 330, 330, 330, 330, 330, 330,
#line 205
            330, 330, 330, 330, 330, 330, 330, 330,
#line 207
            362, 362, 362, 362, 362, 362, 362, 362,
#line 209
            362, 362, 362, 362, 362, 362, 362, 362,
#line 211
            362, 362, 362, 362, 362, 362, 362, 362,
#line 213
            362, 362, 362, 362, 362, 362, 362, 362,
#line 215
            878, 878, 878, 878, 878, 878, 878, 878,
#line 217
            1904, 1904, 1904, 1904, 1936, 1936, 1936, 1936,
#line 219
            -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221,
#line 221
            590, 590, 590, 590, 590, 590, 590, 590,
#line 223
            782, 782, 782, 782, 782, 782, 782, 782,
#line 225
            1584, 1584, 1584, 1584, 1616, 1616, 1616, 1616,
#line 227
            1648, 1648, 1648, 1648, 1680, 1680, 1680, 1680,
#line 229
            814, 814, 814, 814, 814, 814, 814, 814,
#line 231
            1776, 1776, 1776, 1776, 1808, 1808, 1808, 1808,
#line 233
            1840, 1840, 1840, 1840, 1872, 1872, 1872, 1872,
#line 235
            6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157,
#line 237
            6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157,
#line 239
            -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
#line 241
            -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
#line 243
            14353, 14353, 14353, 14353, 16401, 16401, 16401, 16401,
#line 245
            22547, 22547, 24595, 24595, 20497, 20497, 20497, 20497,
#line 247
            18449, 18449, 18449, 18449, 26643, 26643, 28691, 28691,
#line 249
            30739, 30739, -32749, -32749, -30701, -30701, -28653, -28653,
#line 251
            -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461,
#line 253
            8207, 8207, 8207, 8207, 8207, 8207, 8207, 8207,
#line 255
            72, 72, 72, 72, 72, 72, 72, 72,
#line 257
            72, 72, 72, 72, 72, 72, 72, 72,
#line 259
            72, 72, 72, 72, 72, 72, 72, 72,
#line 261
            72, 72, 72, 72, 72, 72, 72, 72,
#line 263
            72, 72, 72, 72, 72, 72, 72, 72,
#line 265
            72, 72, 72, 72, 72, 72, 72, 72,
#line 267
            72, 72, 72, 72, 72, 72, 72, 72,
#line 269
            72, 72, 72, 72, 72, 72, 72, 72,
#line 271
            104, 104, 104, 104, 104, 104, 104, 104,
#line 273
            104, 104, 104, 104, 104, 104, 104, 104,
#line 275
            104, 104, 104, 104, 104, 104, 104, 104,
#line 277
            104, 104, 104, 104, 104, 104, 104, 104,
#line 279
            104, 104, 104, 104, 104, 104, 104, 104,
#line 281
            104, 104, 104, 104, 104, 104, 104, 104,
#line 283
            104, 104, 104, 104, 104, 104, 104, 104,
#line 285
            104, 104, 104, 104, 104, 104, 104, 104,
#line 287
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 289
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 291
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 293
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 295
            266, 266, 266, 266, 266, 266, 266, 266,
#line 297
            266, 266, 266, 266, 266, 266, 266, 266,
#line 299
            266, 266, 266, 266, 266, 266, 266, 266,
#line 301
            266, 266, 266, 266, 266, 266, 266, 266,
#line 303
            298, 298, 298, 298, 298, 298, 298, 298,
#line 305
            298, 298, 298, 298, 298, 298, 298, 298,
#line 307
            298, 298, 298, 298, 298, 298, 298, 298,
#line 309
            298, 298, 298, 298, 298, 298, 298, 298,
#line 311
            524, 524, 524, 524, 524, 524, 524, 524,
#line 313
            524, 524, 524, 524, 524, 524, 524, 524,
#line 315
            556, 556, 556, 556, 556, 556, 556, 556,
#line 317
            556, 556, 556, 556, 556, 556, 556, 556,
#line 319
            136, 136, 136, 136, 136, 136, 136, 136,
#line 321
            136, 136, 136, 136, 136, 136, 136, 136,
#line 323
            136, 136, 136, 136, 136, 136, 136, 136,
#line 325
            136, 136, 136, 136, 136, 136, 136, 136,
#line 327
            136, 136, 136, 136, 136, 136, 136, 136,
#line 329
            136, 136, 136, 136, 136, 136, 136, 136,
#line 331
            136, 136, 136, 136, 136, 136, 136, 136,
#line 333
            136, 136, 136, 136, 136, 136, 136, 136,
#line 335
            168, 168, 168, 168, 168, 168, 168, 168,
#line 337
            168, 168, 168, 168, 168, 168, 168, 168,
#line 339
            168, 168, 168, 168, 168, 168, 168, 168,
#line 341
            168, 168, 168, 168, 168, 168, 168, 168,
#line 343
            168, 168, 168, 168, 168, 168, 168, 168,
#line 345
            168, 168, 168, 168, 168, 168, 168, 168,
#line 347
            168, 168, 168, 168, 168, 168, 168, 168,
#line 349
            168, 168, 168, 168, 168, 168, 168, 168,
#line 351
            460, 460, 460, 460, 460, 460, 460, 460,
#line 353
            460, 460, 460, 460, 460, 460, 460, 460,
#line 355
            492, 492, 492, 492, 492, 492, 492, 492,
#line 357
            492, 492, 492, 492, 492, 492, 492, 492,
#line 359
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 361
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 363
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 365
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 367
            200, 200, 200, 200, 200, 200, 200, 200,
#line 369
            200, 200, 200, 200, 200, 200, 200, 200,
#line 371
            200, 200, 200, 200, 200, 200, 200, 200,
#line 373
            200, 200, 200, 200, 200, 200, 200, 200,
#line 375
            200, 200, 200, 200, 200, 200, 200, 200,
#line 377
            200, 200, 200, 200, 200, 200, 200, 200,
#line 379
            200, 200, 200, 200, 200, 200, 200, 200,
#line 381
            200, 200, 200, 200, 200, 200, 200, 200,
#line 383
            232, 232, 232, 232, 232, 232, 232, 232,
#line 385
            232, 232, 232, 232, 232, 232, 232, 232,
#line 387
            232, 232, 232, 232, 232, 232, 232, 232,
#line 389
            232, 232, 232, 232, 232, 232, 232, 232,
#line 391
            232, 232, 232, 232, 232, 232, 232, 232,
#line 393
            232, 232, 232, 232, 232, 232, 232, 232,
#line 395
            232, 232, 232, 232, 232, 232, 232, 232,
#line 397
            232, 232, 232, 232, 232, 232, 232, 232 } count:1024];
            ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 402
              28679, 28679, 31752, (jshort) 32777,
#line 403
              (jshort) 33801, (jshort) 34825, (jshort) 35849, (jshort) 36873,
#line 404
              (jshort) 29703, (jshort) 29703, (jshort) 30727, (jshort) 30727,
#line 405
              (jshort) 37897, (jshort) 38921, (jshort) 39945, (jshort) 40969 } count:16];
              ComItextpdfTextPdfCodecTIFFFaxDecoder_initBlack_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 411
                3226, 6412, 200, 168, 38, 38, 134, 134,
#line 413
                100, 100, 100, 100, 68, 68, 68, 68 } count:16];
                ComItextpdfTextPdfCodecTIFFFaxDecoder_twoBitBlack_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 417
                  292, 260, 226, 226 } count:4];
                  ComItextpdfTextPdfCodecTIFFFaxDecoder_black_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 422
                    62, 62, 30, 30, 0, 0, 0, 0,
#line 424
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 426
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 428
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 430
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 432
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 434
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 436
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 438
                    588, 588, 588, 588, 588, 588, 588, 588,
#line 440
                    1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776,
#line 442
                    1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904,
#line 444
                    1936, 1936, -16365, -14317, 782, 782, 782, 782,
#line 446
                    814, 814, 814, 814, -12269, -10221, 10257, 10257,
#line 448
                    12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712,
#line 450
                    1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605,
#line 452
                    2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061,
#line 454
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 456
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 458
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 460
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 462
                    750, 750, 750, 750, 1616, 1616, 1648, 1648,
#line 464
                    1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520,
#line 466
                    1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209,
#line 468
                    524, 524, 524, 524, 524, 524, 524, 524,
#line 470
                    556, 556, 556, 556, 556, 556, 556, 556,
#line 472
                    1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032,
#line 474
                    976, 976, 1008, 1008, 1040, 1040, 1072, 1072,
#line 476
                    1296, 1296, 1328, 1328, 718, 718, 718, 718,
#line 478
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 480
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 482
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 484
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 486
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 488
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 490
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 492
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 494
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 496
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 498
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 500
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 502
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 504
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 506
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 508
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 510
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 512
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 514
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 516
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 518
                    490, 490, 490, 490, 490, 490, 490, 490,
#line 520
                    490, 490, 490, 490, 490, 490, 490, 490,
#line 522
                    4113, 4113, 6161, 6161, 848, 848, 880, 880,
#line 524
                    912, 912, 944, 944, 622, 622, 622, 622,
#line 526
                    654, 654, 654, 654, 1104, 1104, 1136, 1136,
#line 528
                    1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264,
#line 530
                    686, 686, 686, 686, 1360, 1360, 1392, 1392,
#line 532
                    12, 12, 12, 12, 12, 12, 12, 12,
#line 534
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 536
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 538
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 540
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 542
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 544
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 546
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 548
                    390, 390, 390, 390, 390, 390, 390, 390 } count:512];
                    ComItextpdfTextPdfCodecTIFFFaxDecoder_twoDCodes_ = [IOSByteArray arrayWithBytes:(jbyte[]){
#line 553
                      80, 88, 23, 71, 30, 30, 62, 62,
#line 555
                      4, 4, 4, 4, 4, 4, 4, 4,
#line 557
                      11, 11, 11, 11, 11, 11, 11, 11,
#line 559
                      11, 11, 11, 11, 11, 11, 11, 11,
#line 561
                      35, 35, 35, 35, 35, 35, 35, 35,
#line 563
                      35, 35, 35, 35, 35, 35, 35, 35,
#line 565
                      51, 51, 51, 51, 51, 51, 51, 51,
#line 567
                      51, 51, 51, 51, 51, 51, 51, 51,
#line 569
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 571
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 573
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 575
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 577
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 579
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 581
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 583
                      41, 41, 41, 41, 41, 41, 41, 41 } count:128];
                      ComItextpdfTextPdfCodecTIFFFaxDecoder_initialized = YES;
                    }
                  }

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withInt:withInt:", "TIFFFaxDecoder", NULL, 0x1, NULL },
    { "reverseBitsWithByteArray:", "reverseBits", "V", 0x9, NULL },
    { "decode1DWithByteArray:withByteArray:withInt:withInt:", "decode1D", "V", 0x1, NULL },
    { "decodeNextScanlineWithByteArray:withInt:withInt:", "decodeNextScanline", "V", 0x1, NULL },
    { "decode2DWithByteArray:withByteArray:withInt:withInt:withLong:", "decode2D", "V", 0x1, NULL },
    { "decodeT6WithByteArray:withByteArray:withInt:withInt:withLong:", "decodeT6", "V", 0x1, NULL },
    { "setToBlackWithByteArray:withInt:withInt:withInt:", "setToBlack", "V", 0x2, NULL },
    { "decodeWhiteCodeWord", NULL, "I", 0x2, NULL },
    { "decodeBlackCodeWord", NULL, "I", 0x2, NULL },
    { "readEOLWithBoolean:", "readEOL", "I", 0x2, NULL },
    { "getNextChangingElementWithInt:withBoolean:withIntArray:", "getNextChangingElement", "V", 0x2, NULL },
    { "nextNBitsWithInt:", "nextNBits", "I", 0x2, NULL },
    { "nextLesserThan8BitsWithInt:", "nextLesserThan8Bits", "I", 0x2, NULL },
    { "updatePointerWithInt:", "updatePointer", "V", 0x2, NULL },
    { "advancePointer", NULL, "Z", 0x2, NULL },
    { "setRecoverFromImageErrorWithBoolean:", "setRecoverFromImageError", "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "bitPointer_", NULL, 0x2, "I", NULL,  },
    { "bytePointer_", NULL, 0x2, "I", NULL,  },
    { "data_", NULL, 0x2, "[B", NULL,  },
    { "w_", NULL, 0x2, "I", NULL,  },
    { "h_", NULL, 0x2, "I", NULL,  },
    { "fillOrder_", NULL, 0x2, "I", NULL,  },
    { "changingElemSize_", NULL, 0x2, "I", NULL,  },
    { "prevChangingElems_", NULL, 0x2, "[I", NULL,  },
    { "currChangingElems_", NULL, 0x2, "[I", NULL,  },
    { "lastChangingElement_", NULL, 0x2, "I", NULL,  },
    { "compression_", NULL, 0x2, "I", NULL,  },
    { "uncompressedMode_", NULL, 0x2, "I", NULL,  },
    { "fillBits_", NULL, 0x2, "I", NULL,  },
    { "oneD_", NULL, 0x2, "I", NULL,  },
    { "recoverFromImageError_", NULL, 0x2, "Z", NULL,  },
    { "table1_", NULL, 0x8, "[I", &ComItextpdfTextPdfCodecTIFFFaxDecoder_table1_,  },
    { "table2_", NULL, 0x8, "[I", &ComItextpdfTextPdfCodecTIFFFaxDecoder_table2_,  },
    { "flipTable_", NULL, 0x8, "[B", &ComItextpdfTextPdfCodecTIFFFaxDecoder_flipTable_,  },
    { "white_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecoder_white_,  },
    { "additionalMakeup_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecoder_additionalMakeup_,  },
    { "initBlack_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecoder_initBlack_,  },
    { "twoBitBlack_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecoder_twoBitBlack_,  },
    { "black_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecoder_black_,  },
    { "twoDCodes_", NULL, 0x8, "[B", &ComItextpdfTextPdfCodecTIFFFaxDecoder_twoDCodes_,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfCodecTIFFFaxDecoder = { "TIFFFaxDecoder", "com.itextpdf.text.pdf.codec", NULL, 0x1, 16, methods, 24, fields, 0, NULL};
  return &_ComItextpdfTextPdfCodecTIFFFaxDecoder;
}

@end

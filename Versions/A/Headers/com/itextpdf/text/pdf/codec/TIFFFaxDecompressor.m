//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/codec/TIFFFaxDecompressor.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/codec/TIFFFaxDecompressor.java"

#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/pdf/codec/TIFFConstants.h"
#include "com/itextpdf/text/pdf/codec/TIFFFaxDecompressor.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Exception.h"
#include "java/lang/RuntimeException.h"

BOOL ComItextpdfTextPdfCodecTIFFFaxDecompressor_initialized = NO;


#line 58
@implementation ComItextpdfTextPdfCodecTIFFFaxDecompressor

IOSIntArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_;
IOSIntArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_;
IOSByteArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_white_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_initBlack_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoBitBlack_;
IOSShortArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_black_;
IOSByteArray * ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoDCodes_;


#line 593
- (instancetype)init {
  if (self = [super init]) {
    uncompressedMode_ =
#line 76
    0;
    fillBits_ =
#line 81
    0;
    changingElemSize_ =
#line 94
    0;
    lastChangingElement_ =
#line 98
    0;
  }
  return self;
}


#line 600
- (void)SetOptionsWithInt:(jint)fillOrder
                  withInt:(jint)compression
                  withInt:(jint)t4Options
                  withInt:(jint)t6Options {
  
#line 601
  self->fillOrder_ = fillOrder;
  self->compression_ = compression;
  self->t4Options_ = t4Options;
  self->t6Options_ = t6Options;
  self->oneD_ = (jint) (t4Options & (jint) 0x01);
  self->uncompressedMode_ = (jint) (RShift32((t4Options & (jint) 0x02), 1));
  self->fillBits_ = (jint) (RShift32((t4Options & (jint) 0x04), 2));
}


#line 610
- (void)decodeRawWithByteArray:(IOSByteArray *)buffer
                 withByteArray:(IOSByteArray *)compData
                       withInt:(jint)w
                       withInt:(jint)h {
  
#line 612
  self->buffer_ = buffer;
  self->data_ = compData;
  self->w_ = w;
  self->h_ = h;
  self->bitsPerScanline_ = w;
  self->lineBitNum_ = 0;
  
#line 619
  self->bitPointer_ = 0;
  self->bytePointer_ = 0;
  self->prevChangingElems_ = [IOSIntArray arrayWithLength:w + 1];
  self->currChangingElems_ = [IOSIntArray arrayWithLength:w + 1];
  
#line 624
  fails_ = 0;
  
#line 626
  @try {
    if (compression_ == ComItextpdfTextPdfCodecTIFFConstants_COMPRESSION_CCITTRLE) {
      [self decodeRLE];
    }
    else
#line 629
    if (compression_ == ComItextpdfTextPdfCodecTIFFConstants_COMPRESSION_CCITTFAX3) {
      [self decodeT4];
    }
    else
#line 631
    if (compression_ == ComItextpdfTextPdfCodecTIFFConstants_COMPRESSION_CCITTFAX4) {
      self->uncompressedMode_ = (jint) (RShift32((t6Options_ & (jint) 0x02), 1));
      [self decodeT6];
    }
    else {
      
#line 635
      @throw [[JavaLangRuntimeException alloc] initWithNSString:JreStrcat("$I", @"Unknown compression type ", compression_)];
    }
  }
  @catch (
#line 637
  JavaLangArrayIndexOutOfBoundsException *e) {
  }
}


#line 642
- (void)decodeRLE {
  
#line 643
  for (jint i = 0; i < h_; i++) {
    
#line 645
    [self decodeNextScanline];
    
#line 648
    if (bitPointer_ != 0) {
      bytePointer_++;
      bitPointer_ = 0;
    }
    
#line 654
    lineBitNum_ += bitsPerScanline_;
  }
}


#line 658
- (void)decodeNextScanline {
  
#line 659
  jint bits = 0, code = 0, isT = 0;
  jint current, entry_, twoBits;
  jboolean isWhite = YES;
  
#line 663
  jint bitOffset = 0;
  
#line 666
  changingElemSize_ = 0;
  
#line 669
  while (bitOffset < w_) {
    
#line 672
    jint runOffset = bitOffset;
    
#line 674
    while (isWhite && bitOffset < w_) {
      
#line 676
      current = [self nextNBitsWithInt:10];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_white_), current);
      
#line 680
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x0f;
      
#line 683
      if (bits == 12) {
        
#line 685
        twoBits = [self nextLesserThan8BitsWithInt:2];
        
#line 687
        current = ((LShift32(current, 2)) & (jint) 0x000c) | twoBits;
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_), current);
        bits = (URShift32(entry_, 1)) & (jint) 0x07;
        code = (URShift32(entry_, 4)) & (jint) 0x0fff;
        bitOffset += code;
        
#line 693
        [self updatePointerWithInt:4 - bits];
      }
      else
#line 694
      if (bits == 0) {
        ++fails_;
      }
      else if (bits == 15) {
        
#line 702
        ++fails_;
        return;
      }
      else {
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        bitOffset += code;
        
#line 709
        [self updatePointerWithInt:10 - bits];
        if (isT == 0) {
          isWhite = NO;
          *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
        }
      }
    }
    
#line 718
    if (bitOffset == w_) {
      
#line 722
      jint runLength = bitOffset - runOffset;
      if (isWhite &&
#line 724
      runLength != 0 && runLength % 64 == 0 &&
#line 725
      [self nextNBitsWithInt:8] != (jint) 0x35) {
        ++fails_;
        [self updatePointerWithInt:8];
      }
      break;
    }
    
#line 733
    runOffset = bitOffset;
    
#line 735
    while (isWhite == NO && bitOffset < w_) {
      
#line 737
      current = [self nextLesserThan8BitsWithInt:4];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_initBlack_), current);
      
#line 741
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x000f;
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      
#line 745
      if (code == 100) {
        current = [self nextNBitsWithInt:9];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_black_), current);
        
#line 750
        isT = entry_ & (jint) 0x0001;
        bits = (URShift32(entry_, 1)) & (jint) 0x000f;
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        
#line 754
        if (bits == 12) {
          
#line 756
          [self updatePointerWithInt:5];
          current = [self nextLesserThan8BitsWithInt:4];
          entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_), current);
          bits = (URShift32(entry_, 1)) & (jint) 0x07;
          code = (URShift32(entry_, 4)) & (jint) 0x0fff;
          
#line 762
          [self setToBlackWithInt:bitOffset withInt:code];
          bitOffset += code;
          
#line 765
          [self updatePointerWithInt:4 - bits];
        }
        else
#line 766
        if (bits == 15) {
          
#line 771
          ++fails_;
          return;
        }
        else {
          
#line 774
          [self setToBlackWithInt:bitOffset withInt:code];
          bitOffset += code;
          
#line 777
          [self updatePointerWithInt:9 - bits];
          if (isT == 0) {
            isWhite = YES;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
          }
        }
      }
      else
#line 783
      if (code == 200) {
        
#line 785
        current = [self nextLesserThan8BitsWithInt:2];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoBitBlack_), current);
        code = (URShift32(entry_, 5)) & (jint) 0x07ff;
        bits = (URShift32(entry_, 1)) & (jint) 0x0f;
        
#line 790
        [self setToBlackWithInt:bitOffset withInt:code];
        bitOffset += code;
        
#line 793
        [self updatePointerWithInt:2 - bits];
        isWhite = YES;
        *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
      }
      else {
        [self setToBlackWithInt:bitOffset withInt:code];
        bitOffset += code;
        
#line 801
        [self updatePointerWithInt:4 - bits];
        isWhite = YES;
        *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
      }
    }
    
#line 808
    if (bitOffset == w_) {
      
#line 812
      jint runLength = bitOffset - runOffset;
      if (!isWhite &&
#line 814
      runLength != 0 && runLength % 64 == 0 &&
#line 815
      [self nextNBitsWithInt:10] != (jint) 0x37) {
        ++fails_;
        [self updatePointerWithInt:10];
      }
      break;
    }
  }
  
#line 823
  *IOSIntArray_GetRef(nil_chk(currChangingElems_), changingElemSize_++) = bitOffset;
}


#line 826
- (void)decodeT4 {
  
#line 827
  jint height = h_;
  
#line 829
  jint a0, a1, b1, b2;
  IOSIntArray *b = [IOSIntArray arrayWithLength:2];
  jint entry_, code, bits, color;
  jboolean isWhite;
  jint currIndex = 0;
  IOSIntArray *temp;
  
#line 836
  if (((IOSByteArray *) nil_chk(data_))->size_ < 2) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Insufficient data to read initial EOL."];
  }
  
#line 841
  jint next12 = [self nextNBitsWithInt:12];
  if (next12 != 1) {
    ++fails_;
  }
  [self updatePointerWithInt:12];
  
#line 848
  jint modeFlag = 0;
  jint lines = -1;
  while (modeFlag != 1) {
    @try {
      modeFlag = [self findNextLine];
      lines++;
    }
    @catch (
#line 854
    JavaLangException *eofe) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:@"No reference line present."];
    }
  }
  
#line 859
  jint bitOffset;
  
#line 863
  [self decodeNextScanline];
  lines++;
  lineBitNum_ += bitsPerScanline_;
  
#line 867
  while (lines < height) {
    
#line 871
    @try {
      modeFlag = [self findNextLine];
    }
    @catch (
#line 873
    JavaLangException *eofe) {
      ++fails_;
      break;
    }
    if (modeFlag == 0) {
      
#line 882
      temp = prevChangingElems_;
      prevChangingElems_ = currChangingElems_;
      currChangingElems_ = temp;
      currIndex = 0;
      
#line 888
      a0 = -1;
      isWhite = YES;
      bitOffset = 0;
      
#line 892
      lastChangingElement_ = 0;
      
#line 894
      while (bitOffset < w_) {
        
#line 896
        [self getNextChangingElementWithInt:a0 withBoolean:isWhite withIntArray:b];
        
#line 898
        b1 = IOSIntArray_Get(b, 0);
        b2 = IOSIntArray_Get(b, 1);
        
#line 902
        entry_ = [self nextLesserThan8BitsWithInt:7];
        
#line 905
        entry_ = (jint) (IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoDCodes_), entry_) & (jint) 0xff);
        
#line 908
        code = URShift32((entry_ & (jint) 0x78), 3);
        bits = entry_ & (jint) 0x07;
        
#line 911
        if (code == 0) {
          if (!isWhite) {
            [self setToBlackWithInt:bitOffset withInt:b2 - bitOffset];
          }
          bitOffset = a0 = b2;
          
#line 918
          [self updatePointerWithInt:7 - bits];
        }
        else
#line 919
        if (code == 1) {
          
#line 921
          [self updatePointerWithInt:7 - bits];
          
#line 924
          jint number;
          if (isWhite) {
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
            
#line 930
            number = [self decodeBlackCodeWord];
            [self setToBlackWithInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(currChangingElems_, currIndex++) = bitOffset;
          }
          else {
            
#line 935
            number = [self decodeBlackCodeWord];
            [self setToBlackWithInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
            
#line 940
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(currChangingElems_, currIndex++) = bitOffset;
          }
          
#line 945
          a0 = bitOffset;
        }
        else
#line 946
        if (code <= 8) {
          
#line 948
          a1 = b1 + (code - 5);
          
#line 950
          *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = a1;
          
#line 954
          if (!isWhite) {
            [self setToBlackWithInt:bitOffset withInt:a1 - bitOffset];
          }
          bitOffset = a0 = a1;
          isWhite = !isWhite;
          
#line 960
          [self updatePointerWithInt:7 - bits];
        }
        else {
          
#line 962
          ++fails_;
          
#line 964
          jint numLinesTested = 0;
          while (modeFlag != 1) {
            @try {
              modeFlag = [self findNextLine];
              numLinesTested++;
            }
            @catch (
#line 969
            JavaLangException *eofe) {
              return;
            }
          }
          lines += numLinesTested - 1;
          [self updatePointerWithInt:13];
          break;
        }
      }
      
#line 981
      *IOSIntArray_GetRef(nil_chk(currChangingElems_), currIndex++) = bitOffset;
      changingElemSize_ = currIndex;
    }
    else {
      [self decodeNextScanline];
    }
    
#line 988
    lineBitNum_ += bitsPerScanline_;
    lines++;
  }
}


#line 993
- (void)decodeT6 {
  @synchronized(self) {
    
#line 994
    jint height = h_;
    
#line 997
    jint a0, a1, b1, b2;
    jint entry_, code, bits;
    jboolean isWhite;
    jint currIndex;
    IOSIntArray *temp;
    
#line 1004
    IOSIntArray *b = [IOSIntArray arrayWithLength:2];
    
#line 1011
    IOSIntArray *cce = currChangingElems_;
    
#line 1016
    changingElemSize_ = 0;
    *IOSIntArray_GetRef(nil_chk(cce), changingElemSize_++) = w_;
    *IOSIntArray_GetRef(cce, changingElemSize_++) = w_;
    
#line 1020
    jint bitOffset;
    
#line 1022
    for (jint lines = 0; lines < height; lines++) {
      
#line 1024
      a0 = -1;
      isWhite = YES;
      
#line 1030
      temp = prevChangingElems_;
      prevChangingElems_ = currChangingElems_;
      cce = currChangingElems_ = temp;
      currIndex = 0;
      
#line 1036
      bitOffset = 0;
      
#line 1039
      lastChangingElement_ = 0;
      
#line 1042
      while (bitOffset < w_) {
        
#line 1044
        [self getNextChangingElementWithInt:a0 withBoolean:isWhite withIntArray:b];
        b1 = IOSIntArray_Get(b, 0);
        b2 = IOSIntArray_Get(b, 1);
        
#line 1049
        entry_ = [self nextLesserThan8BitsWithInt:7];
        
#line 1051
        entry_ = (jint) (IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoDCodes_), entry_) & (jint) 0xff);
        
#line 1054
        code = URShift32((entry_ & (jint) 0x78), 3);
        bits = entry_ & (jint) 0x07;
        
#line 1057
        if (code == 0) {
          
#line 1059
          if (!isWhite) {
            if (b2 > w_) {
              b2 = w_;
            }
            [self setToBlackWithInt:bitOffset withInt:b2 - bitOffset];
          }
          bitOffset = a0 = b2;
          
#line 1068
          [self updatePointerWithInt:7 - bits];
        }
        else
#line 1069
        if (code == 1) {
          
#line 1071
          [self updatePointerWithInt:7 - bits];
          
#line 1074
          jint number;
          if (isWhite) {
            
#line 1077
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
            
#line 1081
            number = [self decodeBlackCodeWord];
            if (number > w_ - bitOffset) {
              number = w_ - bitOffset;
            }
            [self setToBlackWithInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
          }
          else {
            number = [self decodeBlackCodeWord];
            if (number > w_ - bitOffset) {
              number = w_ - bitOffset;
            }
            [self setToBlackWithInt:bitOffset withInt:number];
            bitOffset += number;
            *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
            
#line 1098
            number = [self decodeWhiteCodeWord];
            bitOffset += number;
            *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
          }
          
#line 1103
          a0 = bitOffset;
        }
        else
#line 1104
        if (code <= 8) {
          a1 = b1 + (code - 5);
          *IOSIntArray_GetRef(cce, currIndex++) = a1;
          
#line 1110
          if (!isWhite) {
            if (a1 > w_) {
              a1 = w_;
            }
            [self setToBlackWithInt:bitOffset withInt:a1 - bitOffset];
          }
          bitOffset = a0 = a1;
          isWhite = !isWhite;
          
#line 1119
          [self updatePointerWithInt:7 - bits];
        }
        else
#line 1120
        if (code == 11) {
          jint entranceCode = [self nextLesserThan8BitsWithInt:3];
          
#line 1123
          jint zeros = 0;
          jboolean exit = NO;
          
#line 1126
          while (!exit) {
            while ([self nextLesserThan8BitsWithInt:1] != 1) {
              zeros++;
            }
            
#line 1131
            if (zeros > 5) {
              
#line 1135
              zeros = zeros - 6;
              
#line 1137
              if (!isWhite && (zeros > 0)) {
                *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
              }
              
#line 1142
              bitOffset += zeros;
              if (zeros > 0) {
                
#line 1145
                isWhite = YES;
              }
              
#line 1150
              if ([self nextLesserThan8BitsWithInt:1] == 0) {
                if (!isWhite) {
                  *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
                }
                isWhite = YES;
              }
              else {
                
#line 1156
                if (isWhite) {
                  *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
                }
                isWhite = NO;
              }
              
#line 1162
              exit = YES;
            }
            
#line 1165
            if (zeros == 5) {
              if (!isWhite) {
                *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
              }
              bitOffset += zeros;
              
#line 1172
              isWhite = YES;
            }
            else {
              
#line 1174
              bitOffset += zeros;
              
#line 1176
              *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
              [self setToBlackWithInt:bitOffset withInt:1];
              ++bitOffset;
              
#line 1181
              isWhite = NO;
            }
          }
        }
      }
      
#line 1190
      if (currIndex <= w_)
#line 1191
      *IOSIntArray_GetRef(cce, currIndex++) = bitOffset;
      
#line 1194
      changingElemSize_ = currIndex;
      
#line 1196
      lineBitNum_ += bitsPerScanline_;
    }
  }
}


#line 1200
- (void)setToBlackWithInt:(jint)bitNum
                  withInt:(jint)numBits {
  
#line 1202
  bitNum += lineBitNum_;
  
#line 1204
  jint lastBit = bitNum + numBits;
  jint byteNum = RShift32(bitNum, 3);
  
#line 1208
  jint shift = bitNum & (jint) 0x7;
  if (shift > 0) {
    jint maskVal = LShift32(1, (7 - shift));
    jbyte val = IOSByteArray_Get(nil_chk(buffer_), byteNum);
    while (maskVal > 0 && bitNum < lastBit) {
      val |= maskVal;
      RShiftAssignInt(&maskVal, 1);
      ++bitNum;
    }
    *IOSByteArray_GetRef(buffer_, byteNum) = val;
  }
  
#line 1221
  byteNum = RShift32(bitNum, 3);
  while (bitNum < lastBit - 7) {
    *IOSByteArray_GetRef(nil_chk(buffer_), byteNum++) = (jbyte) 255;
    bitNum += 8;
  }
  
#line 1228
  while (bitNum < lastBit) {
    byteNum = RShift32(bitNum, 3);
    *IOSByteArray_GetRef(nil_chk(buffer_), byteNum) |= LShift32(1, (7 - (bitNum & (jint) 0x7)));
    ++bitNum;
  }
}


#line 1236
- (jint)decodeWhiteCodeWord {
  
#line 1237
  jint current, entry_, bits, isT, twoBits, code = -1;
  jint runLength = 0;
  jboolean isWhite = YES;
  
#line 1241
  while (isWhite) {
    current = [self nextNBitsWithInt:10];
    entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_white_), current);
    
#line 1246
    isT = entry_ & (jint) 0x0001;
    bits = (URShift32(entry_, 1)) & (jint) 0x0f;
    
#line 1249
    if (bits == 12) {
      
#line 1251
      twoBits = [self nextLesserThan8BitsWithInt:2];
      
#line 1253
      current = ((LShift32(current, 2)) & (jint) 0x000c) | twoBits;
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_), current);
      bits = (URShift32(entry_, 1)) & (jint) 0x07;
      code = (URShift32(entry_, 4)) & (jint) 0x0fff;
      runLength += code;
      [self updatePointerWithInt:4 - bits];
    }
    else
#line 1259
    if (bits == 0) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Error 0"];
    }
    else
#line 1261
    if (bits == 15) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Error 1"];
    }
    else {
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      runLength += code;
      [self updatePointerWithInt:10 - bits];
      if (isT == 0) {
        isWhite = NO;
      }
    }
  }
  
#line 1274
  return runLength;
}


#line 1278
- (jint)decodeBlackCodeWord {
  
#line 1279
  jint current, entry_, bits, isT, twoBits, code = -1;
  jint runLength = 0;
  jboolean isWhite = NO;
  
#line 1283
  while (!isWhite) {
    current = [self nextLesserThan8BitsWithInt:4];
    entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_initBlack_), current);
    
#line 1288
    isT = entry_ & (jint) 0x0001;
    bits = (URShift32(entry_, 1)) & (jint) 0x000f;
    code = (URShift32(entry_, 5)) & (jint) 0x07ff;
    
#line 1292
    if (code == 100) {
      current = [self nextNBitsWithInt:9];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_black_), current);
      
#line 1297
      isT = entry_ & (jint) 0x0001;
      bits = (URShift32(entry_, 1)) & (jint) 0x000f;
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      
#line 1301
      if (bits == 12) {
        
#line 1303
        [self updatePointerWithInt:5];
        current = [self nextLesserThan8BitsWithInt:4];
        entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_), current);
        bits = (URShift32(entry_, 1)) & (jint) 0x07;
        code = (URShift32(entry_, 4)) & (jint) 0x0fff;
        runLength += code;
        
#line 1310
        [self updatePointerWithInt:4 - bits];
      }
      else
#line 1311
      if (bits == 15) {
        
#line 1313
        @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Error 2"];
      }
      else {
        
#line 1315
        runLength += code;
        [self updatePointerWithInt:9 - bits];
        if (isT == 0) {
          isWhite = YES;
        }
      }
    }
    else
#line 1321
    if (code == 200) {
      
#line 1323
      current = [self nextLesserThan8BitsWithInt:2];
      entry_ = IOSShortArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoBitBlack_), current);
      code = (URShift32(entry_, 5)) & (jint) 0x07ff;
      runLength += code;
      bits = (URShift32(entry_, 1)) & (jint) 0x0f;
      [self updatePointerWithInt:2 - bits];
      isWhite = YES;
    }
    else {
      runLength += code;
      [self updatePointerWithInt:4 - bits];
      isWhite = YES;
    }
  }
  
#line 1338
  return runLength;
}


#line 1341
- (jint)findNextLine {
  
#line 1343
  jint bitIndexMax = ((IOSByteArray *) nil_chk(data_))->size_ * 8 - 1;
  jint bitIndexMax12 = bitIndexMax - 12;
  jint bitIndex = bytePointer_ * 8 + bitPointer_;
  
#line 1348
  while (bitIndex <= bitIndexMax12) {
    
#line 1350
    jint next12Bits = [self nextNBitsWithInt:12];
    bitIndex += 12;
    
#line 1355
    while (next12Bits != 1 && bitIndex < bitIndexMax) {
      next12Bits =
#line 1357
      (LShift32((next12Bits & (jint) 0x000007ff), 1)) |
#line 1358
      ([self nextLesserThan8BitsWithInt:1] & (jint) 0x00000001);
      bitIndex++;
    }
    
#line 1362
    if (next12Bits == 1) {
      if (oneD_ == 1) {
        if (bitIndex < bitIndexMax) {
          
#line 1366
          return [self nextLesserThan8BitsWithInt:1];
        }
      }
      else {
        
#line 1369
        return 1;
      }
    }
  }
  
#line 1375
  @throw [[JavaLangRuntimeException alloc] init];
}


#line 1378
- (void)getNextChangingElementWithInt:(jint)a0
                          withBoolean:(jboolean)isWhite
                         withIntArray:(IOSIntArray *)ret {
  
#line 1380
  IOSIntArray *pce = self->prevChangingElems_;
  jint ces = self->changingElemSize_;
  
#line 1386
  jint start = lastChangingElement_ > 0 ? lastChangingElement_ - 1 : 0;
  if (isWhite) {
    start &= ~(jint) 0x1;
  }
  else {
    
#line 1390
    start |= (jint) 0x1;
  }
  
#line 1393
  jint i = start;
  for (; i < ces; i += 2) {
    jint temp = IOSIntArray_Get(nil_chk(pce), i);
    if (temp > a0) {
      lastChangingElement_ = i;
      *IOSIntArray_GetRef(nil_chk(ret), 0) = temp;
      break;
    }
  }
  
#line 1403
  if (i + 1 < ces) {
    *IOSIntArray_GetRef(nil_chk(ret), 1) = IOSIntArray_Get(nil_chk(pce), i + 1);
  }
}


#line 1408
- (jint)nextNBitsWithInt:(jint)bitsToGet {
  
#line 1409
  jbyte b, next, next2next;
  jint l = ((IOSByteArray *) nil_chk(data_))->size_ - 1;
  jint bp = self->bytePointer_;
  
#line 1413
  if (fillOrder_ == 1) {
    b = IOSByteArray_Get(data_, bp);
    
#line 1416
    if (bp == l) {
      next = (jint) 0x00;
      next2next = (jint) 0x00;
    }
    else
#line 1419
    if ((bp + 1) == l) {
      next = IOSByteArray_Get(data_, bp + 1);
      next2next = (jint) 0x00;
    }
    else {
      
#line 1423
      next = IOSByteArray_Get(data_, bp + 1);
      next2next = IOSByteArray_Get(data_, bp + 2);
    }
  }
  else
#line 1426
  if (fillOrder_ == 2) {
    b = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_), IOSByteArray_Get(data_, bp) & (jint) 0xff);
    
#line 1429
    if (bp == l) {
      next = (jint) 0x00;
      next2next = (jint) 0x00;
    }
    else
#line 1432
    if ((bp + 1) == l) {
      next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
      next2next = (jint) 0x00;
    }
    else {
      
#line 1436
      next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
      next2next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_, IOSByteArray_Get(data_, bp + 2) & (jint) 0xff);
    }
  }
  else {
    
#line 1440
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Invalid FillOrder"];
  }
  
#line 1443
  jint bitsLeft = 8 - bitPointer_;
  jint bitsFromNextByte = bitsToGet - bitsLeft;
  jint bitsFromNext2NextByte = 0;
  if (bitsFromNextByte > 8) {
    bitsFromNext2NextByte = bitsFromNextByte - 8;
    bitsFromNextByte = 8;
  }
  
#line 1451
  bytePointer_++;
  
#line 1453
  jint i1 = LShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_), bitsLeft)), (bitsToGet - bitsLeft));
  jint i2 = URShift32((next & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_), bitsFromNextByte)), (8 - bitsFromNextByte));
  
#line 1456
  jint i3 = 0;
  if (bitsFromNext2NextByte != 0) {
    LShiftAssignInt(&i2, bitsFromNext2NextByte);
    i3 = URShift32((next2next & IOSIntArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_, bitsFromNext2NextByte)),
#line 1460
    (8 - bitsFromNext2NextByte));
    i2 |= i3;
    bytePointer_++;
    bitPointer_ = bitsFromNext2NextByte;
  }
  else {
    
#line 1465
    if (bitsFromNextByte == 8) {
      bitPointer_ = 0;
      bytePointer_++;
    }
    else {
      
#line 1469
      bitPointer_ = bitsFromNextByte;
    }
  }
  
#line 1473
  jint i = i1 | i2;
  return i;
}


#line 1477
- (jint)nextLesserThan8BitsWithInt:(jint)bitsToGet {
  
#line 1478
  jbyte b, next;
  jint l = ((IOSByteArray *) nil_chk(data_))->size_ - 1;
  jint bp = self->bytePointer_;
  
#line 1482
  if (fillOrder_ == 1) {
    b = IOSByteArray_Get(data_, bp);
    if (bp == l) {
      next = (jint) 0x00;
    }
    else {
      
#line 1487
      next = IOSByteArray_Get(data_, bp + 1);
    }
  }
  else
#line 1489
  if (fillOrder_ == 2) {
    b = IOSByteArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_), IOSByteArray_Get(data_, bp) & (jint) 0xff);
    if (bp == l) {
      next = (jint) 0x00;
    }
    else {
      
#line 1494
      next = IOSByteArray_Get(ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_, IOSByteArray_Get(data_, bp + 1) & (jint) 0xff);
    }
  }
  else {
    
#line 1497
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Invalid FillOrder"];
  }
  
#line 1500
  jint bitsLeft = 8 - bitPointer_;
  jint bitsFromNextByte = bitsToGet - bitsLeft;
  
#line 1503
  jint shift = bitsLeft - bitsToGet;
  jint i1, i2;
  if (shift >= 0) {
    i1 = URShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_), bitsLeft)), shift);
    bitPointer_ += bitsToGet;
    if (bitPointer_ == 8) {
      bitPointer_ = 0;
      bytePointer_++;
    }
  }
  else {
    
#line 1513
    i1 = LShift32((b & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_), bitsLeft)), (-shift));
    i2 = URShift32((next & IOSIntArray_Get(nil_chk(ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_), bitsFromNextByte)), (8 - bitsFromNextByte));
    
#line 1516
    i1 |= i2;
    bytePointer_++;
    bitPointer_ = bitsFromNextByte;
  }
  
#line 1521
  return i1;
}


#line 1525
- (void)updatePointerWithInt:(jint)bitsToMoveBack {
  
#line 1526
  if (bitsToMoveBack > 8) {
    bytePointer_ -= bitsToMoveBack / 8;
    bitsToMoveBack %= 8;
  }
  
#line 1531
  jint i = bitPointer_ - bitsToMoveBack;
  if (i < 0) {
    bytePointer_--;
    bitPointer_ = 8 + i;
  }
  else {
    
#line 1536
    bitPointer_ = i;
  }
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfCodecTIFFFaxDecompressor *)other {
  [super copyAllFieldsTo:other];
  other->bitPointer_ = bitPointer_;
  other->bitsPerScanline_ = bitsPerScanline_;
  other->buffer_ = buffer_;
  other->bytePointer_ = bytePointer_;
  other->changingElemSize_ = changingElemSize_;
  other->compression_ = compression_;
  other->currChangingElems_ = currChangingElems_;
  other->data_ = data_;
  other->fails_ = fails_;
  other->fillBits_ = fillBits_;
  other->fillOrder_ = fillOrder_;
  other->h_ = h_;
  other->lastChangingElement_ = lastChangingElement_;
  other->lineBitNum_ = lineBitNum_;
  other->oneD_ = oneD_;
  other->prevChangingElems_ = prevChangingElems_;
  other->t4Options_ = t4Options_;
  other->t6Options_ = t6Options_;
  other->uncompressedMode_ = uncompressedMode_;
  other->w_ = w_;
}

+ (void)initialize {
  if (self == [ComItextpdfTextPdfCodecTIFFFaxDecompressor class]) {
    ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_ = [IOSIntArray arrayWithInts:(jint[]){
#line 100
      (jint) 0x00,
#line 101
      (jint) 0x01,
#line 102
      (jint) 0x03,
#line 103
      (jint) 0x07,
#line 104
      (jint) 0x0f,
#line 105
      (jint) 0x1f,
#line 106
      (jint) 0x3f,
#line 107
      (jint) 0x7f,
#line 108
      (jint) 0xff } count:9];
      ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_ = [IOSIntArray arrayWithInts:(jint[]){
#line 111
        (jint) 0x00,
#line 112
        (jint) 0x80,
#line 113
        (jint) 0xc0,
#line 114
        (jint) 0xe0,
#line 115
        (jint) 0xf0,
#line 116
        (jint) 0xf8,
#line 117
        (jint) 0xfc,
#line 118
        (jint) 0xfe,
#line 119
        (jint) 0xff } count:9];
        ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_ = [IOSByteArray arrayWithBytes:(jbyte[]){
#line 123
          0, -128, 64, -64, 32, -96, 96, -32,
#line 124
          16, -112, 80, -48, 48, -80, 112, -16,
#line 125
          8, -120, 72, -56, 40, -88, 104, -24,
#line 126
          24, -104, 88, -40, 56, -72, 120, -8,
#line 127
          4, -124, 68, -60, 36, -92, 100, -28,
#line 128
          20, -108, 84, -44, 52, -76, 116, -12,
#line 129
          12, -116, 76, -52, 44, -84, 108, -20,
#line 130
          28, -100, 92, -36, 60, -68, 124, -4,
#line 131
          2, -126, 66, -62, 34, -94, 98, -30,
#line 132
          18, -110, 82, -46, 50, -78, 114, -14,
#line 133
          10, -118, 74, -54, 42, -86, 106, -22,
#line 134
          26, -102, 90, -38, 58, -70, 122, -6,
#line 135
          6, -122, 70, -58, 38, -90, 102, -26,
#line 136
          22, -106, 86, -42, 54, -74, 118, -10,
#line 137
          14, -114, 78, -50, 46, -82, 110, -18,
#line 138
          30, -98, 94, -34, 62, -66, 126, -2,
#line 139
          1, -127, 65, -63, 33, -95, 97, -31,
#line 140
          17, -111, 81, -47, 49, -79, 113, -15,
#line 141
          9, -119, 73, -55, 41, -87, 105, -23,
#line 142
          25, -103, 89, -39, 57, -71, 121, -7,
#line 143
          5, -123, 69, -59, 37, -91, 101, -27,
#line 144
          21, -107, 85, -43, 53, -75, 117, -11,
#line 145
          13, -115, 77, -51, 45, -83, 109, -19,
#line 146
          29, -99, 93, -35, 61, -67, 125, -3,
#line 147
          3, -125, 67, -61, 35, -93, 99, -29,
#line 148
          19, -109, 83, -45, 51, -77, 115, -13,
#line 149
          11, -117, 75, -53, 43, -85, 107, -21,
#line 150
          27, -101, 91, -37, 59, -69, 123, -5,
#line 151
          7, -121, 71, -57, 39, -89, 103, -25,
#line 152
          23, -105, 87, -41, 55, -73, 119, -9,
#line 153
          15, -113, 79, -49, 47, -81, 111, -17,
#line 154
          31, -97, 95, -33, 63, -65, 127, -1 } count:256];
          ComItextpdfTextPdfCodecTIFFFaxDecompressor_white_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 158
            6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
#line 160
            944, 944, 944, 944, 976, 976, 976, 976,
#line 162
            1456, 1456, 1456, 1456, 1488, 1488, 1488, 1488,
#line 164
            718, 718, 718, 718, 718, 718, 718, 718,
#line 166
            750, 750, 750, 750, 750, 750, 750, 750,
#line 168
            1520, 1520, 1520, 1520, 1552, 1552, 1552, 1552,
#line 170
            428, 428, 428, 428, 428, 428, 428, 428,
#line 172
            428, 428, 428, 428, 428, 428, 428, 428,
#line 174
            654, 654, 654, 654, 654, 654, 654, 654,
#line 176
            1072, 1072, 1072, 1072, 1104, 1104, 1104, 1104,
#line 178
            1136, 1136, 1136, 1136, 1168, 1168, 1168, 1168,
#line 180
            1200, 1200, 1200, 1200, 1232, 1232, 1232, 1232,
#line 182
            622, 622, 622, 622, 622, 622, 622, 622,
#line 184
            1008, 1008, 1008, 1008, 1040, 1040, 1040, 1040,
#line 186
            44, 44, 44, 44, 44, 44, 44, 44,
#line 188
            44, 44, 44, 44, 44, 44, 44, 44,
#line 190
            396, 396, 396, 396, 396, 396, 396, 396,
#line 192
            396, 396, 396, 396, 396, 396, 396, 396,
#line 194
            1712, 1712, 1712, 1712, 1744, 1744, 1744, 1744,
#line 196
            846, 846, 846, 846, 846, 846, 846, 846,
#line 198
            1264, 1264, 1264, 1264, 1296, 1296, 1296, 1296,
#line 200
            1328, 1328, 1328, 1328, 1360, 1360, 1360, 1360,
#line 202
            1392, 1392, 1392, 1392, 1424, 1424, 1424, 1424,
#line 204
            686, 686, 686, 686, 686, 686, 686, 686,
#line 206
            910, 910, 910, 910, 910, 910, 910, 910,
#line 208
            1968, 1968, 1968, 1968, 2000, 2000, 2000, 2000,
#line 210
            2032, 2032, 2032, 2032, 16, 16, 16, 16,
#line 212
            10257, 10257, 10257, 10257, 12305, 12305, 12305, 12305,
#line 214
            330, 330, 330, 330, 330, 330, 330, 330,
#line 216
            330, 330, 330, 330, 330, 330, 330, 330,
#line 218
            330, 330, 330, 330, 330, 330, 330, 330,
#line 220
            330, 330, 330, 330, 330, 330, 330, 330,
#line 222
            362, 362, 362, 362, 362, 362, 362, 362,
#line 224
            362, 362, 362, 362, 362, 362, 362, 362,
#line 226
            362, 362, 362, 362, 362, 362, 362, 362,
#line 228
            362, 362, 362, 362, 362, 362, 362, 362,
#line 230
            878, 878, 878, 878, 878, 878, 878, 878,
#line 232
            1904, 1904, 1904, 1904, 1936, 1936, 1936, 1936,
#line 234
            -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221,
#line 236
            590, 590, 590, 590, 590, 590, 590, 590,
#line 238
            782, 782, 782, 782, 782, 782, 782, 782,
#line 240
            1584, 1584, 1584, 1584, 1616, 1616, 1616, 1616,
#line 242
            1648, 1648, 1648, 1648, 1680, 1680, 1680, 1680,
#line 244
            814, 814, 814, 814, 814, 814, 814, 814,
#line 246
            1776, 1776, 1776, 1776, 1808, 1808, 1808, 1808,
#line 248
            1840, 1840, 1840, 1840, 1872, 1872, 1872, 1872,
#line 250
            6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157,
#line 252
            6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157,
#line 254
            -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
#line 256
            -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
#line 258
            14353, 14353, 14353, 14353, 16401, 16401, 16401, 16401,
#line 260
            22547, 22547, 24595, 24595, 20497, 20497, 20497, 20497,
#line 262
            18449, 18449, 18449, 18449, 26643, 26643, 28691, 28691,
#line 264
            30739, 30739, -32749, -32749, -30701, -30701, -28653, -28653,
#line 266
            -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461,
#line 268
            8207, 8207, 8207, 8207, 8207, 8207, 8207, 8207,
#line 270
            72, 72, 72, 72, 72, 72, 72, 72,
#line 272
            72, 72, 72, 72, 72, 72, 72, 72,
#line 274
            72, 72, 72, 72, 72, 72, 72, 72,
#line 276
            72, 72, 72, 72, 72, 72, 72, 72,
#line 278
            72, 72, 72, 72, 72, 72, 72, 72,
#line 280
            72, 72, 72, 72, 72, 72, 72, 72,
#line 282
            72, 72, 72, 72, 72, 72, 72, 72,
#line 284
            72, 72, 72, 72, 72, 72, 72, 72,
#line 286
            104, 104, 104, 104, 104, 104, 104, 104,
#line 288
            104, 104, 104, 104, 104, 104, 104, 104,
#line 290
            104, 104, 104, 104, 104, 104, 104, 104,
#line 292
            104, 104, 104, 104, 104, 104, 104, 104,
#line 294
            104, 104, 104, 104, 104, 104, 104, 104,
#line 296
            104, 104, 104, 104, 104, 104, 104, 104,
#line 298
            104, 104, 104, 104, 104, 104, 104, 104,
#line 300
            104, 104, 104, 104, 104, 104, 104, 104,
#line 302
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 304
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 306
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 308
            4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107,
#line 310
            266, 266, 266, 266, 266, 266, 266, 266,
#line 312
            266, 266, 266, 266, 266, 266, 266, 266,
#line 314
            266, 266, 266, 266, 266, 266, 266, 266,
#line 316
            266, 266, 266, 266, 266, 266, 266, 266,
#line 318
            298, 298, 298, 298, 298, 298, 298, 298,
#line 320
            298, 298, 298, 298, 298, 298, 298, 298,
#line 322
            298, 298, 298, 298, 298, 298, 298, 298,
#line 324
            298, 298, 298, 298, 298, 298, 298, 298,
#line 326
            524, 524, 524, 524, 524, 524, 524, 524,
#line 328
            524, 524, 524, 524, 524, 524, 524, 524,
#line 330
            556, 556, 556, 556, 556, 556, 556, 556,
#line 332
            556, 556, 556, 556, 556, 556, 556, 556,
#line 334
            136, 136, 136, 136, 136, 136, 136, 136,
#line 336
            136, 136, 136, 136, 136, 136, 136, 136,
#line 338
            136, 136, 136, 136, 136, 136, 136, 136,
#line 340
            136, 136, 136, 136, 136, 136, 136, 136,
#line 342
            136, 136, 136, 136, 136, 136, 136, 136,
#line 344
            136, 136, 136, 136, 136, 136, 136, 136,
#line 346
            136, 136, 136, 136, 136, 136, 136, 136,
#line 348
            136, 136, 136, 136, 136, 136, 136, 136,
#line 350
            168, 168, 168, 168, 168, 168, 168, 168,
#line 352
            168, 168, 168, 168, 168, 168, 168, 168,
#line 354
            168, 168, 168, 168, 168, 168, 168, 168,
#line 356
            168, 168, 168, 168, 168, 168, 168, 168,
#line 358
            168, 168, 168, 168, 168, 168, 168, 168,
#line 360
            168, 168, 168, 168, 168, 168, 168, 168,
#line 362
            168, 168, 168, 168, 168, 168, 168, 168,
#line 364
            168, 168, 168, 168, 168, 168, 168, 168,
#line 366
            460, 460, 460, 460, 460, 460, 460, 460,
#line 368
            460, 460, 460, 460, 460, 460, 460, 460,
#line 370
            492, 492, 492, 492, 492, 492, 492, 492,
#line 372
            492, 492, 492, 492, 492, 492, 492, 492,
#line 374
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 376
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 378
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 380
            2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059,
#line 382
            200, 200, 200, 200, 200, 200, 200, 200,
#line 384
            200, 200, 200, 200, 200, 200, 200, 200,
#line 386
            200, 200, 200, 200, 200, 200, 200, 200,
#line 388
            200, 200, 200, 200, 200, 200, 200, 200,
#line 390
            200, 200, 200, 200, 200, 200, 200, 200,
#line 392
            200, 200, 200, 200, 200, 200, 200, 200,
#line 394
            200, 200, 200, 200, 200, 200, 200, 200,
#line 396
            200, 200, 200, 200, 200, 200, 200, 200,
#line 398
            232, 232, 232, 232, 232, 232, 232, 232,
#line 400
            232, 232, 232, 232, 232, 232, 232, 232,
#line 402
            232, 232, 232, 232, 232, 232, 232, 232,
#line 404
            232, 232, 232, 232, 232, 232, 232, 232,
#line 406
            232, 232, 232, 232, 232, 232, 232, 232,
#line 408
            232, 232, 232, 232, 232, 232, 232, 232,
#line 410
            232, 232, 232, 232, 232, 232, 232, 232,
#line 412
            232, 232, 232, 232, 232, 232, 232, 232 } count:1024];
            ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 415
              28679, 28679, 31752, (jshort) 32777,
#line 416
              (jshort) 33801, (jshort) 34825, (jshort) 35849, (jshort) 36873,
#line 417
              (jshort) 29703, (jshort) 29703, (jshort) 30727, (jshort) 30727,
#line 418
              (jshort) 37897, (jshort) 38921, (jshort) 39945, (jshort) 40969 } count:16];
              ComItextpdfTextPdfCodecTIFFFaxDecompressor_initBlack_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 423
                3226, 6412, 200, 168, 38, 38, 134, 134,
#line 425
                100, 100, 100, 100, 68, 68, 68, 68 } count:16];
                ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoBitBlack_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 428
                  292, 260, 226, 226 } count:4];
                  ComItextpdfTextPdfCodecTIFFFaxDecompressor_black_ = [IOSShortArray arrayWithShorts:(jshort[]){
#line 432
                    62, 62, 30, 30, 0, 0, 0, 0,
#line 434
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 436
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 438
                    0, 0, 0, 0, 0, 0, 0, 0,
#line 440
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 442
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 444
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 446
                    3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225,
#line 448
                    588, 588, 588, 588, 588, 588, 588, 588,
#line 450
                    1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776,
#line 452
                    1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904,
#line 454
                    1936, 1936, -16365, -14317, 782, 782, 782, 782,
#line 456
                    814, 814, 814, 814, -12269, -10221, 10257, 10257,
#line 458
                    12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712,
#line 460
                    1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605,
#line 462
                    2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061,
#line 464
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 466
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 468
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 470
                    424, 424, 424, 424, 424, 424, 424, 424,
#line 472
                    750, 750, 750, 750, 1616, 1616, 1648, 1648,
#line 474
                    1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520,
#line 476
                    1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209,
#line 478
                    524, 524, 524, 524, 524, 524, 524, 524,
#line 480
                    556, 556, 556, 556, 556, 556, 556, 556,
#line 482
                    1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032,
#line 484
                    976, 976, 1008, 1008, 1040, 1040, 1072, 1072,
#line 486
                    1296, 1296, 1328, 1328, 718, 718, 718, 718,
#line 488
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 490
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 492
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 494
                    456, 456, 456, 456, 456, 456, 456, 456,
#line 496
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 498
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 500
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 502
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 504
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 506
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 508
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 510
                    326, 326, 326, 326, 326, 326, 326, 326,
#line 512
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 514
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 516
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 518
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 520
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 522
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 524
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 526
                    358, 358, 358, 358, 358, 358, 358, 358,
#line 528
                    490, 490, 490, 490, 490, 490, 490, 490,
#line 530
                    490, 490, 490, 490, 490, 490, 490, 490,
#line 532
                    4113, 4113, 6161, 6161, 848, 848, 880, 880,
#line 534
                    912, 912, 944, 944, 622, 622, 622, 622,
#line 536
                    654, 654, 654, 654, 1104, 1104, 1136, 1136,
#line 538
                    1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264,
#line 540
                    686, 686, 686, 686, 1360, 1360, 1392, 1392,
#line 542
                    12, 12, 12, 12, 12, 12, 12, 12,
#line 544
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 546
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 548
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 550
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 552
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 554
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 556
                    390, 390, 390, 390, 390, 390, 390, 390,
#line 558
                    390, 390, 390, 390, 390, 390, 390, 390 } count:512];
                    ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoDCodes_ = [IOSByteArray arrayWithBytes:(jbyte[]){
#line 561
                      80, 88, 23, 71, 30, 30, 62, 62,
#line 563
                      4, 4, 4, 4, 4, 4, 4, 4,
#line 565
                      11, 11, 11, 11, 11, 11, 11, 11,
#line 567
                      11, 11, 11, 11, 11, 11, 11, 11,
#line 569
                      35, 35, 35, 35, 35, 35, 35, 35,
#line 571
                      35, 35, 35, 35, 35, 35, 35, 35,
#line 573
                      51, 51, 51, 51, 51, 51, 51, 51,
#line 575
                      51, 51, 51, 51, 51, 51, 51, 51,
#line 577
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 579
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 581
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 583
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 585
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 587
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 589
                      41, 41, 41, 41, 41, 41, 41, 41,
#line 591
                      41, 41, 41, 41, 41, 41, 41, 41 } count:128];
                      ComItextpdfTextPdfCodecTIFFFaxDecompressor_initialized = YES;
                    }
                  }

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TIFFFaxDecompressor", NULL, 0x1, NULL },
    { "SetOptionsWithInt:withInt:withInt:withInt:", "SetOptions", "V", 0x1, NULL },
    { "decodeRawWithByteArray:withByteArray:withInt:withInt:", "decodeRaw", "V", 0x1, NULL },
    { "decodeRLE", NULL, "V", 0x1, NULL },
    { "decodeNextScanline", NULL, "V", 0x1, NULL },
    { "decodeT4", NULL, "V", 0x1, NULL },
    { "decodeT6", NULL, "V", 0x21, NULL },
    { "setToBlackWithInt:withInt:", "setToBlack", "V", 0x2, NULL },
    { "decodeWhiteCodeWord", NULL, "I", 0x2, NULL },
    { "decodeBlackCodeWord", NULL, "I", 0x2, NULL },
    { "findNextLine", NULL, "I", 0x2, NULL },
    { "getNextChangingElementWithInt:withBoolean:withIntArray:", "getNextChangingElement", "V", 0x2, NULL },
    { "nextNBitsWithInt:", "nextNBits", "I", 0x2, NULL },
    { "nextLesserThan8BitsWithInt:", "nextLesserThan8Bits", "I", 0x2, NULL },
    { "updatePointerWithInt:", "updatePointer", "V", 0x2, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "fillOrder_", NULL, 0x4, "I", NULL,  },
    { "compression_", NULL, 0x4, "I", NULL,  },
    { "t4Options_", NULL, 0x2, "I", NULL,  },
    { "t6Options_", NULL, 0x2, "I", NULL,  },
    { "fails_", NULL, 0x1, "I", NULL,  },
    { "uncompressedMode_", NULL, 0x4, "I", NULL,  },
    { "fillBits_", NULL, 0x4, "I", NULL,  },
    { "oneD_", NULL, 0x4, "I", NULL,  },
    { "data_", NULL, 0x2, "[B", NULL,  },
    { "bitPointer_", NULL, 0x2, "I", NULL,  },
    { "bytePointer_", NULL, 0x2, "I", NULL,  },
    { "buffer_", NULL, 0x2, "[B", NULL,  },
    { "w_", NULL, 0x2, "I", NULL,  },
    { "h_", NULL, 0x2, "I", NULL,  },
    { "bitsPerScanline_", NULL, 0x2, "I", NULL,  },
    { "lineBitNum_", NULL, 0x2, "I", NULL,  },
    { "changingElemSize_", NULL, 0x2, "I", NULL,  },
    { "prevChangingElems_", NULL, 0x2, "[I", NULL,  },
    { "currChangingElems_", NULL, 0x2, "[I", NULL,  },
    { "lastChangingElement_", NULL, 0x2, "I", NULL,  },
    { "table1_", NULL, 0x8, "[I", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_table1_,  },
    { "table2_", NULL, 0x8, "[I", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_table2_,  },
    { "flipTable_", NULL, 0x8, "[B", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_flipTable_,  },
    { "white_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_white_,  },
    { "additionalMakeup_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_additionalMakeup_,  },
    { "initBlack_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_initBlack_,  },
    { "twoBitBlack_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoBitBlack_,  },
    { "black_", NULL, 0x8, "[S", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_black_,  },
    { "twoDCodes_", NULL, 0x8, "[B", &ComItextpdfTextPdfCodecTIFFFaxDecompressor_twoDCodes_,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfCodecTIFFFaxDecompressor = { "TIFFFaxDecompressor", "com.itextpdf.text.pdf.codec", NULL, 0x1, 15, methods, 29, fields, 0, NULL};
  return &_ComItextpdfTextPdfCodecTIFFFaxDecompressor;
}

@end

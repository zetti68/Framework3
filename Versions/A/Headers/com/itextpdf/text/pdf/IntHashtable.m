//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/IntHashtable.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/IntHashtable.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/pdf/IntHashtable.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InternalError.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Arrays.h"
#include "java/util/Iterator.h"
#include "java/util/NoSuchElementException.h"


#line 52
@implementation ComItextpdfTextPdfIntHashtable


#line 83
- (instancetype)init {
  return
#line 84
  [self initComItextpdfTextPdfIntHashtableWithInt:150 withFloat:0.75f];
}


#line 95
- (instancetype)initWithInt:(jint)initialCapacity {
  return
#line 96
  [self initComItextpdfTextPdfIntHashtableWithInt:initialCapacity withFloat:0.75f];
}


#line 108
- (instancetype)initComItextpdfTextPdfIntHashtableWithInt:(jint)initialCapacity
                                                withFloat:(jfloat)loadFactor {
  if (self =
#line 109
  [super init]) {
    
#line 110
    if (initialCapacity < 0) {
      @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"illegal.capacity.1" withInt:initialCapacity]];
    }
    
#line 113
    if (loadFactor <= 0) {
      @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"illegal.load.1" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [NSString valueOfFloat:loadFactor] } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
    
#line 116
    if (initialCapacity == 0) {
      initialCapacity = 1;
    }
    
#line 119
    self->loadFactor_ = loadFactor;
    
#line 120
    table_ = [IOSObjectArray arrayWithLength:initialCapacity type:[IOSClass classWithClass:[ComItextpdfTextPdfIntHashtable_Entry class]]];
    
#line 121
    threshold_ = J2ObjCFpToInt((initialCapacity * loadFactor));
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor {
  return [self initComItextpdfTextPdfIntHashtableWithInt:
#line 108
initialCapacity withFloat:loadFactor];
}


#line 129
- (jint)size {
  
#line 130
  return count_;
}


#line 139
- (jboolean)isEmpty {
  
#line 140
  return count_ == 0;
}


#line 161
- (jboolean)containsWithInt:(jint)value {
  
#line 163
  IOSObjectArray *tab = table_;
  for (jint i = ((IOSObjectArray *) nil_chk(tab))->size_; i-- > 0; ) {
    for (ComItextpdfTextPdfIntHashtable_Entry *e = IOSObjectArray_Get(tab, i); e != nil; e = e->next_) {
      if (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->value_ == value) {
        return YES;
      }
    }
  }
  return NO;
}


#line 186
- (jboolean)containsValueWithInt:(jint)value {
  
#line 187
  return [self containsWithInt:value];
}


#line 199
- (jboolean)containsKeyWithInt:(jint)key {
  
#line 200
  IOSObjectArray *tab = table_;
  jint hash_ = key;
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfIntHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      return YES;
    }
  }
  return NO;
}


#line 220
- (jint)getWithInt:(jint)key {
  
#line 221
  IOSObjectArray *tab = table_;
  jint hash_ = key;
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfIntHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      return e->value_;
    }
  }
  return 0;
}


#line 262
- (void)rehash {
  
#line 263
  jint oldCapacity = ((IOSObjectArray *) nil_chk(table_))->size_;
  IOSObjectArray *oldMap = table_;
  
#line 266
  jint newCapacity = oldCapacity * 2 + 1;
  IOSObjectArray *newMap = [IOSObjectArray arrayWithLength:newCapacity type:[IOSClass classWithClass:[ComItextpdfTextPdfIntHashtable_Entry class]]];
  
#line 269
  threshold_ = J2ObjCFpToInt((newCapacity * loadFactor_));
  table_ = newMap;
  
#line 272
  for (jint i = oldCapacity; i-- > 0; ) {
    for (ComItextpdfTextPdfIntHashtable_Entry *old = IOSObjectArray_Get(oldMap, i); old != nil; ) {
      ComItextpdfTextPdfIntHashtable_Entry *e = old;
      old = ((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(old))->next_;
      
#line 277
      jint index = (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->hash__ & (jint) 0x7FFFFFFF) % newCapacity;
      e->next_ = IOSObjectArray_Get(newMap, index);
      IOSObjectArray_Set(newMap, index, e);
    }
  }
}


#line 299
- (jint)putWithInt:(jint)key
           withInt:(jint)value {
  
#line 301
  IOSObjectArray *tab = table_;
  jint hash_ = key;
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfIntHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      jint old = e->value_;
      
#line 308
      e->value_ = value;
      return old;
    }
  }
  
#line 313
  if (count_ >= threshold_) {
    
#line 315
    [self rehash];
    
#line 317
    tab = table_;
    index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  }
  
#line 322
  ComItextpdfTextPdfIntHashtable_Entry *e = [[ComItextpdfTextPdfIntHashtable_Entry alloc] initWithInt:hash_ withInt:key withInt:value withComItextpdfTextPdfIntHashtable_Entry:IOSObjectArray_Get(nil_chk(tab), index)];
  IOSObjectArray_Set(tab, index, e);
  count_++;
  return 0;
}


#line 339
- (jint)removeWithInt:(jint)key {
  
#line 340
  IOSObjectArray *tab = table_;
  jint hash_ = key;
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfIntHashtable_Entry *e = IOSObjectArray_Get(tab, index), *prev = nil; e != nil; prev = e, e = e->next_) {
    if (((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      if (prev != nil) {
        prev->next_ = e->next_;
      }
      else {
        
#line 348
        IOSObjectArray_Set(tab, index, e->next_);
      }
      count_--;
      jint oldValue = e->value_;
      e->value_ = 0;
      return oldValue;
    }
  }
  return 0;
}


#line 362
- (void)clear {
  
#line 363
  IOSObjectArray *tab = table_;
  for (jint index = ((IOSObjectArray *) nil_chk(tab))->size_; --index >= 0; ) {
    IOSObjectArray_Set(tab, index, nil);
  }
  count_ = 0;
}


#line 460
- (id<JavaUtilIterator>)getEntryIterator {
  
#line 461
  return [[ComItextpdfTextPdfIntHashtable_IntHashtableIterator alloc] initWithComItextpdfTextPdfIntHashtable_EntryArray:table_];
}


#line 464
- (IOSIntArray *)toOrderedKeys {
  
#line 465
  IOSIntArray *res = [self getKeys];
  [JavaUtilArrays sortWithIntArray:res];
  return res;
}


#line 470
- (IOSIntArray *)getKeys {
  
#line 471
  IOSIntArray *res = [IOSIntArray arrayWithLength:count_];
  jint ptr = 0;
  jint index = ((IOSObjectArray *) nil_chk(table_))->size_;
  ComItextpdfTextPdfIntHashtable_Entry *entry_ = nil;
  while (YES) {
    if (entry_ == nil)
#line 477
    while (index-- > 0 && (entry_ = IOSObjectArray_Get(table_, index)) == nil) ;
    if (entry_ == nil)
#line 479
    break;
    ComItextpdfTextPdfIntHashtable_Entry *e = entry_;
    entry_ = ((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(e))->next_;
    *IOSIntArray_GetRef(res, ptr++) = e->key_;
  }
  return res;
}


#line 487
- (jint)getOneKey {
  
#line 488
  if (count_ == 0)
#line 489
  return 0;
  jint index = ((IOSObjectArray *) nil_chk(table_))->size_;
  ComItextpdfTextPdfIntHashtable_Entry *entry_ = nil;
  while (index-- > 0 && (entry_ = IOSObjectArray_Get(table_, index)) == nil) ;
  if (entry_ == nil)
#line 494
  return 0;
  return ((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(entry_))->key_;
}


#line 499
- (id)clone {
  
#line 500
  @try {
    ComItextpdfTextPdfIntHashtable *t = (ComItextpdfTextPdfIntHashtable *) check_class_cast([super clone], [ComItextpdfTextPdfIntHashtable class]);
    ((ComItextpdfTextPdfIntHashtable *) nil_chk(t))->table_ = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(table_))->size_ type:[IOSClass classWithClass:[ComItextpdfTextPdfIntHashtable_Entry class]]];
    for (jint i = table_->size_; i-- > 0; ) {
      IOSObjectArray_Set(t->table_, i, IOSObjectArray_Get(table_, i) != nil ?
#line 505
      (ComItextpdfTextPdfIntHashtable_Entry *) check_class_cast([((ComItextpdfTextPdfIntHashtable_Entry *) nil_chk(IOSObjectArray_Get(table_, i))) clone], [ComItextpdfTextPdfIntHashtable_Entry class]) : nil);
    }
    return t;
  }
  @catch (
#line 508
  JavaLangCloneNotSupportedException *e) {
    
#line 510
    @throw [[JavaLangInternalError alloc] init];
  }
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfIntHashtable *)other {
  [super copyAllFieldsTo:other];
  other->count_ = count_;
  other->loadFactor_ = loadFactor_;
  other->table_ = table_;
  other->threshold_ = threshold_;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "IntHashtable", NULL, 0x1, NULL },
    { "initWithInt:", "IntHashtable", NULL, 0x1, NULL },
    { "initWithInt:withFloat:", "IntHashtable", NULL, 0x1, NULL },
    { "size", NULL, "I", 0x1, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "containsWithInt:", "contains", "Z", 0x1, NULL },
    { "containsValueWithInt:", "containsValue", "Z", 0x1, NULL },
    { "containsKeyWithInt:", "containsKey", "Z", 0x1, NULL },
    { "getWithInt:", "get", "I", 0x1, NULL },
    { "rehash", NULL, "V", 0x4, NULL },
    { "putWithInt:withInt:", "put", "I", 0x1, NULL },
    { "removeWithInt:", "remove", "I", 0x1, NULL },
    { "clear", NULL, "V", 0x1, NULL },
    { "getEntryIterator", NULL, "Ljava.util.Iterator;", 0x1, NULL },
    { "toOrderedKeys", NULL, "[I", 0x1, NULL },
    { "getKeys", NULL, "[I", 0x1, NULL },
    { "getOneKey", NULL, "I", 0x1, NULL },
    { "clone", NULL, "Ljava.lang.Object;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "table_", NULL, 0x82, "[Lcom.itextpdf.text.pdf.IntHashtable$Entry;", NULL,  },
    { "count_", NULL, 0x82, "I", NULL,  },
    { "threshold_", NULL, 0x2, "I", NULL,  },
    { "loadFactor_", NULL, 0x2, "F", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfIntHashtable = { "IntHashtable", "com.itextpdf.text.pdf", NULL, 0x1, 18, methods, 4, fields, 0, NULL};
  return &_ComItextpdfTextPdfIntHashtable;
}

@end


#line 374
@implementation ComItextpdfTextPdfIntHashtable_Entry


#line 389
- (instancetype)initWithInt:(jint)hash_
                    withInt:(jint)key
                    withInt:(jint)value
withComItextpdfTextPdfIntHashtable_Entry:(ComItextpdfTextPdfIntHashtable_Entry *)next {
  if (self = [super init]) {
    
#line 390
    self->hash__ = hash_;
    
#line 391
    self->key_ = key;
    
#line 392
    self->value_ = value;
    
#line 393
    self->next_ = next;
  }
  return self;
}


#line 407
- (jint)getKey {
  
#line 408
  return key_;
}


#line 410
- (jint)getValue {
  
#line 411
  return value_;
}


#line 414
- (id)clone {
  
#line 415
  ComItextpdfTextPdfIntHashtable_Entry *entry_ = [[ComItextpdfTextPdfIntHashtable_Entry alloc] initWithInt:hash__ withInt:key_ withInt:value_ withComItextpdfTextPdfIntHashtable_Entry:next_ != nil ? (ComItextpdfTextPdfIntHashtable_Entry *) check_class_cast([next_ clone], [ComItextpdfTextPdfIntHashtable_Entry class]) : nil];
  return entry_;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfIntHashtable_Entry *)other {
  [super copyAllFieldsTo:other];
  other->hash__ = hash__;
  other->key_ = key_;
  other->next_ = next_;
  other->value_ = value_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withInt:withInt:withComItextpdfTextPdfIntHashtable_Entry:", "Entry", NULL, 0x4, NULL },
    { "getKey", NULL, "I", 0x1, NULL },
    { "getValue", NULL, "I", 0x1, NULL },
    { "clone", NULL, "Ljava.lang.Object;", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "hash__", "hash", 0x0, "I", NULL,  },
    { "key_", NULL, 0x0, "I", NULL,  },
    { "value_", NULL, 0x0, "I", NULL,  },
    { "next_", NULL, 0x0, "Lcom.itextpdf.text.pdf.IntHashtable$Entry;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfIntHashtable_Entry = { "Entry", "com.itextpdf.text.pdf", "IntHashtable", 0x8, 4, methods, 4, fields, 0, NULL};
  return &_ComItextpdfTextPdfIntHashtable_Entry;
}

@end


#line 421
@implementation ComItextpdfTextPdfIntHashtable_IntHashtableIterator


#line 426
- (instancetype)initWithComItextpdfTextPdfIntHashtable_EntryArray:(IOSObjectArray *)table {
  if (self = [super init]) {
    
#line 427
    self->table_ = table;
    
#line 428
    self->index_ = ((IOSObjectArray *) nil_chk(table))->size_;
  }
  return self;
}


#line 430
- (jboolean)hasNext {
  
#line 431
  if (entry__ != nil) {
    return YES;
  }
  while (index_-- > 0) {
    if ((entry__ = IOSObjectArray_Get(nil_chk(table_), index_)) != nil) {
      return YES;
    }
  }
  return NO;
}


#line 442
- (ComItextpdfTextPdfIntHashtable_Entry *)next {
  
#line 443
  if (entry__ == nil) {
    while (index_-- > 0 && (entry__ = IOSObjectArray_Get(nil_chk(table_), index_)) == nil) ;
  }
  if (entry__ != nil) {
    ComItextpdfTextPdfIntHashtable_Entry *e = entry__;
    entry__ = e->next_;
    return e;
  }
  @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"inthashtableiterator" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
}


#line 453
- (void)remove {
  
#line 454
  @throw [[JavaLangUnsupportedOperationException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"remove.not.supported" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfIntHashtable_IntHashtableIterator *)other {
  [super copyAllFieldsTo:other];
  other->entry__ = entry__;
  other->index_ = index_;
  other->table_ = table_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfTextPdfIntHashtable_EntryArray:", "IntHashtableIterator", NULL, 0x0, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
    { "next", NULL, "Lcom.itextpdf.text.pdf.IntHashtable$Entry;", 0x1, NULL },
    { "remove", NULL, "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "index_", NULL, 0x0, "I", NULL,  },
    { "table_", NULL, 0x0, "[Lcom.itextpdf.text.pdf.IntHashtable$Entry;", NULL,  },
    { "entry__", "entry", 0x0, "Lcom.itextpdf.text.pdf.IntHashtable$Entry;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfIntHashtable_IntHashtableIterator = { "IntHashtableIterator", "com.itextpdf.text.pdf", "IntHashtable", 0x8, 4, methods, 3, fields, 0, NULL};
  return &_ComItextpdfTextPdfIntHashtable_IntHashtableIterator;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/MappedRandomAccessFile.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/MappedRandomAccessFile.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/pdf/MappedRandomAccessFile.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileNotFoundException.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/Boolean.h"
#include "java/lang/Error.h"
#include "java/lang/Exception.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/lang/reflect/Method.h"
#include "java/nio/Buffer.h"
#include "java/nio/BufferUnderflowException.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/MappedByteBuffer.h"
#include "java/nio/channels/FileChannel.h"
#include "java/security/AccessController.h"


#line 63
@implementation ComItextpdfTextPdfMappedRandomAccessFile


#line 79
- (instancetype)initWithNSString:(NSString *)filename
                    withNSString:(NSString *)mode {
  if (self = [super init]) {
    channel_ =
#line 67
    nil;
    
#line 82
    if ([((NSString *) nil_chk(mode)) isEqual:@"rw"])
#line 83
    [self init__WithJavaNioChannelsFileChannel:
#line 84
    [((JavaIoRandomAccessFile *) [[JavaIoRandomAccessFile alloc] initWithNSString:filename withNSString:mode]) getChannel] withJavaNioChannelsFileChannel_MapMode:JavaNioChannelsFileChannel_MapMode_get_READ_WRITE_()];
    else
#line 87
    [self init__WithJavaNioChannelsFileChannel:
#line 88
    [((JavaIoFileInputStream *) [[JavaIoFileInputStream alloc] initWithNSString:filename]) getChannel] withJavaNioChannelsFileChannel_MapMode:JavaNioChannelsFileChannel_MapMode_get_READ_ONLY_()];
  }
  return self;
}


#line 99
- (void)init__WithJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)channel
      withJavaNioChannelsFileChannel_MapMode:(JavaNioChannelsFileChannel_MapMode *)mapMode {
  
#line 102
  self->channel_ = channel;
  
#line 105
  size_ = [((JavaNioChannelsFileChannel *) nil_chk(channel)) size];
  pos_ = 0;
  jint requiredBuffers = (jint) (size_ / ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE) + (size_ % ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE == 0 ? 0 : 1);
  
#line 110
  mappedBuffers_ = [IOSObjectArray arrayWithLength:requiredBuffers type:[IOSClass classWithClass:[JavaNioMappedByteBuffer class]]];
  @try {
    jint index = 0;
    for (jlong offset = 0; offset < size_; offset += ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE) {
      jlong size2 = [JavaLangMath minWithLong:size_ - offset withLong:ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE];
      IOSObjectArray_Set(mappedBuffers_, index, [channel mapWithJavaNioChannelsFileChannel_MapMode:mapMode withLong:offset withLong:size2]);
      (void) [((JavaNioMappedByteBuffer *) nil_chk(IOSObjectArray_Get(mappedBuffers_, index))) load__];
      index++;
    }
    if (index != requiredBuffers) {
      @throw [[JavaLangError alloc] initWithNSString:JreStrcat("$I$I", @"Should never happen - ", index, @" != ", requiredBuffers)];
    }
  }
  @catch (
#line 122
  JavaIoIOException *e) {
    [self close];
    @throw e;
  }
  @catch (
#line 125
  JavaLangRuntimeException *e) {
    [self close];
    @throw e;
  }
}


#line 135
- (JavaNioChannelsFileChannel *)getChannel {
  
#line 136
  return channel_;
}


#line 143
- (jint)read {
  
#line 144
  @try {
    jint mapN = (jint) (pos_ / ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE);
    jint offN = (jint) (pos_ % ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE);
    
#line 148
    if (mapN >= ((IOSObjectArray *) nil_chk(mappedBuffers_))->size_)
#line 149
    return -1;
    
#line 151
    if (offN >= [((JavaNioMappedByteBuffer *) nil_chk(IOSObjectArray_Get(mappedBuffers_, mapN))) limit])
#line 152
    return -1;
    
#line 154
    jbyte b = [((JavaNioMappedByteBuffer *) nil_chk(IOSObjectArray_Get(mappedBuffers_, mapN))) getWithInt:offN];
    pos_++;
    jint n = b & (jint) 0xff;
    
#line 158
    return n;
  }
  @catch (
#line 159
  JavaNioBufferUnderflowException *e) {
    return -1;
  }
}


#line 171
- (jint)readWithByteArray:(IOSByteArray *)bytes
                  withInt:(jint)off
                  withInt:(jint)len {
  
#line 172
  jint mapN = (jint) (pos_ / ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE);
  jint offN = (jint) (pos_ % ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE);
  jint totalRead = 0;
  
#line 176
  while (totalRead < len) {
    if (mapN >= ((IOSObjectArray *) nil_chk(mappedBuffers_))->size_)
#line 178
    break;
    JavaNioMappedByteBuffer *currentBuffer = IOSObjectArray_Get(mappedBuffers_, mapN);
    if (offN > [((JavaNioMappedByteBuffer *) nil_chk(currentBuffer)) limit])
#line 181
    break;
    (void) [currentBuffer positionWithInt:offN];
    jint bytesFromThisBuffer = [JavaLangMath minWithInt:len - totalRead withInt:[currentBuffer remaining]];
    (void) [currentBuffer getWithByteArray:bytes withInt:off withInt:bytesFromThisBuffer];
    off += bytesFromThisBuffer;
    pos_ += bytesFromThisBuffer;
    totalRead += bytesFromThisBuffer;
    
#line 189
    mapN++;
    offN = 0;
  }
  
#line 193
  return totalRead == 0 ? -1 : totalRead;
}


#line 200
- (jlong)getFilePointer {
  
#line 201
  return pos_;
}


#line 208
- (void)seekWithLong:(jlong)pos {
  
#line 209
  self->pos_ = pos;
}


#line 216
- (jlong)length {
  
#line 217
  return size_;
}


#line 224
- (void)close {
  
#line 225
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(mappedBuffers_))->size_; i++) {
    if (IOSObjectArray_Get(mappedBuffers_, i) != nil) {
      [ComItextpdfTextPdfMappedRandomAccessFile cleanWithJavaNioByteBuffer:IOSObjectArray_Get(mappedBuffers_, i)];
      IOSObjectArray_Set(mappedBuffers_, i, nil);
    }
  }
  
#line 232
  if (channel_ != nil)
#line 233
  [channel_ close];
  channel_ = nil;
}


#line 242
- (void)dealloc {
  
#line 243
  [self close];
  channel_ = nil;
  mappedBuffers_ = nil;
}


#line 252
+ (jboolean)cleanWithJavaNioByteBuffer:(JavaNioByteBuffer *)buffer {
  
#line 253
  if (buffer == nil || ![buffer isDirect])
#line 254
  return NO;
  
#line 256
  JavaLangBoolean *b = (JavaLangBoolean *) check_class_cast([JavaSecurityAccessController doPrivilegedWithJavaSecurityPrivilegedAction:[[ComItextpdfTextPdfMappedRandomAccessFile_$1 alloc] initWithJavaNioByteBuffer:buffer]], [JavaLangBoolean class]);
  
#line 274
  return [((JavaLangBoolean *) nil_chk(b)) booleanValue];
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfMappedRandomAccessFile *)other {
  [super copyAllFieldsTo:other];
  other->channel_ = channel_;
  other->mappedBuffers_ = mappedBuffers_;
  other->pos_ = pos_;
  other->size_ = size_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withNSString:", "MappedRandomAccessFile", NULL, 0x1, "Ljava.io.FileNotFoundException;Ljava.io.IOException;" },
    { "init__WithJavaNioChannelsFileChannel:withJavaNioChannelsFileChannel_MapMode:", "init", "V", 0x2, "Ljava.io.IOException;" },
    { "getChannel", NULL, "Ljava.nio.channels.FileChannel;", 0x1, NULL },
    { "read", NULL, "I", 0x1, NULL },
    { "readWithByteArray:withInt:withInt:", "read", "I", 0x1, NULL },
    { "getFilePointer", NULL, "J", 0x1, NULL },
    { "seekWithLong:", "seek", "V", 0x1, NULL },
    { "length", NULL, "J", 0x1, NULL },
    { "close", NULL, "V", 0x1, "Ljava.io.IOException;" },
    { "dealloc", "finalize", "V", 0x4, "Ljava.lang.Throwable;" },
    { "cleanWithJavaNioByteBuffer:", "clean", "Z", 0x9, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "BUFSIZE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfTextPdfMappedRandomAccessFile_BUFSIZE },
    { "channel_", NULL, 0x2, "Ljava.nio.channels.FileChannel;", NULL,  },
    { "mappedBuffers_", NULL, 0x2, "[Ljava.nio.MappedByteBuffer;", NULL,  },
    { "size_", NULL, 0x2, "J", NULL,  },
    { "pos_", NULL, 0x2, "J", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfMappedRandomAccessFile = { "MappedRandomAccessFile", "com.itextpdf.text.pdf", NULL, 0x1, 11, methods, 5, fields, 0, NULL};
  return &_ComItextpdfTextPdfMappedRandomAccessFile;
}

@end

@implementation ComItextpdfTextPdfMappedRandomAccessFile_$1


#line 257
- (JavaLangBoolean *)run {
  
#line 258
  JavaLangBoolean *success = JavaLangBoolean_get_FALSE__();
  @try {
    JavaLangReflectMethod *getCleanerMethod = [[((JavaNioByteBuffer *) nil_chk(val$buffer_)) getClass] getMethod:@"cleaner" parameterTypes:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    [((JavaLangReflectMethod *) nil_chk(getCleanerMethod)) setAccessibleWithBoolean:YES];
    id cleaner = [getCleanerMethod invokeWithId:val$buffer_ withNSObjectArray:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    JavaLangReflectMethod *clean = [[nil_chk(cleaner) getClass] getMethod:@"clean" parameterTypes:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    (void) [((JavaLangReflectMethod *) nil_chk(clean)) invokeWithId:cleaner withNSObjectArray:(IOSObjectArray *) check_class_cast(nil, [IOSObjectArray class])];
    success = JavaLangBoolean_get_TRUE__();
  }
  @catch (
#line 266
  JavaLangException *e) {
  }
  
#line 270
  return success;
}

- (instancetype)initWithJavaNioByteBuffer:(JavaNioByteBuffer *)capture$0 {
  val$buffer_ = capture$0;
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "run", NULL, "Ljava.lang.Boolean;", 0x1, NULL },
    { "initWithJavaNioByteBuffer:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$buffer_", NULL, 0x1012, "Ljava.nio.ByteBuffer;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfMappedRandomAccessFile_$1 = { "$1", "com.itextpdf.text.pdf", "MappedRandomAccessFile", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_ComItextpdfTextPdfMappedRandomAccessFile_$1;
}

@end

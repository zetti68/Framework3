//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/FontSelector.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/FontSelector.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/BaseColor.h"
#include "com/itextpdf/text/Chunk.h"
#include "com/itextpdf/text/Font.h"
#include "com/itextpdf/text/Phrase.h"
#include "com/itextpdf/text/Utilities.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/pdf/BaseFont.h"
#include "com/itextpdf/text/pdf/FontSelector.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/StringBuffer.h"
#include "java/util/ArrayList.h"


#line 63
@implementation ComItextpdfTextPdfFontSelector


#line 72
- (void)addFontWithComItextpdfTextFont:(ComItextpdfTextFont *)font {
  
#line 73
  if ([((ComItextpdfTextFont *) nil_chk(font)) getBaseFont] != nil) {
    [((JavaUtilArrayList *) nil_chk(fonts_)) addWithId:font];
    return;
  }
  ComItextpdfTextPdfBaseFont *bf = [font getCalculatedBaseFontWithBoolean:YES];
  ComItextpdfTextFont *f2 = [[ComItextpdfTextFont alloc] initWithComItextpdfTextPdfBaseFont:bf withFloat:[font getSize] withInt:[font getCalculatedStyle] withComItextpdfTextBaseColor:[font getColor]];
  [((JavaUtilArrayList *) nil_chk(fonts_)) addWithId:f2];
}


#line 88
- (ComItextpdfTextPhrase *)processWithNSString:(NSString *)text {
  
#line 89
  if ([((JavaUtilArrayList *) nil_chk(fonts_)) size] == 0)
#line 90
  @throw [[JavaLangIndexOutOfBoundsException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"no.font.is.defined" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  IOSCharArray *cc = [((NSString *) nil_chk(text)) toCharArray];
  jint len = ((IOSCharArray *) nil_chk(cc))->size_;
  JavaLangStringBuffer *sb = [[JavaLangStringBuffer alloc] init];
  ComItextpdfTextPhrase *ret = [[ComItextpdfTextPhrase alloc] init];
  currentFont_ = nil;
  for (jint k = 0; k < len; ++k) {
    ComItextpdfTextChunk *newChunk = [self processCharWithCharArray:cc withInt:k withJavaLangStringBuffer:sb];
    if (newChunk != nil) {
      [ret addWithId:newChunk];
    }
  }
  if ([sb sequenceLength] > 0) {
    ComItextpdfTextChunk *ck = [[ComItextpdfTextChunk alloc] initWithNSString:[sb description] withComItextpdfTextFont:currentFont_ != nil ? currentFont_ : [fonts_ getWithInt:0]];
    [ret addWithId:ck];
  }
  return ret;
}


#line 109
- (ComItextpdfTextChunk *)processCharWithCharArray:(IOSCharArray *)cc
                                           withInt:(jint)k
                          withJavaLangStringBuffer:(JavaLangStringBuffer *)sb {
  
#line 110
  ComItextpdfTextChunk *newChunk = nil;
  jchar c = IOSCharArray_Get(nil_chk(cc), k);
  if (c == 0x000a || c == 0x000d) {
    (void) [((JavaLangStringBuffer *) nil_chk(sb)) appendWithChar:c];
  }
  else {
    
#line 115
    ComItextpdfTextFont *font = nil;
    if ([ComItextpdfTextUtilities isSurrogatePairWithCharArray:cc withInt:k]) {
      jint u = [ComItextpdfTextUtilities convertToUtf32WithCharArray:cc withInt:k];
      for (jint f = 0; f < [((JavaUtilArrayList *) nil_chk(fonts_)) size]; ++f) {
        font = [fonts_ getWithInt:f];
        if ([((ComItextpdfTextPdfBaseFont *) nil_chk([((ComItextpdfTextFont *) nil_chk(font)) getBaseFont])) charExistsWithInt:u]) {
          if (currentFont_ != font) {
            if ([((JavaLangStringBuffer *) nil_chk(sb)) sequenceLength] > 0 && currentFont_ != nil) {
              newChunk = [[ComItextpdfTextChunk alloc] initWithNSString:[sb description] withComItextpdfTextFont:currentFont_];
              [sb setLengthWithInt:0];
            }
            currentFont_ = font;
          }
          (void) [((JavaLangStringBuffer *) nil_chk(sb)) appendWithChar:c];
          (void) [sb appendWithChar:IOSCharArray_Get(cc, ++k)];
          break;
        }
      }
    }
    else {
      
#line 134
      for (jint f = 0; f < [((JavaUtilArrayList *) nil_chk(fonts_)) size]; ++f) {
        font = [fonts_ getWithInt:f];
        if ([((ComItextpdfTextPdfBaseFont *) nil_chk([((ComItextpdfTextFont *) nil_chk(font)) getBaseFont])) charExistsWithInt:c]) {
          if (currentFont_ != font) {
            if ([((JavaLangStringBuffer *) nil_chk(sb)) sequenceLength] > 0 && currentFont_ != nil) {
              newChunk = [[ComItextpdfTextChunk alloc] initWithNSString:[sb description] withComItextpdfTextFont:currentFont_];
              [sb setLengthWithInt:0];
            }
            currentFont_ = font;
          }
          (void) [((JavaLangStringBuffer *) nil_chk(sb)) appendWithChar:c];
          break;
        }
      }
    }
  }
  return newChunk;
}

- (instancetype)init {
  if (self = [super init]) {
    fonts_ =
#line 65
    [[JavaUtilArrayList alloc] init];
    currentFont_ =
#line 66
    nil;
  }
  return self;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfFontSelector *)other {
  [super copyAllFieldsTo:other];
  other->currentFont_ = currentFont_;
  other->fonts_ = fonts_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "addFontWithComItextpdfTextFont:", "addFont", "V", 0x1, NULL },
    { "processWithNSString:", "process", "Lcom.itextpdf.text.Phrase;", 0x1, NULL },
    { "processCharWithCharArray:withInt:withJavaLangStringBuffer:", "processChar", "Lcom.itextpdf.text.Chunk;", 0x4, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "fonts_", NULL, 0x4, "Ljava.util.ArrayList;", NULL,  },
    { "currentFont_", NULL, 0x4, "Lcom.itextpdf.text.Font;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfFontSelector = { "FontSelector", "com.itextpdf.text.pdf", NULL, 0x1, 4, methods, 2, fields, 0, NULL};
  return &_ComItextpdfTextPdfFontSelector;
}

@end

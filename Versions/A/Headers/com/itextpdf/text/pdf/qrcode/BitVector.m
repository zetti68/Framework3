//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/qrcode/BitVector.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/qrcode/BitVector.java"

#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/pdf/qrcode/BitVector.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/System.h"


#line 28
@implementation ComItextpdfTextPdfQrcodeBitVector


#line 36
- (instancetype)init {
  if (self = [super init]) {
    
#line 37
    sizeInBits_ = 0;
    
#line 38
    array_ = [IOSByteArray arrayWithLength:ComItextpdfTextPdfQrcodeBitVector_DEFAULT_SIZE_IN_BYTES];
  }
  return self;
}


#line 42
- (jint)atWithInt:(jint)index {
  
#line 43
  if (index < 0 || index >= sizeInBits_) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$I", @"Bad index: ", index)];
  }
  jint value = IOSByteArray_Get(nil_chk(array_), RShift32(index, 3)) & (jint) 0xff;
  return (RShift32(value, (7 - (index & (jint) 0x7)))) & 1;
}


#line 51
- (jint)size {
  return sizeInBits_;
}


#line 56
- (jint)sizeInBytes {
  
#line 57
  return RShift32((sizeInBits_ + 7), 3);
}


#line 61
- (void)appendBitWithInt:(jint)bit {
  if (!(bit == 0 || bit == 1)) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Bad bit"];
  }
  jint numBitsInLastByte = sizeInBits_ & (jint) 0x7;
  
#line 67
  if (numBitsInLastByte == 0) {
    [self appendByteWithInt:0];
    sizeInBits_ -= 8;
  }
  
#line 72
  *IOSByteArray_GetRef(nil_chk(array_), RShift32(sizeInBits_, 3)) |= (LShift32(bit, (7 - numBitsInLastByte)));
  ++sizeInBits_;
}


#line 83
- (void)appendBitsWithInt:(jint)value
                  withInt:(jint)numBits {
  
#line 84
  if (numBits < 0 || numBits > 32) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Num bits must be between 0 and 32"];
  }
  jint numBitsLeft = numBits;
  while (numBitsLeft > 0) {
    
#line 90
    if ((sizeInBits_ & (jint) 0x7) == 0 && numBitsLeft >= 8) {
      jint newByte = (RShift32(value, (numBitsLeft - 8))) & (jint) 0xff;
      [self appendByteWithInt:newByte];
      numBitsLeft -= 8;
    }
    else {
      
#line 95
      jint bit = (RShift32(value, (numBitsLeft - 1))) & 1;
      [self appendBitWithInt:bit];
      --numBitsLeft;
    }
  }
}


#line 103
- (void)appendBitVectorWithComItextpdfTextPdfQrcodeBitVector:(ComItextpdfTextPdfQrcodeBitVector *)bits {
  
#line 104
  jint size = [((ComItextpdfTextPdfQrcodeBitVector *) nil_chk(bits)) size];
  for (jint i = 0; i < size; ++i) {
    [self appendBitWithInt:[bits atWithInt:i]];
  }
}


#line 111
- (void)xor__WithComItextpdfTextPdfQrcodeBitVector:(ComItextpdfTextPdfQrcodeBitVector *)other {
  if (sizeInBits_ != [((ComItextpdfTextPdfQrcodeBitVector *) nil_chk(other)) size]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"BitVector sizes don't match"];
  }
  jint sizeInBytes = RShift32((sizeInBits_ + 7), 3);
  for (jint i = 0; i < sizeInBytes; ++i) {
    
#line 119
    *IOSByteArray_GetRef(nil_chk(array_), i) ^= IOSByteArray_Get(other->array_, i);
  }
}

- (NSString *)description {
  
#line 125
  JavaLangStringBuffer *result = [[JavaLangStringBuffer alloc] initWithInt:sizeInBits_];
  for (jint i = 0; i < sizeInBits_; ++i) {
    if ([self atWithInt:i] == 0) {
      (void) [result appendWithChar:'0'];
    }
    else
#line 129
    if ([self atWithInt:i] == 1) {
      (void) [result appendWithChar:'1'];
    }
    else {
      
#line 132
      @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Byte isn't 0 or 1"];
    }
  }
  return [result description];
}


#line 140
- (IOSByteArray *)getArray {
  
#line 141
  return array_;
}

- (void)appendByteWithInt:(jint)value {
  
#line 147
  if ((RShift32(sizeInBits_, 3)) == ((IOSByteArray *) nil_chk(array_))->size_) {
    IOSByteArray *newArray = [IOSByteArray arrayWithLength:(LShift32(array_->size_, 1))];
    [JavaLangSystem arraycopyWithId:array_ withInt:0 withId:newArray withInt:0 withInt:array_->size_];
    array_ = newArray;
  }
  *IOSByteArray_GetRef(array_, RShift32(sizeInBits_, 3)) = (jbyte) value;
  sizeInBits_ += 8;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfQrcodeBitVector *)other {
  [super copyAllFieldsTo:other];
  other->array_ = array_;
  other->sizeInBits_ = sizeInBits_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "BitVector", NULL, 0x1, NULL },
    { "atWithInt:", "at", "I", 0x1, NULL },
    { "size", NULL, "I", 0x1, NULL },
    { "sizeInBytes", NULL, "I", 0x1, NULL },
    { "appendBitWithInt:", "appendBit", "V", 0x1, NULL },
    { "appendBitsWithInt:withInt:", "appendBits", "V", 0x1, NULL },
    { "appendBitVectorWithComItextpdfTextPdfQrcodeBitVector:", "appendBitVector", "V", 0x1, NULL },
    { "xor__WithComItextpdfTextPdfQrcodeBitVector:", "xor", "V", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "getArray", NULL, "[B", 0x1, NULL },
    { "appendByteWithInt:", "appendByte", "V", 0x2, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "sizeInBits_", NULL, 0x2, "I", NULL,  },
    { "array_", NULL, 0x2, "[B", NULL,  },
    { "DEFAULT_SIZE_IN_BYTES_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfTextPdfQrcodeBitVector_DEFAULT_SIZE_IN_BYTES },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfQrcodeBitVector = { "BitVector", "com.itextpdf.text.pdf.qrcode", NULL, 0x11, 11, methods, 3, fields, 0, NULL};
  return &_ComItextpdfTextPdfQrcodeBitVector;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/PdfEFStream.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/PdfEFStream.java"

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/pdf/OutputStreamCounter.h"
#include "com/itextpdf/text/pdf/OutputStreamEncryption.h"
#include "com/itextpdf/text/pdf/PdfArray.h"
#include "com/itextpdf/text/pdf/PdfDictionary.h"
#include "com/itextpdf/text/pdf/PdfEFStream.h"
#include "com/itextpdf/text/pdf/PdfEncryption.h"
#include "com/itextpdf/text/pdf/PdfName.h"
#include "com/itextpdf/text/pdf/PdfNull.h"
#include "com/itextpdf/text/pdf/PdfNumber.h"
#include "com/itextpdf/text/pdf/PdfObject.h"
#include "com/itextpdf/text/pdf/PdfStream.h"
#include "com/itextpdf/text/pdf/PdfWriter.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/util/zip/Deflater.h"
#include "java/util/zip/DeflaterOutputStream.h"


#line 59
@implementation ComItextpdfTextPdfPdfEFStream


#line 66
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
          withComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer {
  return
#line 67
  [super initWithJavaIoInputStream:inArg withComItextpdfTextPdfPdfWriter:writer];
}


#line 74
- (instancetype)initWithByteArray:(IOSByteArray *)fileStore {
  return
#line 75
  [super initWithByteArray:fileStore];
}


#line 81
- (void)toPdfWithComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer
                      withJavaIoOutputStream:(JavaIoOutputStream *)os {
  
#line 82
  if (inputStream_ != nil && compressed_)
#line 83
  [self putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_FILTER_() withComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfName_get_FLATEDECODE_()];
  ComItextpdfTextPdfPdfEncryption *crypto = nil;
  if (writer != nil)
#line 86
  crypto = [writer getEncryption];
  if (crypto != nil) {
    ComItextpdfTextPdfPdfObject *filter = [self getWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_FILTER_()];
    if (filter != nil) {
      if ([((ComItextpdfTextPdfPdfName *) nil_chk(ComItextpdfTextPdfPdfName_get_CRYPT_())) isEqual:filter])
#line 91
      crypto = nil;
      else if ([filter isArray]) {
        ComItextpdfTextPdfPdfArray *a = (ComItextpdfTextPdfPdfArray *) check_class_cast(filter, [ComItextpdfTextPdfPdfArray class]);
        if (![a isEmpty] && [ComItextpdfTextPdfPdfName_get_CRYPT_() isEqual:[a getPdfObjectWithInt:0]])
#line 95
        crypto = nil;
      }
    }
  }
  if (crypto != nil && [crypto isEmbeddedFilesOnly]) {
    ComItextpdfTextPdfPdfArray *filter = [[ComItextpdfTextPdfPdfArray alloc] init];
    ComItextpdfTextPdfPdfArray *decodeparms = [[ComItextpdfTextPdfPdfArray alloc] init];
    ComItextpdfTextPdfPdfDictionary *crypt = [[ComItextpdfTextPdfPdfDictionary alloc] init];
    [crypt putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_NAME_() withComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfName_get_STDCF_()];
    [filter addWithComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfName_get_CRYPT_()];
    [decodeparms addWithComItextpdfTextPdfPdfObject:crypt];
    if (compressed_) {
      [filter addWithComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfName_get_FLATEDECODE_()];
      [decodeparms addWithComItextpdfTextPdfPdfObject:[[ComItextpdfTextPdfPdfNull alloc] init]];
    }
    [self putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_FILTER_() withComItextpdfTextPdfPdfObject:filter];
    [self putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_DECODEPARMS_() withComItextpdfTextPdfPdfObject:decodeparms];
  }
  ComItextpdfTextPdfPdfObject *nn = [self getWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_LENGTH_()];
  if (crypto != nil && nn != nil && [nn isNumber]) {
    jint sz = [((ComItextpdfTextPdfPdfNumber *) check_class_cast(nn, [ComItextpdfTextPdfPdfNumber class])) intValue];
    [self putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_LENGTH_() withComItextpdfTextPdfPdfObject:[[ComItextpdfTextPdfPdfNumber alloc] initWithInt:[crypto calculateStreamSizeWithInt:sz]]];
    [self superToPdfWithComItextpdfTextPdfPdfWriter:writer withJavaIoOutputStream:os];
    [self putWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_LENGTH_() withComItextpdfTextPdfPdfObject:nn];
  }
  else
#line 121
  [self superToPdfWithComItextpdfTextPdfPdfWriter:writer withJavaIoOutputStream:os];
  
#line 123
  [((JavaIoOutputStream *) nil_chk(os)) writeWithByteArray:ComItextpdfTextPdfPdfStream_get_STARTSTREAM_()];
  if (inputStream_ != nil) {
    rawLength_ = 0;
    JavaUtilZipDeflaterOutputStream *def = nil;
    ComItextpdfTextPdfOutputStreamCounter *osc = [[ComItextpdfTextPdfOutputStreamCounter alloc] initWithJavaIoOutputStream:os];
    ComItextpdfTextPdfOutputStreamEncryption *ose = nil;
    JavaIoOutputStream *fout = osc;
    if (crypto != nil)
#line 131
    fout = ose = [crypto getEncryptionStreamWithJavaIoOutputStream:fout];
    JavaUtilZipDeflater *deflater = nil;
    if (compressed_) {
      deflater = [[JavaUtilZipDeflater alloc] initWithInt:compressionLevel_];
      fout = def = [[JavaUtilZipDeflaterOutputStream alloc] initWithJavaIoOutputStream:fout withJavaUtilZipDeflater:deflater withInt:(jint) 0x8000];
    }
    
#line 138
    IOSByteArray *buf = [IOSByteArray arrayWithLength:4192];
    while (YES) {
      jint n = [inputStream_ readWithByteArray:buf];
      if (n <= 0)
#line 142
      break;
      [fout writeWithByteArray:buf withInt:0 withInt:n];
      rawLength_ += n;
    }
    if (def != nil) {
      [def finish];
      [((JavaUtilZipDeflater *) nil_chk(deflater)) end];
    }
    if (ose != nil)
#line 151
    [ose finish];
    inputStreamLength_ = (jint) [osc getCounter];
  }
  else {
    if (crypto == nil) {
      if (streamBytes_ != nil)
#line 157
      [streamBytes_ writeToWithJavaIoOutputStream:os];
      else
#line 159
      [os writeWithByteArray:bytes_];
    }
    else {
      IOSByteArray *b;
      if (streamBytes_ != nil) {
        b = [crypto encryptByteArrayWithByteArray:[streamBytes_ toByteArray]];
      }
      else {
        b = [crypto encryptByteArrayWithByteArray:bytes_];
      }
      [os writeWithByteArray:b];
    }
  }
  [os writeWithByteArray:ComItextpdfTextPdfPdfStream_get_ENDSTREAM_()];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithJavaIoInputStream:withComItextpdfTextPdfPdfWriter:", "PdfEFStream", NULL, 0x1, NULL },
    { "initWithByteArray:", "PdfEFStream", NULL, 0x1, NULL },
    { "toPdfWithComItextpdfTextPdfPdfWriter:withJavaIoOutputStream:", "toPdf", "V", 0x1, "Ljava.io.IOException;" },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfPdfEFStream = { "PdfEFStream", "com.itextpdf.text.pdf", NULL, 0x1, 3, methods, 0, NULL, 0, NULL};
  return &_ComItextpdfTextPdfPdfEFStream;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/PdfSmartCopy.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/PdfSmartCopy.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/Document.h"
#include "com/itextpdf/text/DocumentException.h"
#include "com/itextpdf/text/ExceptionConverter.h"
#include "com/itextpdf/text/log/Counter.h"
#include "com/itextpdf/text/log/CounterFactory.h"
#include "com/itextpdf/text/pdf/BadPdfFormatException.h"
#include "com/itextpdf/text/pdf/ByteBuffer.h"
#include "com/itextpdf/text/pdf/PRIndirectReference.h"
#include "com/itextpdf/text/pdf/PRStream.h"
#include "com/itextpdf/text/pdf/PdfArray.h"
#include "com/itextpdf/text/pdf/PdfCopy.h"
#include "com/itextpdf/text/pdf/PdfDictionary.h"
#include "com/itextpdf/text/pdf/PdfImportedPage.h"
#include "com/itextpdf/text/pdf/PdfIndirectObject.h"
#include "com/itextpdf/text/pdf/PdfIndirectReference.h"
#include "com/itextpdf/text/pdf/PdfName.h"
#include "com/itextpdf/text/pdf/PdfObject.h"
#include "com/itextpdf/text/pdf/PdfReader.h"
#include "com/itextpdf/text/pdf/PdfReaderInstance.h"
#include "com/itextpdf/text/pdf/PdfSmartCopy.h"
#include "com/itextpdf/text/pdf/PdfWriter.h"
#include "com/itextpdf/text/pdf/RefKey.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/security/MessageDigest.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/Set.h"


#line 68
@implementation ComItextpdfTextPdfPdfSmartCopy


#line 75
- (id<ComItextpdfTextLogCounter>)getCounter {
  
#line 76
  return COUNTER_;
}


#line 80
- (instancetype)initWithComItextpdfTextDocument:(ComItextpdfTextDocument *)document
                         withJavaIoOutputStream:(JavaIoOutputStream *)os {
  if (self =
#line 81
  [super initWithComItextpdfTextDocument:document withJavaIoOutputStream:os]) {
    streamMap_ =
#line 71
    nil;
    serialized_ =
#line 72
    [[JavaUtilHashMap alloc] init];
    COUNTER_ =
#line 74
    [ComItextpdfTextLogCounterFactory getCounterWithIOSClass:[IOSClass classWithClass:[ComItextpdfTextPdfPdfSmartCopy class]]];
    
#line 82
    self->streamMap_ = [[JavaUtilHashMap alloc] init];
  }
  return self;
}


#line 97
- (ComItextpdfTextPdfPdfIndirectReference *)copyIndirectWithComItextpdfTextPdfPRIndirectReference:(ComItextpdfTextPdfPRIndirectReference *)inArg {
  
#line 98
  ComItextpdfTextPdfPdfObject *srcObj = [ComItextpdfTextPdfPdfReader getPdfObjectReleaseWithComItextpdfTextPdfPdfObject:inArg];
  ComItextpdfTextPdfPdfSmartCopy_ByteStore *streamKey = nil;
  jboolean validStream = NO;
  if ([((ComItextpdfTextPdfPdfObject *) nil_chk(srcObj)) isStream]) {
    streamKey = [[ComItextpdfTextPdfPdfSmartCopy_ByteStore alloc] initWithComItextpdfTextPdfPRStream:(ComItextpdfTextPdfPRStream *) check_class_cast(srcObj, [ComItextpdfTextPdfPRStream class]) withJavaUtilHashMap:serialized_];
    validStream = YES;
    ComItextpdfTextPdfPdfIndirectReference *streamRef = [((JavaUtilHashMap *) nil_chk(streamMap_)) getWithId:streamKey];
    if (streamRef != nil) {
      return streamRef;
    }
  }
  else if ([srcObj isDictionary]) {
    streamKey = [[ComItextpdfTextPdfPdfSmartCopy_ByteStore alloc] initWithComItextpdfTextPdfPdfDictionary:(ComItextpdfTextPdfPdfDictionary *) check_class_cast(srcObj, [ComItextpdfTextPdfPdfDictionary class]) withJavaUtilHashMap:serialized_];
    validStream = YES;
    ComItextpdfTextPdfPdfIndirectReference *streamRef = [((JavaUtilHashMap *) nil_chk(streamMap_)) getWithId:streamKey];
    if (streamRef != nil) {
      return streamRef;
    }
  }
  
#line 118
  ComItextpdfTextPdfPdfIndirectReference *theRef;
  ComItextpdfTextPdfRefKey *key = [[ComItextpdfTextPdfRefKey alloc] initWithComItextpdfTextPdfPRIndirectReference:inArg];
  ComItextpdfTextPdfPdfCopy_IndirectReferences *iRef = [((JavaUtilHashMap *) nil_chk(indirects_)) getWithId:key];
  if (iRef != nil) {
    theRef = [iRef getRef];
    if ([iRef getCopied]) {
      return theRef;
    }
  }
  else {
    
#line 127
    theRef = [((ComItextpdfTextPdfPdfWriter_PdfBody *) nil_chk(body_)) getPdfIndirectReference];
    iRef = [[ComItextpdfTextPdfPdfCopy_IndirectReferences alloc] initWithComItextpdfTextPdfPdfIndirectReference:theRef];
    (void) [indirects_ putWithId:key withId:iRef];
  }
  if ([srcObj isDictionary]) {
    ComItextpdfTextPdfPdfObject *type = [ComItextpdfTextPdfPdfReader getPdfObjectReleaseWithComItextpdfTextPdfPdfObject:[((ComItextpdfTextPdfPdfDictionary *) check_class_cast(srcObj, [ComItextpdfTextPdfPdfDictionary class])) getWithComItextpdfTextPdfPdfName:ComItextpdfTextPdfPdfName_get_TYPE_()]];
    if (type != nil && [((ComItextpdfTextPdfPdfName *) nil_chk(ComItextpdfTextPdfPdfName_get_PAGE_())) isEqual:type]) {
      return theRef;
    }
  }
  [((ComItextpdfTextPdfPdfCopy_IndirectReferences *) nil_chk(iRef)) setCopied];
  
#line 139
  if (validStream) {
    (void) [((JavaUtilHashMap *) nil_chk(streamMap_)) putWithId:streamKey withId:theRef];
  }
  
#line 143
  ComItextpdfTextPdfPdfObject *obj = [self copyObjectWithComItextpdfTextPdfPdfObject:srcObj];
  (void) [self addToBodyWithComItextpdfTextPdfPdfObject:obj withComItextpdfTextPdfPdfIndirectReference:theRef];
  return theRef;
}


#line 149
- (void)freeReaderWithComItextpdfTextPdfPdfReader:(ComItextpdfTextPdfPdfReader *)reader {
  
#line 150
  [((JavaUtilHashMap *) nil_chk(serialized_)) clear];
  [super freeReaderWithComItextpdfTextPdfPdfReader:reader];
}


#line 155
- (void)addPageWithComItextpdfTextPdfPdfImportedPage:(ComItextpdfTextPdfPdfImportedPage *)iPage {
  if ([((ComItextpdfTextPdfPdfReaderInstance *) nil_chk(currentPdfReaderInstance_)) getReader] != reader_)
#line 157
  [((JavaUtilHashMap *) nil_chk(serialized_)) clear];
  [super addPageWithComItextpdfTextPdfPdfImportedPage:iPage];
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfPdfSmartCopy *)other {
  [super copyAllFieldsTo:other];
  other->COUNTER_ = COUNTER_;
  other->serialized_ = serialized_;
  other->streamMap_ = streamMap_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getCounter", NULL, "Lcom.itextpdf.text.log.Counter;", 0x4, NULL },
    { "initWithComItextpdfTextDocument:withJavaIoOutputStream:", "PdfSmartCopy", NULL, 0x1, "Lcom.itextpdf.text.DocumentException;" },
    { "copyIndirectWithComItextpdfTextPdfPRIndirectReference:", "copyIndirect", "Lcom.itextpdf.text.pdf.PdfIndirectReference;", 0x4, "Ljava.io.IOException;Lcom.itextpdf.text.pdf.BadPdfFormatException;" },
    { "freeReaderWithComItextpdfTextPdfPdfReader:", "freeReader", "V", 0x1, "Ljava.io.IOException;" },
    { "addPageWithComItextpdfTextPdfPdfImportedPage:", "addPage", "V", 0x1, "Ljava.io.IOException;Lcom.itextpdf.text.pdf.BadPdfFormatException;" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "streamMap_", NULL, 0x2, "Ljava.util.HashMap;", NULL,  },
    { "serialized_", NULL, 0x12, "Ljava.util.HashMap;", NULL,  },
    { "COUNTER_", NULL, 0x4, "Lcom.itextpdf.text.log.Counter;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfPdfSmartCopy = { "PdfSmartCopy", "com.itextpdf.text.pdf", NULL, 0x1, 5, methods, 3, fields, 0, NULL};
  return &_ComItextpdfTextPdfPdfSmartCopy;
}

@end


#line 161
@implementation ComItextpdfTextPdfPdfSmartCopy_ByteStore


#line 166
- (void)serObjectWithComItextpdfTextPdfPdfObject:(ComItextpdfTextPdfPdfObject *)obj
                                         withInt:(jint)level
                withComItextpdfTextPdfByteBuffer:(ComItextpdfTextPdfByteBuffer *)bb
                             withJavaUtilHashMap:(JavaUtilHashMap *)serialized {
  
#line 167
  if (level <= 0)
#line 168
  return;
  if (obj == nil) {
    (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$Lnull"];
    return;
  }
  ComItextpdfTextPdfPdfIndirectReference *ref = nil;
  ComItextpdfTextPdfByteBuffer *savedBb = nil;
  
#line 176
  if ([((ComItextpdfTextPdfPdfObject *) nil_chk(obj)) isIndirect]) {
    ref = (ComItextpdfTextPdfPdfIndirectReference *) check_class_cast(obj, [ComItextpdfTextPdfPdfIndirectReference class]);
    ComItextpdfTextPdfRefKey *key = [[ComItextpdfTextPdfRefKey alloc] initWithComItextpdfTextPdfPdfIndirectReference:ref];
    if ([((JavaUtilHashMap *) nil_chk(serialized)) containsKeyWithId:key]) {
      (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithInt:[((JavaLangInteger *) nil_chk([serialized getWithId:key])) intValue]];
      return;
    }
    else {
      savedBb = bb;
      bb = [[ComItextpdfTextPdfByteBuffer alloc] init];
    }
  }
  obj = [ComItextpdfTextPdfPdfReader getPdfObjectWithComItextpdfTextPdfPdfObject:obj];
  if ([((ComItextpdfTextPdfPdfObject *) nil_chk(obj)) isStream]) {
    (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$B"];
    [self serDicWithComItextpdfTextPdfPdfDictionary:(ComItextpdfTextPdfPdfDictionary *) check_class_cast(obj, [ComItextpdfTextPdfPdfDictionary class]) withInt:level - 1 withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
    if (level > 0) {
      [((JavaSecurityMessageDigest *) nil_chk(md5_)) reset];
      (void) [bb appendWithByteArray:[md5_ digestWithByteArray:[ComItextpdfTextPdfPdfReader getStreamBytesRawWithComItextpdfTextPdfPRStream:(ComItextpdfTextPdfPRStream *) check_class_cast(obj, [ComItextpdfTextPdfPRStream class])]]];
    }
  }
  else if ([obj isDictionary]) {
    [self serDicWithComItextpdfTextPdfPdfDictionary:(ComItextpdfTextPdfPdfDictionary *) check_class_cast(obj, [ComItextpdfTextPdfPdfDictionary class]) withInt:level - 1 withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
  }
  else if ([obj isArray]) {
    [self serArrayWithComItextpdfTextPdfPdfArray:(ComItextpdfTextPdfPdfArray *) check_class_cast(obj, [ComItextpdfTextPdfPdfArray class]) withInt:level - 1 withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
  }
  else if ([obj isString]) {
    (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk([((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$S"])) appendWithNSString:[obj description]];
  }
  else if ([obj isName]) {
    (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk([((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$N"])) appendWithNSString:[obj description]];
  }
  else
#line 210
  (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk([((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$L"])) appendWithNSString:[obj description]];
  
#line 212
  if (savedBb != nil) {
    ComItextpdfTextPdfRefKey *key = [[ComItextpdfTextPdfRefKey alloc] initWithComItextpdfTextPdfPdfIndirectReference:ref];
    if (![((JavaUtilHashMap *) nil_chk(serialized)) containsKeyWithId:key])
#line 215
    (void) [serialized putWithId:key withId:[JavaLangInteger valueOfWithInt:[ComItextpdfTextPdfPdfSmartCopy_ByteStore calculateHashWithByteArray:[((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) getBuffer]]]];
    (void) [savedBb appendWithComItextpdfTextPdfByteBuffer:bb];
  }
}


#line 220
- (void)serDicWithComItextpdfTextPdfPdfDictionary:(ComItextpdfTextPdfPdfDictionary *)dic
                                          withInt:(jint)level
                 withComItextpdfTextPdfByteBuffer:(ComItextpdfTextPdfByteBuffer *)bb
                              withJavaUtilHashMap:(JavaUtilHashMap *)serialized {
  
#line 221
  (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$D"];
  if (level <= 0)
#line 223
  return;
  IOSObjectArray *keys = [((id<JavaUtilSet>) nil_chk([((ComItextpdfTextPdfPdfDictionary *) nil_chk(dic)) getKeys])) toArray];
  [JavaUtilArrays sortWithNSObjectArray:keys];
  for (jint k = 0; k < ((IOSObjectArray *) nil_chk(keys))->size_; ++k) {
    [self serObjectWithComItextpdfTextPdfPdfObject:(ComItextpdfTextPdfPdfObject *) check_class_cast(IOSObjectArray_Get(keys, k), [ComItextpdfTextPdfPdfObject class]) withInt:level withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
    [self serObjectWithComItextpdfTextPdfPdfObject:[dic getWithComItextpdfTextPdfPdfName:(ComItextpdfTextPdfPdfName *) check_class_cast(IOSObjectArray_Get(keys, k), [ComItextpdfTextPdfPdfName class])] withInt:level withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
  }
}


#line 232
- (void)serArrayWithComItextpdfTextPdfPdfArray:(ComItextpdfTextPdfPdfArray *)array
                                       withInt:(jint)level
              withComItextpdfTextPdfByteBuffer:(ComItextpdfTextPdfByteBuffer *)bb
                           withJavaUtilHashMap:(JavaUtilHashMap *)serialized {
  
#line 233
  (void) [((ComItextpdfTextPdfByteBuffer *) nil_chk(bb)) appendWithNSString:@"$A"];
  if (level <= 0)
#line 235
  return;
  for (jint k = 0; k < [((ComItextpdfTextPdfPdfArray *) nil_chk(array)) size]; ++k) {
    [self serObjectWithComItextpdfTextPdfPdfObject:[array getPdfObjectWithInt:k] withInt:level withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
  }
}


#line 241
- (instancetype)initWithComItextpdfTextPdfPRStream:(ComItextpdfTextPdfPRStream *)str
                               withJavaUtilHashMap:(JavaUtilHashMap *)serialized {
  if (self = [super init]) {
    
#line 242
    @try {
      md5_ = [JavaSecurityMessageDigest getInstanceWithNSString:@"MD5"];
    }
    @catch (JavaLangException *e) {
      @throw [[ComItextpdfTextExceptionConverter alloc] initWithJavaLangException:e];
    }
    
#line 248
    ComItextpdfTextPdfByteBuffer *bb = [[ComItextpdfTextPdfByteBuffer alloc] init];
    
#line 249
    jint level = 100;
    
#line 250
    [self serObjectWithComItextpdfTextPdfPdfObject:str withInt:level withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
    
#line 251
    self->b_ = [bb toByteArray];
    
#line 252
    hash__ = [ComItextpdfTextPdfPdfSmartCopy_ByteStore calculateHashWithByteArray:self->b_];
    
#line 253
    md5_ = nil;
  }
  return self;
}


#line 256
- (instancetype)initWithComItextpdfTextPdfPdfDictionary:(ComItextpdfTextPdfPdfDictionary *)dict
                                    withJavaUtilHashMap:(JavaUtilHashMap *)serialized {
  if (self = [super init]) {
    
#line 257
    @try {
      md5_ = [JavaSecurityMessageDigest getInstanceWithNSString:@"MD5"];
    }
    @catch (JavaLangException *e) {
      @throw [[ComItextpdfTextExceptionConverter alloc] initWithJavaLangException:e];
    }
    
#line 263
    ComItextpdfTextPdfByteBuffer *bb = [[ComItextpdfTextPdfByteBuffer alloc] init];
    
#line 264
    jint level = 100;
    
#line 265
    [self serObjectWithComItextpdfTextPdfPdfObject:dict withInt:level withComItextpdfTextPdfByteBuffer:bb withJavaUtilHashMap:serialized];
    
#line 266
    self->b_ = [bb toByteArray];
    
#line 267
    hash__ = [ComItextpdfTextPdfPdfSmartCopy_ByteStore calculateHashWithByteArray:self->b_];
    
#line 268
    md5_ = nil;
  }
  return self;
}


#line 271
+ (jint)calculateHashWithByteArray:(IOSByteArray *)b {
  
#line 272
  jint hash_ = 0;
  jint len = ((IOSByteArray *) nil_chk(b))->size_;
  for (jint k = 0; k < len; ++k)
#line 275
  hash_ = hash_ * 31 + (IOSByteArray_Get(b, k) & (jint) 0xff);
  return hash_;
}

- (jboolean)isEqual:(id)obj {
  
#line 281
  if (!([obj isKindOfClass:[ComItextpdfTextPdfPdfSmartCopy_ByteStore class]]))
#line 282
  return NO;
  if (((jint) [self hash]) != ((jint) [nil_chk(obj) hash]))
#line 284
  return NO;
  return [JavaUtilArrays equalsWithByteArray:b_ withByteArray:((ComItextpdfTextPdfPdfSmartCopy_ByteStore *) check_class_cast(obj, [ComItextpdfTextPdfPdfSmartCopy_ByteStore class]))->b_];
}

- (NSUInteger)hash {
  
#line 290
  return hash__;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfPdfSmartCopy_ByteStore *)other {
  [super copyAllFieldsTo:other];
  other->b_ = b_;
  other->hash__ = hash__;
  other->md5_ = md5_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "serObjectWithComItextpdfTextPdfPdfObject:withInt:withComItextpdfTextPdfByteBuffer:withJavaUtilHashMap:", "serObject", "V", 0x2, "Ljava.io.IOException;" },
    { "serDicWithComItextpdfTextPdfPdfDictionary:withInt:withComItextpdfTextPdfByteBuffer:withJavaUtilHashMap:", "serDic", "V", 0x2, "Ljava.io.IOException;" },
    { "serArrayWithComItextpdfTextPdfPdfArray:withInt:withComItextpdfTextPdfByteBuffer:withJavaUtilHashMap:", "serArray", "V", 0x2, "Ljava.io.IOException;" },
    { "initWithComItextpdfTextPdfPRStream:withJavaUtilHashMap:", "ByteStore", NULL, 0x0, "Ljava.io.IOException;" },
    { "initWithComItextpdfTextPdfPdfDictionary:withJavaUtilHashMap:", "ByteStore", NULL, 0x0, "Ljava.io.IOException;" },
    { "calculateHashWithByteArray:", "calculateHash", "I", 0xa, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "b_", NULL, 0x12, "[B", NULL,  },
    { "hash__", "hash", 0x12, "I", NULL,  },
    { "md5_", NULL, 0x2, "Ljava.security.MessageDigest;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfPdfSmartCopy_ByteStore = { "ByteStore", "com.itextpdf.text.pdf", "PdfSmartCopy", 0x8, 8, methods, 3, fields, 0, NULL};
  return &_ComItextpdfTextPdfPdfSmartCopy_ByteStore;
}

@end

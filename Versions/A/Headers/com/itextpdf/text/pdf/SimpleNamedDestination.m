//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/SimpleNamedDestination.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/SimpleNamedDestination.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/pdf/IntHashtable.h"
#include "com/itextpdf/text/pdf/PRIndirectReference.h"
#include "com/itextpdf/text/pdf/PdfArray.h"
#include "com/itextpdf/text/pdf/PdfDictionary.h"
#include "com/itextpdf/text/pdf/PdfIndirectObject.h"
#include "com/itextpdf/text/pdf/PdfIndirectReference.h"
#include "com/itextpdf/text/pdf/PdfName.h"
#include "com/itextpdf/text/pdf/PdfNameTree.h"
#include "com/itextpdf/text/pdf/PdfNull.h"
#include "com/itextpdf/text/pdf/PdfNumber.h"
#include "com/itextpdf/text/pdf/PdfObject.h"
#include "com/itextpdf/text/pdf/PdfReader.h"
#include "com/itextpdf/text/pdf/PdfWriter.h"
#include "com/itextpdf/text/pdf/SimpleNamedDestination.h"
#include "com/itextpdf/text/xml/XMLUtil.h"
#include "com/itextpdf/text/xml/simpleparser/IanaEncodings.h"
#include "com/itextpdf/text/xml/simpleparser/SimpleXMLParser.h"
#include "java/io/BufferedWriter.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/OutputStreamWriter.h"
#include "java/io/Reader.h"
#include "java/io/Writer.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuffer.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/StringTokenizer.h"


#line 68
@implementation ComItextpdfTextPdfSimpleNamedDestination


#line 73
- (instancetype)init {
  return [super init];
}


#line 76
+ (JavaUtilHashMap *)getNamedDestinationWithComItextpdfTextPdfPdfReader:(ComItextpdfTextPdfPdfReader *)reader
                                                            withBoolean:(jboolean)fromNames {
  ComItextpdfTextPdfIntHashtable *pages = [[ComItextpdfTextPdfIntHashtable alloc] init];
  jint numPages = [((ComItextpdfTextPdfPdfReader *) nil_chk(reader)) getNumberOfPages];
  for (jint k = 1; k <= numPages; ++k)
#line 80
  [pages putWithInt:[((ComItextpdfTextPdfPRIndirectReference *) nil_chk([reader getPageOrigRefWithInt:k])) getNumber] withInt:k];
  JavaUtilHashMap *names = fromNames ? [reader getNamedDestinationFromNames] : [reader getNamedDestinationFromStrings];
  JavaUtilHashMap *n2 = [[JavaUtilHashMap alloc] initWithInt:[names size]];
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([names entrySet])) {
    ComItextpdfTextPdfPdfArray *arr = (ComItextpdfTextPdfPdfArray *) check_class_cast([((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue], [ComItextpdfTextPdfPdfArray class]);
    JavaLangStringBuffer *s = [[JavaLangStringBuffer alloc] init];
    @try {
      (void) [s appendWithInt:[pages getWithInt:[((ComItextpdfTextPdfPdfIndirectReference *) nil_chk([((ComItextpdfTextPdfPdfArray *) nil_chk(arr)) getAsIndirectObjectWithInt:0])) getNumber]]];
      (void) [((JavaLangStringBuffer *) nil_chk([s appendWithChar:' '])) appendWithNSString:[((NSString *) nil_chk([((ComItextpdfTextPdfPdfObject *) nil_chk([arr getPdfObjectWithInt:1])) description])) substring:1]];
      for (jint k = 2; k < [arr size]; ++k)
#line 90
      (void) [((JavaLangStringBuffer *) nil_chk([s appendWithChar:' '])) appendWithNSString:[((ComItextpdfTextPdfPdfObject *) nil_chk([arr getPdfObjectWithInt:k])) description]];
      (void) [n2 putWithId:[entry_ getKey] withId:[s description]];
    }
    @catch (JavaLangException *e) {
    }
  }
  return n2;
}


#line 118
+ (void)exportToXMLWithJavaUtilHashMap:(JavaUtilHashMap *)names
                withJavaIoOutputStream:(JavaIoOutputStream *)outArg
                          withNSString:(NSString *)encoding
                           withBoolean:(jboolean)onlyASCII {
  
#line 119
  NSString *jenc = [ComItextpdfTextXmlSimpleparserIanaEncodings getJavaEncodingWithNSString:encoding];
  JavaIoWriter *wrt = [[JavaIoBufferedWriter alloc] initWithJavaIoWriter:[[JavaIoOutputStreamWriter alloc] initWithJavaIoOutputStream:outArg withNSString:jenc]];
  [ComItextpdfTextPdfSimpleNamedDestination exportToXMLWithJavaUtilHashMap:names withJavaIoWriter:wrt withNSString:encoding withBoolean:onlyASCII];
}


#line 134
+ (void)exportToXMLWithJavaUtilHashMap:(JavaUtilHashMap *)names
                      withJavaIoWriter:(JavaIoWriter *)wrt
                          withNSString:(NSString *)encoding
                           withBoolean:(jboolean)onlyASCII {
  
#line 135
  [((JavaIoWriter *) nil_chk(wrt)) writeWithNSString:@"<?xml version=\"1.0\" encoding=\""];
  [wrt writeWithNSString:[ComItextpdfTextXmlXMLUtil escapeXMLWithNSString:encoding withBoolean:onlyASCII]];
  [wrt writeWithNSString:@"\"?>\n<Destination>\n"];
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((JavaUtilHashMap *) nil_chk(names)) entrySet])) {
    NSString *key = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
    NSString *value = [entry_ getValue];
    [wrt writeWithNSString:@"  <Name Page=\""];
    [wrt writeWithNSString:[ComItextpdfTextXmlXMLUtil escapeXMLWithNSString:value withBoolean:onlyASCII]];
    [wrt writeWithNSString:@"\">"];
    [wrt writeWithNSString:[ComItextpdfTextXmlXMLUtil escapeXMLWithNSString:[ComItextpdfTextPdfSimpleNamedDestination escapeBinaryStringWithNSString:key] withBoolean:onlyASCII]];
    [wrt writeWithNSString:@"</Name>\n"];
  }
  [wrt writeWithNSString:@"</Destination>\n"];
  [wrt flush];
}


#line 157
+ (JavaUtilHashMap *)importFromXMLWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  
#line 158
  ComItextpdfTextPdfSimpleNamedDestination *names = [[ComItextpdfTextPdfSimpleNamedDestination alloc] init];
  [ComItextpdfTextXmlSimpleparserSimpleXMLParser parseWithComItextpdfTextXmlSimpleparserSimpleXMLDocHandler:names withJavaIoInputStream:inArg];
  return names->xmlNames_;
}


#line 169
+ (JavaUtilHashMap *)importFromXMLWithJavaIoReader:(JavaIoReader *)inArg {
  
#line 170
  ComItextpdfTextPdfSimpleNamedDestination *names = [[ComItextpdfTextPdfSimpleNamedDestination alloc] init];
  [ComItextpdfTextXmlSimpleparserSimpleXMLParser parseWithComItextpdfTextXmlSimpleparserSimpleXMLDocHandler:names withJavaIoReader:inArg];
  return names->xmlNames_;
}


#line 175
+ (ComItextpdfTextPdfPdfArray *)createDestinationArrayWithNSString:(NSString *)value
                                   withComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer {
  
#line 176
  ComItextpdfTextPdfPdfArray *ar = [[ComItextpdfTextPdfPdfArray alloc] init];
  JavaUtilStringTokenizer *tk = [[JavaUtilStringTokenizer alloc] initWithNSString:value];
  jint n = [JavaLangInteger parseIntWithNSString:[tk nextToken]];
  [ar addWithComItextpdfTextPdfPdfObject:[((ComItextpdfTextPdfPdfWriter *) nil_chk(writer)) getPageReferenceWithInt:n]];
  if (![tk hasMoreTokens]) {
    [ar addWithComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfName_get_XYZ_()];
    [ar addWithFloatArray:[IOSFloatArray arrayWithFloats:(jfloat[]){ 0, 10000, 0 } count:3]];
  }
  else {
    NSString *fn = [tk nextToken];
    if ([((NSString *) nil_chk(fn)) hasPrefix:@"/"])
#line 187
    fn = [fn substring:1];
    [ar addWithComItextpdfTextPdfPdfObject:[[ComItextpdfTextPdfPdfName alloc] initWithNSString:fn]];
    for (jint k = 0; k < 4 && [tk hasMoreTokens]; ++k) {
      fn = [tk nextToken];
      if ([((NSString *) nil_chk(fn)) isEqual:@"null"])
#line 192
      [ar addWithComItextpdfTextPdfPdfObject:ComItextpdfTextPdfPdfNull_get_PDFNULL_()];
      else
#line 194
      [ar addWithComItextpdfTextPdfPdfObject:[[ComItextpdfTextPdfPdfNumber alloc] initWithNSString:fn]];
    }
  }
  return ar;
}


#line 200
+ (ComItextpdfTextPdfPdfDictionary *)outputNamedDestinationAsNamesWithJavaUtilHashMap:(JavaUtilHashMap *)names
                                                      withComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer {
  
#line 201
  ComItextpdfTextPdfPdfDictionary *dic = [[ComItextpdfTextPdfPdfDictionary alloc] init];
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((JavaUtilHashMap *) nil_chk(names)) entrySet])) {
    @try {
      NSString *key = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
      NSString *value = [entry_ getValue];
      ComItextpdfTextPdfPdfArray *ar = [ComItextpdfTextPdfSimpleNamedDestination createDestinationArrayWithNSString:value withComItextpdfTextPdfPdfWriter:writer];
      ComItextpdfTextPdfPdfName *kn = [[ComItextpdfTextPdfPdfName alloc] initWithNSString:key];
      [dic putWithComItextpdfTextPdfPdfName:kn withComItextpdfTextPdfPdfObject:ar];
    }
    @catch (JavaLangException *e) {
    }
  }
  
#line 214
  return dic;
}


#line 217
+ (ComItextpdfTextPdfPdfDictionary *)outputNamedDestinationAsStringsWithJavaUtilHashMap:(JavaUtilHashMap *)names
                                                        withComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer {
  
#line 218
  JavaUtilHashMap *n2 = [[JavaUtilHashMap alloc] initWithInt:[((JavaUtilHashMap *) nil_chk(names)) size]];
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([names entrySet])) {
    @try {
      NSString *value = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
      ComItextpdfTextPdfPdfArray *ar = [ComItextpdfTextPdfSimpleNamedDestination createDestinationArrayWithNSString:value withComItextpdfTextPdfPdfWriter:writer];
      (void) [n2 putWithId:[entry_ getKey] withId:[((ComItextpdfTextPdfPdfIndirectObject *) nil_chk([((ComItextpdfTextPdfPdfWriter *) nil_chk(writer)) addToBodyWithComItextpdfTextPdfPdfObject:ar])) getIndirectReference]];
    }
    @catch (JavaLangException *e) {
    }
  }
  return [ComItextpdfTextPdfPdfNameTree writeTreeWithJavaUtilHashMap:n2 withComItextpdfTextPdfPdfWriter:writer];
}


#line 231
+ (NSString *)escapeBinaryStringWithNSString:(NSString *)s {
  
#line 232
  JavaLangStringBuffer *buf = [[JavaLangStringBuffer alloc] init];
  IOSCharArray *cc = [((NSString *) nil_chk(s)) toCharArray];
  jint len = ((IOSCharArray *) nil_chk(cc))->size_;
  for (jint k = 0; k < len; ++k) {
    jchar c = IOSCharArray_Get(cc, k);
    if (c < ' ') {
      (void) [buf appendWithChar:'\\'];
      NSString *octal = JreStrcat("$$", @"00", [JavaLangInteger toOctalStringWithInt:c]);
      (void) [buf appendWithNSString:[octal substring:((jint) [octal length]) - 3]];
    }
    else if (c == '\\')
#line 243
    (void) [buf appendWithNSString:@"\\\\"];
    else
#line 245
    (void) [buf appendWithChar:c];
  }
  return [buf description];
}


#line 250
+ (NSString *)unEscapeBinaryStringWithNSString:(NSString *)s {
  
#line 251
  JavaLangStringBuffer *buf = [[JavaLangStringBuffer alloc] init];
  IOSCharArray *cc = [((NSString *) nil_chk(s)) toCharArray];
  jint len = ((IOSCharArray *) nil_chk(cc))->size_;
  for (jint k = 0; k < len; ++k) {
    jchar c = IOSCharArray_Get(cc, k);
    if (c == '\\') {
      if (++k >= len) {
        (void) [buf appendWithChar:'\\'];
        break;
      }
      c = IOSCharArray_Get(cc, k);
      if (c >= '0' && c <= '7') {
        jint n = c - '0';
        ++k;
        for (jint j = 0; j < 2 && k < len; ++j) {
          c = IOSCharArray_Get(cc, k);
          if (c >= '0' && c <= '7') {
            ++k;
            n = n * 8 + c - '0';
          }
          else {
            break;
          }
        }
        --k;
        (void) [buf appendWithChar:(jchar) n];
      }
      else
#line 279
      (void) [buf appendWithChar:c];
    }
    else
#line 282
    (void) [buf appendWithChar:c];
  }
  return [buf description];
}


#line 287
- (void)endDocument {
}

- (void)endElementWithNSString:(NSString *)tag {
  
#line 291
  if ([((NSString *) nil_chk(tag)) isEqual:@"Destination"]) {
    if (xmlLast_ == nil && xmlNames_ != nil)
#line 293
    return;
    else
#line 295
    @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"destination.end.tag.out.of.place" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  if (![tag isEqual:@"Name"])
#line 298
  @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"invalid.end.tag.1" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ tag } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
  if (xmlLast_ == nil || xmlNames_ == nil)
#line 300
  @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"name.end.tag.out.of.place" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  if (![((JavaUtilHashMap *) nil_chk(xmlLast_)) containsKeyWithId:@"Page"])
#line 302
  @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"page.attribute.missing" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  (void) [((JavaUtilHashMap *) nil_chk(xmlNames_)) putWithId:[ComItextpdfTextPdfSimpleNamedDestination unEscapeBinaryStringWithNSString:[xmlLast_ getWithId:@"Name"]] withId:[xmlLast_ getWithId:@"Page"]];
  xmlLast_ = nil;
}


#line 307
- (void)startDocument {
}

- (void)startElementWithNSString:(NSString *)tag
                 withJavaUtilMap:(id<JavaUtilMap>)h {
  
#line 311
  if (xmlNames_ == nil) {
    if ([((NSString *) nil_chk(tag)) isEqual:@"Destination"]) {
      xmlNames_ = [[JavaUtilHashMap alloc] init];
      return;
    }
    else
#line 317
    @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"root.element.is.not.destination" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  if (![((NSString *) nil_chk(tag)) isEqual:@"Name"])
#line 320
  @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"tag.1.not.allowed" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ tag } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
  if (xmlLast_ != nil)
#line 322
  @throw [[JavaLangRuntimeException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"nested.tags.are.not.allowed" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
  xmlLast_ = [[JavaUtilHashMap alloc] initWithJavaUtilMap:h];
  (void) [xmlLast_ putWithId:@"Name" withId:@""];
}


#line 327
- (void)textWithNSString:(NSString *)str {
  
#line 328
  if (xmlLast_ == nil)
#line 329
  return;
  NSString *name = [((JavaUtilHashMap *) nil_chk(xmlLast_)) getWithId:@"Name"];
  name = JreStrcat("$$", name, str);
  (void) [xmlLast_ putWithId:@"Name" withId:name];
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfSimpleNamedDestination *)other {
  [super copyAllFieldsTo:other];
  other->xmlLast_ = xmlLast_;
  other->xmlNames_ = xmlNames_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "SimpleNamedDestination", NULL, 0x2, NULL },
    { "getNamedDestinationWithComItextpdfTextPdfPdfReader:withBoolean:", "getNamedDestination", "Ljava.util.HashMap;", 0x9, NULL },
    { "exportToXMLWithJavaUtilHashMap:withJavaIoOutputStream:withNSString:withBoolean:", "exportToXML", "V", 0x9, "Ljava.io.IOException;" },
    { "exportToXMLWithJavaUtilHashMap:withJavaIoWriter:withNSString:withBoolean:", "exportToXML", "V", 0x9, "Ljava.io.IOException;" },
    { "importFromXMLWithJavaIoInputStream:", "importFromXML", "Ljava.util.HashMap;", 0x9, "Ljava.io.IOException;" },
    { "importFromXMLWithJavaIoReader:", "importFromXML", "Ljava.util.HashMap;", 0x9, "Ljava.io.IOException;" },
    { "createDestinationArrayWithNSString:withComItextpdfTextPdfPdfWriter:", "createDestinationArray", "Lcom.itextpdf.text.pdf.PdfArray;", 0x8, NULL },
    { "outputNamedDestinationAsNamesWithJavaUtilHashMap:withComItextpdfTextPdfPdfWriter:", "outputNamedDestinationAsNames", "Lcom.itextpdf.text.pdf.PdfDictionary;", 0x9, NULL },
    { "outputNamedDestinationAsStringsWithJavaUtilHashMap:withComItextpdfTextPdfPdfWriter:", "outputNamedDestinationAsStrings", "Lcom.itextpdf.text.pdf.PdfDictionary;", 0x9, "Ljava.io.IOException;" },
    { "escapeBinaryStringWithNSString:", "escapeBinaryString", "Ljava.lang.String;", 0x9, NULL },
    { "unEscapeBinaryStringWithNSString:", "unEscapeBinaryString", "Ljava.lang.String;", 0x9, NULL },
    { "endDocument", NULL, "V", 0x1, NULL },
    { "endElementWithNSString:", "endElement", "V", 0x1, NULL },
    { "startDocument", NULL, "V", 0x1, NULL },
    { "startElementWithNSString:withJavaUtilMap:", "startElement", "V", 0x1, NULL },
    { "textWithNSString:", "text", "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "xmlNames_", NULL, 0x2, "Ljava.util.HashMap;", NULL,  },
    { "xmlLast_", NULL, 0x2, "Ljava.util.HashMap;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfSimpleNamedDestination = { "SimpleNamedDestination", "com.itextpdf.text.pdf", NULL, 0x11, 16, methods, 2, fields, 0, NULL};
  return &_ComItextpdfTextPdfSimpleNamedDestination;
}

@end

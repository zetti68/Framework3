//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/FontDetails.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/FontDetails.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/ExceptionConverter.h"
#include "com/itextpdf/text/Utilities.h"
#include "com/itextpdf/text/pdf/ArrayBasedStringTokenizer.h"
#include "com/itextpdf/text/pdf/BaseFont.h"
#include "com/itextpdf/text/pdf/CJKFont.h"
#include "com/itextpdf/text/pdf/FontDetails.h"
#include "com/itextpdf/text/pdf/Glyph.h"
#include "com/itextpdf/text/pdf/IntHashtable.h"
#include "com/itextpdf/text/pdf/PdfEncodings.h"
#include "com/itextpdf/text/pdf/PdfIndirectReference.h"
#include "com/itextpdf/text/pdf/PdfName.h"
#include "com/itextpdf/text/pdf/PdfWriter.h"
#include "com/itextpdf/text/pdf/TrueTypeFontUnicode.h"
#include "com/itextpdf/text/pdf/fonts/otf/Language.h"
#include "com/itextpdf/text/pdf/languages/BanglaGlyphRepositioner.h"
#include "com/itextpdf/text/pdf/languages/GlyphRepositioner.h"
#include "com/itextpdf/text/pdf/languages/IndicCompositeCharacterComparator.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Boolean.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/TreeSet.h"


#line 69
@implementation ComItextpdfTextPdfFontDetails


#line 126
- (instancetype)initWithComItextpdfTextPdfPdfName:(ComItextpdfTextPdfPdfName *)fontName
       withComItextpdfTextPdfPdfIndirectReference:(ComItextpdfTextPdfPdfIndirectReference *)indirectReference
                   withComItextpdfTextPdfBaseFont:(ComItextpdfTextPdfBaseFont *)baseFont {
  if (self = [super init]) {
    subset_ =
#line 116
    YES;
    
#line 127
    self->fontName_ = fontName;
    
#line 128
    self->indirectReference_ = indirectReference;
    
#line 129
    self->baseFont_ = baseFont;
    
#line 130
    fontType_ = [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont)) getFontType];
    
#line 131
    switch (fontType_) {
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_T1:
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_TT:
      shortTag_ = [IOSByteArray arrayWithLength:256];
      break;
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_CJK:
      cjkTag_ = [[ComItextpdfTextPdfIntHashtable alloc] init];
      cjkFont_ = (ComItextpdfTextPdfCJKFont *) check_class_cast(baseFont, [ComItextpdfTextPdfCJKFont class]);
      break;
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_TTUNI:
      longTag_ = [[JavaUtilHashMap alloc] init];
      ttu_ = (ComItextpdfTextPdfTrueTypeFontUnicode *) check_class_cast(baseFont, [ComItextpdfTextPdfTrueTypeFontUnicode class]);
      symbolic_ = [baseFont isFontSpecific];
      break;
    }
  }
  return self;
}


#line 152
- (ComItextpdfTextPdfPdfIndirectReference *)getIndirectReference {
  
#line 153
  return indirectReference_;
}


#line 160
- (ComItextpdfTextPdfPdfName *)getFontName {
  
#line 161
  return fontName_;
}


#line 168
- (ComItextpdfTextPdfBaseFont *)getBaseFont {
  
#line 169
  return baseFont_;
}


#line 179
- (IOSByteArray *)convertToBytesWithNSString:(NSString *)text {
  
#line 180
  IOSByteArray *b = nil;
  switch (fontType_) {
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_T3:
    return [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) convertToBytesWithNSString:text];
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_T1:
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_TT:
    {
      
#line 186
      b = [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) convertToBytesWithNSString:text];
      jint len = ((IOSByteArray *) nil_chk(b))->size_;
      for (jint k = 0; k < len; ++k)
#line 189
      *IOSByteArray_GetRef(nil_chk(shortTag_), IOSByteArray_Get(b, k) & (jint) 0xff) = 1;
      break;
    }
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_CJK:
    {
      
#line 193
      jint len = ((jint) [((NSString *) nil_chk(text)) length]);
      if ([((ComItextpdfTextPdfCJKFont *) nil_chk(cjkFont_)) isIdentity]) {
        for (jint k = 0; k < len; ++k) {
          [((ComItextpdfTextPdfIntHashtable *) nil_chk(cjkTag_)) putWithInt:[text charAtWithInt:k] withInt:0];
        }
      }
      else {
        for (jint k = 0; k < len; ++k) {
          jint val;
          if ([ComItextpdfTextUtilities isSurrogatePairWithNSString:text withInt:k]) {
            val = [ComItextpdfTextUtilities convertToUtf32WithNSString:text withInt:k];
            k++;
          }
          else {
            val = [text charAtWithInt:k];
          }
          [((ComItextpdfTextPdfIntHashtable *) nil_chk(cjkTag_)) putWithInt:[cjkFont_ getCidCodeWithInt:val] withInt:0];
        }
      }
      b = [cjkFont_ convertToBytesWithNSString:text];
      break;
    }
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_DOCUMENT:
    {
      
#line 216
      b = [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) convertToBytesWithNSString:text];
      break;
    }
    case ComItextpdfTextPdfBaseFont_FONT_TYPE_TTUNI:
    {
      
#line 220
      @try {
        jint len = ((jint) [((NSString *) nil_chk(text)) length]);
        IOSIntArray *metrics = nil;
        IOSCharArray *glyph = [IOSCharArray arrayWithLength:len];
        jint i = 0;
        if (symbolic_) {
          b = [ComItextpdfTextPdfPdfEncodings convertToBytesWithNSString:text withNSString:@"symboltt"];
          len = ((IOSByteArray *) nil_chk(b))->size_;
          for (jint k = 0; k < len; ++k) {
            metrics = [((ComItextpdfTextPdfTrueTypeFontUnicode *) nil_chk(ttu_)) getMetricsTTWithInt:IOSByteArray_Get(b, k) & (jint) 0xff];
            if (metrics == nil)
#line 231
            continue;
            (void) [((JavaUtilHashMap *) nil_chk(longTag_)) putWithId:[JavaLangInteger valueOfWithInt:IOSIntArray_Get(nil_chk(metrics), 0)] withId:[IOSIntArray arrayWithInts:(jint[]){ IOSIntArray_Get(metrics, 0), IOSIntArray_Get(metrics, 1), [ttu_ getUnicodeDifferencesWithInt:IOSByteArray_Get(b, k) & (jint) 0xff] } count:3]];
            *IOSCharArray_GetRef(glyph, i++) = (jchar) IOSIntArray_Get(metrics, 0);
          }
        }
        else
#line 235
        if ([self canApplyGlyphSubstitution]) {
          return [self convertToBytesAfterGlyphSubstitutionWithNSString:text];
        }
        else {
          
#line 238
          for (jint k = 0; k < len; ++k) {
            jint val;
            if ([ComItextpdfTextUtilities isSurrogatePairWithNSString:text withInt:k]) {
              val = [ComItextpdfTextUtilities convertToUtf32WithNSString:text withInt:k];
              k++;
            }
            else {
              val = [text charAtWithInt:k];
            }
            metrics = [((ComItextpdfTextPdfTrueTypeFontUnicode *) nil_chk(ttu_)) getMetricsTTWithInt:val];
            if (metrics == nil)
#line 249
            continue;
            jint m0 = IOSIntArray_Get(nil_chk(metrics), 0);
            JavaLangInteger *gl = [JavaLangInteger valueOfWithInt:m0];
            if (![((JavaUtilHashMap *) nil_chk(longTag_)) containsKeyWithId:gl])
#line 253
            (void) [longTag_ putWithId:gl withId:[IOSIntArray arrayWithInts:(jint[]){ m0, IOSIntArray_Get(metrics, 1), val } count:3]];
            *IOSCharArray_GetRef(glyph, i++) = (jchar) m0;
          }
        }
        NSString *s = [NSString stringWithCharacters:glyph offset:0 length:i];
        b = [s getBytesWithCharsetName:ComItextpdfTextPdfCJKFont_get_CJK_ENCODING_()];
      }
      @catch (JavaIoUnsupportedEncodingException *e) {
        @throw [[ComItextpdfTextExceptionConverter alloc] initWithJavaLangException:e];
      }
      break;
    }
  }
  return b;
}


#line 269
- (jboolean)canApplyGlyphSubstitution {
  
#line 270
  return (fontType_ == ComItextpdfTextPdfBaseFont_FONT_TYPE_TTUNI) && ([((ComItextpdfTextPdfTrueTypeFontUnicode *) nil_chk(ttu_)) getGlyphSubstitutionMap] != nil);
}


#line 273
- (IOSByteArray *)convertToBytesAfterGlyphSubstitutionWithNSString:(NSString *)text {
  if (![self canApplyGlyphSubstitution]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Make sure the font type if TTF Unicode and a valid GlyphSubstitutionTable exists!"];
  }
  
#line 279
  id<JavaUtilMap> glyphSubstitutionMap = [((ComItextpdfTextPdfTrueTypeFontUnicode *) nil_chk(ttu_)) getGlyphSubstitutionMap];
  
#line 284
  id<JavaUtilSet> compositeCharacters = [[JavaUtilTreeSet alloc] initWithJavaUtilComparator:[[ComItextpdfTextPdfLanguagesIndicCompositeCharacterComparator alloc] init]];
  [compositeCharacters addAllWithJavaUtilCollection:[((id<JavaUtilMap>) nil_chk(glyphSubstitutionMap)) keySet]];
  
#line 288
  ComItextpdfTextPdfArrayBasedStringTokenizer *tokenizer = [[ComItextpdfTextPdfArrayBasedStringTokenizer alloc] initWithNSStringArray:[compositeCharacters toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSString class]]]]];
  IOSObjectArray *tokens = [tokenizer tokenizeWithNSString:text];
  
#line 291
  id<JavaUtilList> glyphList = [[JavaUtilArrayList alloc] initWithInt:50];
  {
    IOSObjectArray *a__ = tokens;
    NSString * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    NSString * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      NSString *token = *b__++;
      
#line 296
      ComItextpdfTextPdfGlyph *subsGlyph = [glyphSubstitutionMap getWithId:token];
      
#line 298
      if (subsGlyph != nil) {
        [glyphList addWithId:subsGlyph];
      }
      else {
        {
          IOSCharArray *a__ =
#line 302
          [((NSString *) nil_chk(token)) toCharArray];
          jchar const *b__ = ((IOSCharArray *) nil_chk(a__))->buffer_;
          jchar const *e__ = b__ + a__->size_;
          while (b__ < e__) {
            jchar c = *b__++;
            
#line 303
            IOSIntArray *metrics = [ttu_ getMetricsTTWithInt:c];
            jint glyphCode = IOSIntArray_Get(nil_chk(metrics), 0);
            jint glyphWidth = IOSIntArray_Get(metrics, 1);
            [glyphList addWithId:[[ComItextpdfTextPdfGlyph alloc] initWithInt:glyphCode withInt:glyphWidth withNSString:[NSString valueOfChar:c]]];
          }
        }
      }
    }
  }
  id<ComItextpdfTextPdfLanguagesGlyphRepositioner> glyphRepositioner = [self getGlyphRepositioner];
  
#line 314
  if (glyphRepositioner != nil) {
    [glyphRepositioner repositionGlyphsWithJavaUtilList:glyphList];
  }
  
#line 318
  IOSCharArray *charEncodedGlyphCodes = [IOSCharArray arrayWithLength:[glyphList size]];
  
#line 321
  for (jint i = 0; i < [glyphList size]; i++) {
    ComItextpdfTextPdfGlyph *glyph = [glyphList getWithInt:i];
    *IOSCharArray_GetRef(charEncodedGlyphCodes, i) = (jchar) ((ComItextpdfTextPdfGlyph *) nil_chk(glyph))->code_;
    JavaLangInteger *glyphCode = [JavaLangInteger valueOfWithInt:glyph->code_];
    
#line 326
    if (![((JavaUtilHashMap *) nil_chk(longTag_)) containsKeyWithId:glyphCode]) {
      
#line 328
      (void) [longTag_ putWithId:glyphCode withId:[IOSIntArray arrayWithInts:(jint[]){ glyph->code_, glyph->width_, [((NSString *) nil_chk(glyph->chars_)) charAtWithInt:0] } count:3]];
    }
  }
  
#line 332
  return [[NSString stringWithCharacters:charEncodedGlyphCodes] getBytesWithCharsetName:ComItextpdfTextPdfCJKFont_get_CJK_ENCODING_()];
}


#line 335
- (id<ComItextpdfTextPdfLanguagesGlyphRepositioner>)getGlyphRepositioner {
  
#line 336
  ComItextpdfTextPdfFontsOtfLanguageEnum *language = [((ComItextpdfTextPdfTrueTypeFontUnicode *) nil_chk(ttu_)) getSupportedLanguage];
  
#line 338
  if (language == nil) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"The supported language field cannot be null in ", [[ttu_ getClass] getName])];
  }
  
#line 342
  switch ([language ordinal]) {
    case ComItextpdfTextPdfFontsOtfLanguage_BENGALI:
    return [[ComItextpdfTextPdfLanguagesBanglaGlyphRepositioner alloc] initWithJavaUtilMap:[JavaUtilCollections unmodifiableMapWithJavaUtilMap:ttu_->cmap31_] withJavaUtilMap:[ttu_ getGlyphSubstitutionMap]];
    default:
    return nil;
  }
}

- (void)writeFontWithComItextpdfTextPdfPdfWriter:(ComItextpdfTextPdfPdfWriter *)writer {
  
#line 355
  @try {
    switch (fontType_) {
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_T3:
      [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) writeFontWithComItextpdfTextPdfPdfWriter:writer withComItextpdfTextPdfPdfIndirectReference:indirectReference_ withNSObjectArray:nil];
      break;
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_T1:
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_TT:
      {
        
#line 362
        jint firstChar;
        jint lastChar;
        for (firstChar = 0; firstChar < 256; ++firstChar) {
          if (IOSByteArray_Get(nil_chk(shortTag_), firstChar) != 0)
#line 366
          break;
        }
        for (lastChar = 255; lastChar >= firstChar; --lastChar) {
          if (IOSByteArray_Get(nil_chk(shortTag_), lastChar) != 0)
#line 370
          break;
        }
        if (firstChar > 255) {
          firstChar = 255;
          lastChar = 255;
        }
        [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) writeFontWithComItextpdfTextPdfPdfWriter:writer withComItextpdfTextPdfPdfIndirectReference:indirectReference_ withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:firstChar], [JavaLangInteger valueOfWithInt:lastChar], shortTag_, [JavaLangBoolean valueOfWithBoolean:subset_] } count:4 type:[IOSClass classWithClass:[NSObject class]]]];
        break;
      }
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_CJK:
      [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) writeFontWithComItextpdfTextPdfPdfWriter:writer withComItextpdfTextPdfPdfIndirectReference:indirectReference_ withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ cjkTag_ } count:1 type:[IOSClass classWithClass:[NSObject class]]]];
      break;
      case ComItextpdfTextPdfBaseFont_FONT_TYPE_TTUNI:
      [((ComItextpdfTextPdfBaseFont *) nil_chk(baseFont_)) writeFontWithComItextpdfTextPdfPdfWriter:writer withComItextpdfTextPdfPdfIndirectReference:indirectReference_ withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ longTag_, [JavaLangBoolean valueOfWithBoolean:subset_] } count:2 type:[IOSClass classWithClass:[NSObject class]]]];
      break;
    }
  }
  @catch (JavaLangException *e) {
    @throw [[ComItextpdfTextExceptionConverter alloc] initWithJavaLangException:e];
  }
}


#line 397
- (jboolean)isSubset {
  
#line 398
  return subset_;
}


#line 407
- (void)setSubsetWithBoolean:(jboolean)subset {
  
#line 408
  self->subset_ = subset;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfFontDetails *)other {
  [super copyAllFieldsTo:other];
  other->baseFont_ = baseFont_;
  other->cjkFont_ = cjkFont_;
  other->cjkTag_ = cjkTag_;
  other->fontName_ = fontName_;
  other->fontType_ = fontType_;
  other->indirectReference_ = indirectReference_;
  other->longTag_ = longTag_;
  other->shortTag_ = shortTag_;
  other->subset_ = subset_;
  other->symbolic_ = symbolic_;
  other->ttu_ = ttu_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfTextPdfPdfName:withComItextpdfTextPdfPdfIndirectReference:withComItextpdfTextPdfBaseFont:", "FontDetails", NULL, 0x0, NULL },
    { "getIndirectReference", NULL, "Lcom.itextpdf.text.pdf.PdfIndirectReference;", 0x0, NULL },
    { "getFontName", NULL, "Lcom.itextpdf.text.pdf.PdfName;", 0x0, NULL },
    { "getBaseFont", NULL, "Lcom.itextpdf.text.pdf.BaseFont;", 0x0, NULL },
    { "convertToBytesWithNSString:", "convertToBytes", "[B", 0x0, NULL },
    { "canApplyGlyphSubstitution", NULL, "Z", 0x2, NULL },
    { "convertToBytesAfterGlyphSubstitutionWithNSString:", "convertToBytesAfterGlyphSubstitution", "[B", 0x2, "Ljava.io.UnsupportedEncodingException;" },
    { "getGlyphRepositioner", NULL, "Lcom.itextpdf.text.pdf.languages.GlyphRepositioner;", 0x2, NULL },
    { "writeFontWithComItextpdfTextPdfPdfWriter:", "writeFont", "V", 0x1, NULL },
    { "isSubset", NULL, "Z", 0x1, NULL },
    { "setSubsetWithBoolean:", "setSubset", "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "indirectReference_", NULL, 0x0, "Lcom.itextpdf.text.pdf.PdfIndirectReference;", NULL,  },
    { "fontName_", NULL, 0x0, "Lcom.itextpdf.text.pdf.PdfName;", NULL,  },
    { "baseFont_", NULL, 0x0, "Lcom.itextpdf.text.pdf.BaseFont;", NULL,  },
    { "ttu_", NULL, 0x0, "Lcom.itextpdf.text.pdf.TrueTypeFontUnicode;", NULL,  },
    { "cjkFont_", NULL, 0x0, "Lcom.itextpdf.text.pdf.CJKFont;", NULL,  },
    { "shortTag_", NULL, 0x0, "[B", NULL,  },
    { "longTag_", NULL, 0x0, "Ljava.util.HashMap;", NULL,  },
    { "cjkTag_", NULL, 0x0, "Lcom.itextpdf.text.pdf.IntHashtable;", NULL,  },
    { "fontType_", NULL, 0x0, "I", NULL,  },
    { "symbolic_", NULL, 0x0, "Z", NULL,  },
    { "subset_", NULL, 0x4, "Z", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfFontDetails = { "FontDetails", "com.itextpdf.text.pdf", NULL, 0x0, 11, methods, 11, fields, 0, NULL};
  return &_ComItextpdfTextPdfFontDetails;
}

@end

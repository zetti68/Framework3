//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/LongHashtable.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/text/pdf/LongHashtable.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/text/error_messages/MessageLocalization.h"
#include "com/itextpdf/text/pdf/LongHashtable.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InternalError.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Arrays.h"
#include "java/util/Iterator.h"
#include "java/util/NoSuchElementException.h"


#line 51
@implementation ComItextpdfTextPdfLongHashtable


#line 82
- (instancetype)init {
  return
#line 83
  [self initComItextpdfTextPdfLongHashtableWithInt:150 withFloat:0.75f];
}


#line 94
- (instancetype)initWithInt:(jint)initialCapacity {
  return
#line 95
  [self initComItextpdfTextPdfLongHashtableWithInt:initialCapacity withFloat:0.75f];
}


#line 107
- (instancetype)initComItextpdfTextPdfLongHashtableWithInt:(jint)initialCapacity
                                                 withFloat:(jfloat)loadFactor {
  if (self =
#line 108
  [super init]) {
    
#line 109
    if (initialCapacity < 0) {
      @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"illegal.capacity.1" withInt:initialCapacity]];
    }
    
#line 112
    if (loadFactor <= 0) {
      @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"illegal.load.1" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [NSString valueOfFloat:loadFactor] } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
    
#line 115
    if (initialCapacity == 0) {
      initialCapacity = 1;
    }
    
#line 118
    self->loadFactor_ = loadFactor;
    
#line 119
    table_ = [IOSObjectArray arrayWithLength:initialCapacity type:[IOSClass classWithClass:[ComItextpdfTextPdfLongHashtable_Entry class]]];
    
#line 120
    threshold_ = J2ObjCFpToInt((initialCapacity * loadFactor));
  }
  return self;
}

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor {
  return [self initComItextpdfTextPdfLongHashtableWithInt:
#line 107
initialCapacity withFloat:loadFactor];
}


#line 128
- (jint)size {
  
#line 129
  return count_;
}


#line 138
- (jboolean)isEmpty {
  
#line 139
  return count_ == 0;
}


#line 160
- (jboolean)containsWithLong:(jlong)value {
  
#line 162
  IOSObjectArray *tab = table_;
  for (jint i = ((IOSObjectArray *) nil_chk(tab))->size_; i-- > 0; ) {
    for (ComItextpdfTextPdfLongHashtable_Entry *e = IOSObjectArray_Get(tab, i); e != nil; e = e->next_) {
      if (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->value_ == value) {
        return YES;
      }
    }
  }
  return NO;
}


#line 185
- (jboolean)containsValueWithLong:(jlong)value {
  
#line 186
  return [self containsWithLong:value];
}


#line 198
- (jboolean)containsKeyWithLong:(jlong)key {
  
#line 199
  IOSObjectArray *tab = table_;
  jint hash_ = (jint) (key ^ (URShift64(key, 32)));
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfLongHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      return YES;
    }
  }
  return NO;
}


#line 219
- (jlong)getWithLong:(jlong)key {
  
#line 220
  IOSObjectArray *tab = table_;
  jint hash_ = (jint) (key ^ (URShift64(key, 32)));
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfLongHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      return e->value_;
    }
  }
  return 0;
}


#line 240
- (void)rehash {
  
#line 241
  jint oldCapacity = ((IOSObjectArray *) nil_chk(table_))->size_;
  IOSObjectArray *oldMap = table_;
  
#line 244
  jint newCapacity = oldCapacity * 2 + 1;
  IOSObjectArray *newMap = [IOSObjectArray arrayWithLength:newCapacity type:[IOSClass classWithClass:[ComItextpdfTextPdfLongHashtable_Entry class]]];
  
#line 247
  threshold_ = J2ObjCFpToInt((newCapacity * loadFactor_));
  table_ = newMap;
  
#line 250
  for (jint i = oldCapacity; i-- > 0; ) {
    for (ComItextpdfTextPdfLongHashtable_Entry *old = IOSObjectArray_Get(oldMap, i); old != nil; ) {
      ComItextpdfTextPdfLongHashtable_Entry *e = old;
      old = ((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(old))->next_;
      
#line 255
      jint index = (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->hash__ & (jint) 0x7FFFFFFF) % newCapacity;
      e->next_ = IOSObjectArray_Get(newMap, index);
      IOSObjectArray_Set(newMap, index, e);
    }
  }
}


#line 277
- (jlong)putWithLong:(jlong)key
            withLong:(jlong)value {
  
#line 279
  IOSObjectArray *tab = table_;
  jint hash_ = (jint) (key ^ (URShift64(key, 32)));
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfLongHashtable_Entry *e = IOSObjectArray_Get(tab, index); e != nil; e = e->next_) {
    if (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      jlong old = e->value_;
      e->value_ = value;
      return old;
    }
  }
  
#line 290
  if (count_ >= threshold_) {
    
#line 292
    [self rehash];
    
#line 294
    tab = table_;
    index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  }
  
#line 299
  ComItextpdfTextPdfLongHashtable_Entry *e = [[ComItextpdfTextPdfLongHashtable_Entry alloc] initWithInt:hash_ withLong:key withLong:value withComItextpdfTextPdfLongHashtable_Entry:IOSObjectArray_Get(nil_chk(tab), index)];
  IOSObjectArray_Set(tab, index, e);
  count_++;
  return 0;
}


#line 316
- (jlong)removeWithLong:(jlong)key {
  
#line 317
  IOSObjectArray *tab = table_;
  jint hash_ = (jint) (key ^ (URShift64(key, 32)));
  jint index = (hash_ & (jint) 0x7FFFFFFF) % ((IOSObjectArray *) nil_chk(tab))->size_;
  for (ComItextpdfTextPdfLongHashtable_Entry *e = IOSObjectArray_Get(tab, index), *prev = nil; e != nil; prev = e, e = e->next_) {
    if (((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->hash__ == hash_ && e->key_ == key) {
      if (prev != nil) {
        prev->next_ = e->next_;
      }
      else {
        
#line 325
        IOSObjectArray_Set(tab, index, e->next_);
      }
      count_--;
      jlong oldValue = e->value_;
      e->value_ = 0;
      return oldValue;
    }
  }
  return 0;
}


#line 339
- (void)clear {
  
#line 340
  IOSObjectArray *tab = table_;
  for (jint index = ((IOSObjectArray *) nil_chk(tab))->size_; --index >= 0; ) {
    IOSObjectArray_Set(tab, index, nil);
  }
  count_ = 0;
}


#line 426
- (id<JavaUtilIterator>)getEntryIterator {
  
#line 427
  return [[ComItextpdfTextPdfLongHashtable_LongHashtableIterator alloc] initWithComItextpdfTextPdfLongHashtable_EntryArray:table_];
}


#line 430
- (IOSLongArray *)toOrderedKeys {
  
#line 431
  IOSLongArray *res = [self getKeys];
  [JavaUtilArrays sortWithLongArray:res];
  return res;
}


#line 436
- (IOSLongArray *)getKeys {
  
#line 437
  IOSLongArray *res = [IOSLongArray arrayWithLength:count_];
  jint ptr = 0;
  jint index = ((IOSObjectArray *) nil_chk(table_))->size_;
  ComItextpdfTextPdfLongHashtable_Entry *entry_ = nil;
  while (YES) {
    if (entry_ == nil)
#line 443
    while (index-- > 0 && (entry_ = IOSObjectArray_Get(table_, index)) == nil) ;
    if (entry_ == nil)
#line 445
    break;
    ComItextpdfTextPdfLongHashtable_Entry *e = entry_;
    entry_ = ((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(e))->next_;
    *IOSLongArray_GetRef(res, ptr++) = e->key_;
  }
  return res;
}


#line 453
- (jlong)getOneKey {
  
#line 454
  if (count_ == 0)
#line 455
  return 0;
  jint index = ((IOSObjectArray *) nil_chk(table_))->size_;
  ComItextpdfTextPdfLongHashtable_Entry *entry_ = nil;
  while (index-- > 0 && (entry_ = IOSObjectArray_Get(table_, index)) == nil) ;
  if (entry_ == nil)
#line 460
  return 0;
  return ((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(entry_))->key_;
}


#line 465
- (id)clone {
  
#line 466
  @try {
    ComItextpdfTextPdfLongHashtable *t = (ComItextpdfTextPdfLongHashtable *) check_class_cast([super clone], [ComItextpdfTextPdfLongHashtable class]);
    ((ComItextpdfTextPdfLongHashtable *) nil_chk(t))->table_ = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(table_))->size_ type:[IOSClass classWithClass:[ComItextpdfTextPdfLongHashtable_Entry class]]];
    for (jint i = table_->size_; i-- > 0; ) {
      IOSObjectArray_Set(t->table_, i, IOSObjectArray_Get(table_, i) != nil ?
#line 471
      (ComItextpdfTextPdfLongHashtable_Entry *) check_class_cast([((ComItextpdfTextPdfLongHashtable_Entry *) nil_chk(IOSObjectArray_Get(table_, i))) clone], [ComItextpdfTextPdfLongHashtable_Entry class]) : nil);
    }
    return t;
  }
  @catch (
#line 474
  JavaLangCloneNotSupportedException *e) {
    
#line 476
    @throw [[JavaLangInternalError alloc] init];
  }
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfLongHashtable *)other {
  [super copyAllFieldsTo:other];
  other->count_ = count_;
  other->loadFactor_ = loadFactor_;
  other->table_ = table_;
  other->threshold_ = threshold_;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "LongHashtable", NULL, 0x1, NULL },
    { "initWithInt:", "LongHashtable", NULL, 0x1, NULL },
    { "initWithInt:withFloat:", "LongHashtable", NULL, 0x1, NULL },
    { "size", NULL, "I", 0x1, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL },
    { "containsWithLong:", "contains", "Z", 0x1, NULL },
    { "containsValueWithLong:", "containsValue", "Z", 0x1, NULL },
    { "containsKeyWithLong:", "containsKey", "Z", 0x1, NULL },
    { "getWithLong:", "get", "J", 0x1, NULL },
    { "rehash", NULL, "V", 0x4, NULL },
    { "putWithLong:withLong:", "put", "J", 0x1, NULL },
    { "removeWithLong:", "remove", "J", 0x1, NULL },
    { "clear", NULL, "V", 0x1, NULL },
    { "getEntryIterator", NULL, "Ljava.util.Iterator;", 0x1, NULL },
    { "toOrderedKeys", NULL, "[J", 0x1, NULL },
    { "getKeys", NULL, "[J", 0x1, NULL },
    { "getOneKey", NULL, "J", 0x1, NULL },
    { "clone", NULL, "Ljava.lang.Object;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "table_", NULL, 0x82, "[Lcom.itextpdf.text.pdf.LongHashtable$Entry;", NULL,  },
    { "count_", NULL, 0x82, "I", NULL,  },
    { "threshold_", NULL, 0x2, "I", NULL,  },
    { "loadFactor_", NULL, 0x2, "F", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfLongHashtable = { "LongHashtable", "com.itextpdf.text.pdf", NULL, 0x1, 18, methods, 4, fields, 0, NULL};
  return &_ComItextpdfTextPdfLongHashtable;
}

@end


#line 351
@implementation ComItextpdfTextPdfLongHashtable_Entry


#line 365
- (instancetype)initWithInt:(jint)hash_
                   withLong:(jlong)key
                   withLong:(jlong)value
withComItextpdfTextPdfLongHashtable_Entry:(ComItextpdfTextPdfLongHashtable_Entry *)next {
  if (self = [super init]) {
    
#line 366
    self->hash__ = hash_;
    
#line 367
    self->key_ = key;
    
#line 368
    self->value_ = value;
    
#line 369
    self->next_ = next;
  }
  return self;
}


#line 373
- (jlong)getKey {
  
#line 374
  return key_;
}


#line 376
- (jlong)getValue {
  
#line 377
  return value_;
}


#line 380
- (id)clone {
  
#line 381
  ComItextpdfTextPdfLongHashtable_Entry *entry_ = [[ComItextpdfTextPdfLongHashtable_Entry alloc] initWithInt:hash__ withLong:key_ withLong:value_ withComItextpdfTextPdfLongHashtable_Entry:next_ != nil ? (ComItextpdfTextPdfLongHashtable_Entry *) check_class_cast([next_ clone], [ComItextpdfTextPdfLongHashtable_Entry class]) : nil];
  return entry_;
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfLongHashtable_Entry *)other {
  [super copyAllFieldsTo:other];
  other->hash__ = hash__;
  other->key_ = key_;
  other->next_ = next_;
  other->value_ = value_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withLong:withLong:withComItextpdfTextPdfLongHashtable_Entry:", "Entry", NULL, 0x4, NULL },
    { "getKey", NULL, "J", 0x1, NULL },
    { "getValue", NULL, "J", 0x1, NULL },
    { "clone", NULL, "Ljava.lang.Object;", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "hash__", "hash", 0x0, "I", NULL,  },
    { "key_", NULL, 0x0, "J", NULL,  },
    { "value_", NULL, 0x0, "J", NULL,  },
    { "next_", NULL, 0x0, "Lcom.itextpdf.text.pdf.LongHashtable$Entry;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfLongHashtable_Entry = { "Entry", "com.itextpdf.text.pdf", "LongHashtable", 0x8, 4, methods, 4, fields, 0, NULL};
  return &_ComItextpdfTextPdfLongHashtable_Entry;
}

@end


#line 387
@implementation ComItextpdfTextPdfLongHashtable_LongHashtableIterator


#line 392
- (instancetype)initWithComItextpdfTextPdfLongHashtable_EntryArray:(IOSObjectArray *)table {
  if (self = [super init]) {
    
#line 393
    self->table_ = table;
    
#line 394
    self->index_ = ((IOSObjectArray *) nil_chk(table))->size_;
  }
  return self;
}


#line 396
- (jboolean)hasNext {
  
#line 397
  if (entry__ != nil) {
    return YES;
  }
  while (index_-- > 0) {
    if ((entry__ = IOSObjectArray_Get(nil_chk(table_), index_)) != nil) {
      return YES;
    }
  }
  return NO;
}


#line 408
- (ComItextpdfTextPdfLongHashtable_Entry *)next {
  
#line 409
  if (entry__ == nil) {
    while (index_-- > 0 && (entry__ = IOSObjectArray_Get(nil_chk(table_), index_)) == nil) ;
  }
  if (entry__ != nil) {
    ComItextpdfTextPdfLongHashtable_Entry *e = entry__;
    entry__ = e->next_;
    return e;
  }
  @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"inthashtableiterator" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
}


#line 419
- (void)remove {
  
#line 420
  @throw [[JavaLangUnsupportedOperationException alloc] initWithNSString:[ComItextpdfTextError_messagesMessageLocalization getComposedMessageWithNSString:@"remove.not.supported" withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSObject class]]]]];
}

- (void)copyAllFieldsTo:(ComItextpdfTextPdfLongHashtable_LongHashtableIterator *)other {
  [super copyAllFieldsTo:other];
  other->entry__ = entry__;
  other->index_ = index_;
  other->table_ = table_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfTextPdfLongHashtable_EntryArray:", "LongHashtableIterator", NULL, 0x0, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
    { "next", NULL, "Lcom.itextpdf.text.pdf.LongHashtable$Entry;", 0x1, NULL },
    { "remove", NULL, "V", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "index_", NULL, 0x0, "I", NULL,  },
    { "table_", NULL, 0x0, "[Lcom.itextpdf.text.pdf.LongHashtable$Entry;", NULL,  },
    { "entry__", "entry", 0x0, "Lcom.itextpdf.text.pdf.LongHashtable$Entry;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfTextPdfLongHashtable_LongHashtableIterator = { "LongHashtableIterator", "com.itextpdf.text.pdf", "LongHashtable", 0x8, 4, methods, 3, fields, 0, NULL};
  return &_ComItextpdfTextPdfLongHashtable_LongHashtableIterator;
}

@end

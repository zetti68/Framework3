//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/ISO8601Converter.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/ISO8601Converter.java"

#include "IOSClass.h"
#include "com/itextpdf/xmp/XMPDateTime.h"
#include "com/itextpdf/xmp/XMPError.h"
#include "com/itextpdf/xmp/XMPException.h"
#include "com/itextpdf/xmp/impl/ISO8601Converter.h"
#include "com/itextpdf/xmp/impl/XMPDateTimeImpl.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuffer.h"
#include "java/text/DecimalFormat.h"
#include "java/text/DecimalFormatSymbols.h"
#include "java/util/Calendar.h"
#include "java/util/Locale.h"
#include "java/util/SimpleTimeZone.h"
#include "java/util/TimeZone.h"


#line 48
@implementation ComItextpdfXmpImplISO8601Converter


#line 51
- (instancetype)init {
  return [super init];
}


#line 97
+ (id<ComItextpdfXmpXMPDateTime>)parseWithNSString:(NSString *)iso8601String {
  
#line 99
  return [ComItextpdfXmpImplISO8601Converter parseWithNSString:iso8601String withComItextpdfXmpXMPDateTime:[[ComItextpdfXmpImplXMPDateTimeImpl alloc] init]];
}


#line 109
+ (id<ComItextpdfXmpXMPDateTime>)parseWithNSString:(NSString *)iso8601String
                     withComItextpdfXmpXMPDateTime:(id<ComItextpdfXmpXMPDateTime>)binValue {
  
#line 111
  if (iso8601String == nil) {
    
#line 113
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Parameter must not be null" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
  else if (((jint) [iso8601String length]) == 0) {
    
#line 117
    return binValue;
  }
  
#line 120
  ComItextpdfXmpImplParseState *input = [[ComItextpdfXmpImplParseState alloc] initWithNSString:iso8601String];
  jint value;
  
#line 123
  if ([input chWithInt:0] == '-') {
    
#line 125
    [input skip];
  }
  
#line 129
  value = [input gatherIntWithNSString:@"Invalid year in date string" withInt:9999];
  if ([input hasNext] && [input ch] != '-') {
    
#line 132
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after year" withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
  
#line 135
  if ([input chWithInt:0] == '-') {
    
#line 137
    value = -value;
  }
  [((id<ComItextpdfXmpXMPDateTime>) nil_chk(binValue)) setYearWithInt:value];
  if (![input hasNext]) {
    
#line 142
    return binValue;
  }
  [input skip];
  
#line 148
  value = [input gatherIntWithNSString:@"Invalid month in date string" withInt:12];
  if ([input hasNext] && [input ch] != '-') {
    
#line 151
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after month" withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
  [binValue setMonthWithInt:value];
  if (![input hasNext]) {
    
#line 156
    return binValue;
  }
  [input skip];
  
#line 162
  value = [input gatherIntWithNSString:@"Invalid day in date string" withInt:31];
  if ([input hasNext] && [input ch] != 'T') {
    
#line 165
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after day" withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
  [binValue setDayWithInt:value];
  if (![input hasNext]) {
    
#line 170
    return binValue;
  }
  [input skip];
  
#line 175
  value = [input gatherIntWithNSString:@"Invalid hour in date string" withInt:23];
  [binValue setHourWithInt:value];
  if (![input hasNext]) {
    
#line 179
    return binValue;
  }
  
#line 183
  if ([input ch] == ':') {
    
#line 185
    [input skip];
    value = [input gatherIntWithNSString:@"Invalid minute in date string" withInt:59];
    if ([input hasNext] &&
#line 188
    [input ch] != ':' && [input ch] != 'Z' && [input ch] != '+' && [input ch] != '-') {
      
#line 190
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after minute" withInt:ComItextpdfXmpXMPError_BADVALUE];
    }
    [binValue setMinuteWithInt:value];
  }
  
#line 195
  if (![input hasNext]) {
    
#line 197
    return binValue;
  }
  else if ([input hasNext] && [input ch] == ':') {
    
#line 201
    [input skip];
    value = [input gatherIntWithNSString:@"Invalid whole seconds in date string" withInt:59];
    if ([input hasNext] && [input ch] != '.' && [input ch] != 'Z' &&
#line 204
    [input ch] != '+' && [input ch] != '-') {
      
#line 206
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after whole seconds" withInt:
#line 207
      ComItextpdfXmpXMPError_BADVALUE];
    }
    [binValue setSecondWithInt:value];
    if ([input ch] == '.') {
      
#line 212
      [input skip];
      jint digits = [input pos];
      value = [input gatherIntWithNSString:@"Invalid fractional seconds in date string" withInt:999999999];
      if ([input hasNext] &&
#line 216
      ([input ch] != 'Z' && [input ch] != '+' && [input ch] != '-')) {
        
#line 218
        @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after fractional second" withInt:
#line 219
        ComItextpdfXmpXMPError_BADVALUE];
      }
      digits = [input pos] - digits;
      for (; digits > 9; --digits) {
        
#line 224
        value = value / 10;
      }
      for (; digits < 9; ++digits) {
        
#line 228
        value = value * 10;
      }
      [binValue setNanoSecondWithInt:value];
    }
  }
  else if ([input ch] != 'Z' && [input ch] != '+' && [input ch] != '-') {
    
#line 235
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after time" withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
  
#line 239
  jint tzSign = 0;
  jint tzHour = 0;
  jint tzMinute = 0;
  
#line 243
  if (![input hasNext]) {
    
#line 246
    return binValue;
  }
  else if ([input ch] == 'Z') {
    
#line 250
    [input skip];
  }
  else if ([input hasNext]) {
    
#line 254
    if ([input ch] == '+') {
      
#line 256
      tzSign = 1;
    }
    else if ([input ch] == '-') {
      
#line 260
      tzSign = -1;
    }
    else {
      
#line 264
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Time zone must begin with 'Z', '+', or '-'" withInt:
#line 265
      ComItextpdfXmpXMPError_BADVALUE];
    }
    
#line 268
    [input skip];
    
#line 270
    tzHour = [input gatherIntWithNSString:@"Invalid time zone hour in date string" withInt:23];
    if ([input hasNext]) {
      
#line 273
      if ([input ch] == ':') {
        
#line 275
        [input skip];
        
#line 278
        tzMinute = [input gatherIntWithNSString:@"Invalid time zone minute in date string" withInt:59];
      }
      else {
        
#line 282
        @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid date string, after time zone hour" withInt:
#line 283
        ComItextpdfXmpXMPError_BADVALUE];
      }
    }
  }
  
#line 289
  jint offset = (tzHour * 3600 * 1000 + tzMinute * 60 * 1000) * tzSign;
  [binValue setTimeZoneWithJavaUtilTimeZone:[[JavaUtilSimpleTimeZone alloc] initWithInt:offset withNSString:@""]];
  
#line 292
  if ([input hasNext]) {
    
#line 294
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:
#line 295
    @"Invalid date string, extra chars at end" withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
  
#line 298
  return binValue;
}


#line 334
+ (NSString *)renderWithComItextpdfXmpXMPDateTime:(id<ComItextpdfXmpXMPDateTime>)dateTime {
  
#line 336
  JavaLangStringBuffer *buffer = [[JavaLangStringBuffer alloc] init];
  
#line 338
  if ([((id<ComItextpdfXmpXMPDateTime>) nil_chk(dateTime)) hasDate]) {
    
#line 341
    JavaTextDecimalFormat *df = [[JavaTextDecimalFormat alloc] initWithNSString:@"0000" withJavaTextDecimalFormatSymbols:[[JavaTextDecimalFormatSymbols alloc] initWithJavaUtilLocale:JavaUtilLocale_get_ENGLISH_()]];
    (void) [buffer appendWithNSString:[df formatWithLong:[dateTime getYear]]];
    if ([dateTime getMonth] == 0) {
      
#line 345
      return [buffer description];
    }
    
#line 349
    [df applyPatternWithNSString:@"'-'00"];
    (void) [buffer appendWithNSString:[df formatWithLong:[dateTime getMonth]]];
    if ([dateTime getDay] == 0) {
      
#line 353
      return [buffer description];
    }
    
#line 357
    (void) [buffer appendWithNSString:[df formatWithLong:[dateTime getDay]]];
    
#line 360
    if ([dateTime hasTime]) {
      
#line 363
      (void) [buffer appendWithChar:'T'];
      [df applyPatternWithNSString:@"00"];
      (void) [buffer appendWithNSString:[df formatWithLong:[dateTime getHour]]];
      (void) [buffer appendWithChar:':'];
      (void) [buffer appendWithNSString:[df formatWithLong:[dateTime getMinute]]];
      
#line 370
      if ([dateTime getSecond] != 0 || [dateTime getNanoSecond] != 0) {
        
#line 372
        jdouble seconds = [dateTime getSecond] + [dateTime getNanoSecond] / 1e9;
        
#line 374
        [df applyPatternWithNSString:@":00.#########"];
        (void) [buffer appendWithNSString:[df formatWithDouble:seconds]];
      }
      
#line 379
      if ([dateTime hasTimeZone]) {
        
#line 382
        jlong timeInMillis = [((JavaUtilCalendar *) nil_chk([dateTime getCalendar])) getTimeInMillis];
        jint offset = [((JavaUtilTimeZone *) nil_chk([dateTime getTimeZone])) getOffsetWithLong:timeInMillis];
        if (offset == 0) {
          
#line 387
          (void) [buffer appendWithChar:'Z'];
        }
        else {
          
#line 391
          jint thours = offset / 3600000;
          jint tminutes = [JavaLangMath absWithInt:offset % 3600000 / 60000];
          [df applyPatternWithNSString:@"+00;-00"];
          (void) [buffer appendWithNSString:[df formatWithLong:thours]];
          [df applyPatternWithNSString:@":00"];
          (void) [buffer appendWithNSString:[df formatWithLong:tminutes]];
        }
      }
    }
  }
  return [buffer description];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "ISO8601Converter", NULL, 0x2, NULL },
    { "parseWithNSString:", "parse", "Lcom.itextpdf.xmp.XMPDateTime;", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "parseWithNSString:withComItextpdfXmpXMPDateTime:", "parse", "Lcom.itextpdf.xmp.XMPDateTime;", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "renderWithComItextpdfXmpXMPDateTime:", "render", "Ljava.lang.String;", 0x9, NULL },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplISO8601Converter = { "ISO8601Converter", "com.itextpdf.xmp.impl", NULL, 0x11, 4, methods, 0, NULL, 0, NULL};
  return &_ComItextpdfXmpImplISO8601Converter;
}

@end


#line 411
@implementation ComItextpdfXmpImplParseState


#line 422
- (instancetype)initWithNSString:(NSString *)str {
  if (self = [super init]) {
    pos__ =
#line 416
    0;
    
#line 424
    self->str_ = str;
  }
  return self;
}


#line 431
- (jint)length {
  
#line 433
  return ((jint) [((NSString *) nil_chk(str_)) length]);
}


#line 440
- (jboolean)hasNext {
  
#line 442
  return pos__ < ((jint) [((NSString *) nil_chk(str_)) length]);
}


#line 450
- (jchar)chWithInt:(jint)index {
  
#line 452
  return index < ((jint) [((NSString *) nil_chk(str_)) length]) ?
#line 453
  [str_ charAtWithInt:index] :
#line 454
  (jint) 0x0000;
}


#line 461
- (jchar)ch {
  
#line 463
  return pos__ < ((jint) [((NSString *) nil_chk(str_)) length]) ?
#line 464
  [str_ charAtWithInt:pos__] :
#line 465
  (jint) 0x0000;
}


#line 472
- (void)skip {
  
#line 474
  pos__++;
}


#line 481
- (jint)pos {
  
#line 483
  return pos__;
}


#line 494
- (jint)gatherIntWithNSString:(NSString *)errorMsg
                      withInt:(jint)maxValue {
  
#line 496
  jint value = 0;
  jboolean success = NO;
  jchar ch = [self chWithInt:pos__];
  while ('0' <= ch && ch <= '9') {
    
#line 501
    value = (value * 10) + (ch - '0');
    success = YES;
    pos__++;
    ch = [self chWithInt:pos__];
  }
  
#line 507
  if (success) {
    
#line 509
    if (value > maxValue) {
      
#line 511
      return maxValue;
    }
    else if (value < 0) {
      
#line 515
      return 0;
    }
    else {
      
#line 519
      return value;
    }
  }
  else {
    
#line 524
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:errorMsg withInt:ComItextpdfXmpXMPError_BADVALUE];
  }
}

- (void)copyAllFieldsTo:(ComItextpdfXmpImplParseState *)other {
  [super copyAllFieldsTo:other];
  other->pos__ = pos__;
  other->str_ = str_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:", "ParseState", NULL, 0x1, NULL },
    { "length", NULL, "I", 0x1, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
    { "chWithInt:", "ch", "C", 0x1, NULL },
    { "ch", NULL, "C", 0x1, NULL },
    { "skip", NULL, "V", 0x1, NULL },
    { "pos", NULL, "I", 0x1, NULL },
    { "gatherIntWithNSString:withInt:", "gatherInt", "I", 0x1, "Lcom.itextpdf.xmp.XMPException;" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "str_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "pos__", "pos", 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplParseState = { "ParseState", "com.itextpdf.xmp.impl", NULL, 0x0, 8, methods, 2, fields, 0, NULL};
  return &_ComItextpdfXmpImplParseState;
}

@end

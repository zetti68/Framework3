//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/Latin1Converter.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/Latin1Converter.java"

#include "IOSPrimitiveArray.h"
#include "com/itextpdf/xmp/impl/ByteBuffer.h"
#include "com/itextpdf/xmp/impl/Latin1Converter.h"
#include "java/io/UnsupportedEncodingException.h"


#line 39
@implementation ComItextpdfXmpImplLatin1Converter


#line 50
- (instancetype)init {
  return [super init];
}


#line 85
+ (ComItextpdfXmpImplByteBuffer *)convertWithComItextpdfXmpImplByteBuffer:(ComItextpdfXmpImplByteBuffer *)buffer {
  
#line 87
  if ([@"UTF-8" isEqual:[((ComItextpdfXmpImplByteBuffer *) nil_chk(buffer)) getEncoding]]) {
    
#line 90
    IOSByteArray *readAheadBuffer = [IOSByteArray arrayWithLength:8];
    
#line 92
    jint readAhead = 0;
    
#line 94
    jint expectedBytes = 0;
    
#line 96
    ComItextpdfXmpImplByteBuffer *out = [[ComItextpdfXmpImplByteBuffer alloc] initWithInt:[buffer length] * 4 / 3];
    
#line 98
    jint state = ComItextpdfXmpImplLatin1Converter_STATE_START;
    for (jint i = 0; i < [buffer length]; i++) {
      
#line 101
      jint b = [buffer charAtWithInt:i];
      
#line 103
      switch (state) {
        
#line 105
        default:
        case ComItextpdfXmpImplLatin1Converter_STATE_START:
        if (b < (jint) 0x7F) {
          
#line 109
          [out appendWithByte:(jbyte) b];
        }
        else if (b >= (jint) 0xC0) {
          
#line 114
          expectedBytes = -1;
          jint test = b;
          for (; expectedBytes < 8 && (test & (jint) 0x80) == (jint) 0x80; test = LShift32(test, 1)) {
            
#line 118
            expectedBytes++;
          }
          *IOSByteArray_GetRef(readAheadBuffer, readAhead++) = (jbyte) b;
          state = ComItextpdfXmpImplLatin1Converter_STATE_UTF8CHAR;
        }
        else {
          
#line 126
          IOSByteArray *utf8 = [ComItextpdfXmpImplLatin1Converter convertToUTF8WithByte:(jbyte) b];
          [out appendWithByteArray:utf8];
        }
        break;
        
#line 131
        case ComItextpdfXmpImplLatin1Converter_STATE_UTF8CHAR:
        if (expectedBytes > 0 && (b & (jint) 0xC0) == (jint) 0x80) {
          
#line 135
          *IOSByteArray_GetRef(readAheadBuffer, readAhead++) = (jbyte) b;
          expectedBytes--;
          
#line 138
          if (expectedBytes == 0) {
            
#line 140
            [out appendWithByteArray:readAheadBuffer withInt:0 withInt:readAhead];
            readAhead = 0;
            
#line 143
            state = ComItextpdfXmpImplLatin1Converter_STATE_START;
          }
        }
        else {
          
#line 150
          IOSByteArray *utf8 = [ComItextpdfXmpImplLatin1Converter convertToUTF8WithByte:IOSByteArray_Get(readAheadBuffer, 0)];
          [out appendWithByteArray:utf8];
          
#line 154
          i = i - readAhead;
          readAhead = 0;
          
#line 157
          state = ComItextpdfXmpImplLatin1Converter_STATE_START;
        }
        break;
      }
    }
    
#line 164
    if (state == ComItextpdfXmpImplLatin1Converter_STATE_UTF8CHAR) {
      
#line 166
      for (jint j = 0; j < readAhead; j++) {
        
#line 168
        jbyte b = IOSByteArray_Get(readAheadBuffer, j);
        IOSByteArray *utf8 = [ComItextpdfXmpImplLatin1Converter convertToUTF8WithByte:b];
        [out appendWithByteArray:utf8];
      }
    }
    
#line 174
    return out;
  }
  else {
    
#line 179
    return buffer;
  }
}


#line 194
+ (IOSByteArray *)convertToUTF8WithByte:(jbyte)ch {
  
#line 196
  jint c = ch & (jint) 0xFF;
  @try {
    
#line 199
    if (c >= (jint) 0x80) {
      
#line 201
      if (c == (jint) 0x81 || c == (jint) 0x8D || c == (jint) 0x8F || c == (jint) 0x90 || c == (jint) 0x9D) {
        
#line 203
        return [IOSByteArray arrayWithBytes:(jbyte[]){ (jint) 0x20 } count:1];
      }
      
#line 207
      return [[NSString stringWithBytes:[IOSByteArray arrayWithBytes:(jbyte[]){ ch } count:1] charsetName:@"cp1252"] getBytesWithCharsetName:@"UTF-8"];
    }
  }
  @catch (JavaIoUnsupportedEncodingException *e) {
  }
  
#line 214
  return [IOSByteArray arrayWithBytes:(jbyte[]){ ch } count:1];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Latin1Converter", NULL, 0x2, NULL },
    { "convertWithComItextpdfXmpImplByteBuffer:", "convert", "Lcom.itextpdf.xmp.impl.ByteBuffer;", 0x9, NULL },
    { "convertToUTF8WithByte:", "convertToUTF8", "[B", 0xa, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "STATE_START_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplLatin1Converter_STATE_START },
    { "STATE_UTF8CHAR_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplLatin1Converter_STATE_UTF8CHAR },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplLatin1Converter = { "Latin1Converter", "com.itextpdf.xmp.impl", NULL, 0x1, 3, methods, 2, fields, 0, NULL};
  return &_ComItextpdfXmpImplLatin1Converter;
}

@end

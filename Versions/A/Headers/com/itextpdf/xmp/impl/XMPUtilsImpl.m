//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/XMPUtilsImpl.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/XMPUtilsImpl.java"

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "com/itextpdf/xmp/XMPConst.h"
#include "com/itextpdf/xmp/XMPError.h"
#include "com/itextpdf/xmp/XMPException.h"
#include "com/itextpdf/xmp/XMPMeta.h"
#include "com/itextpdf/xmp/XMPMetaFactory.h"
#include "com/itextpdf/xmp/XMPSchemaRegistry.h"
#include "com/itextpdf/xmp/impl/ParameterAsserts.h"
#include "com/itextpdf/xmp/impl/Utils.h"
#include "com/itextpdf/xmp/impl/XMPMetaImpl.h"
#include "com/itextpdf/xmp/impl/XMPNode.h"
#include "com/itextpdf/xmp/impl/XMPNodeUtils.h"
#include "com/itextpdf/xmp/impl/XMPUtilsImpl.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPath.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPathParser.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPathSegment.h"
#include "com/itextpdf/xmp/options/PropertyOptions.h"
#include "com/itextpdf/xmp/properties/XMPAliasInfo.h"
#include "java/lang/StringBuffer.h"
#include "java/util/Iterator.h"


#line 51
@implementation ComItextpdfXmpImplXMPUtilsImpl

NSString * ComItextpdfXmpImplXMPUtilsImpl_SPACES_ = 
#line 1151
@" \u3000\u303f";
NSString * ComItextpdfXmpImplXMPUtilsImpl_COMMAS_ = 
#line 1162
@",\uff0c\uff64\ufe50\ufe51\u3001\u060c\u055d";
NSString * ComItextpdfXmpImplXMPUtilsImpl_SEMICOLA_ = 
#line 1170
@";\uff1b\ufe54\u061b\u037e";
NSString * ComItextpdfXmpImplXMPUtilsImpl_QUOTES_ = 
#line 1184
@"\"\u00ab\u00bb\u301d\u301e\u301f\u2015\u2039\u203a";
NSString * ComItextpdfXmpImplXMPUtilsImpl_CONTROLS_ = 
#line 1191
@"\u2028\u2029";


#line 70
- (instancetype)init {
  return [super init];
}


#line 102
+ (NSString *)catenateArrayItemsWithComItextpdfXmpXMPMeta:(id<ComItextpdfXmpXMPMeta>)xmp
                                             withNSString:(NSString *)schemaNS
                                             withNSString:(NSString *)arrayName
                                             withNSString:(NSString *)separator
                                             withNSString:(NSString *)quotes
                                              withBoolean:(jboolean)allowCommas {
  
#line 105
  [ComItextpdfXmpImplParameterAsserts assertSchemaNSWithNSString:schemaNS];
  [ComItextpdfXmpImplParameterAsserts assertArrayNameWithNSString:arrayName];
  [ComItextpdfXmpImplParameterAsserts assertImplementationWithComItextpdfXmpXMPMeta:xmp];
  if (separator == nil || ((jint) [separator length]) == 0) {
    
#line 110
    separator = @"; ";
  }
  if (quotes == nil || ((jint) [quotes length]) == 0) {
    
#line 114
    quotes = @"\"";
  }
  
#line 117
  ComItextpdfXmpImplXMPMetaImpl *xmpImpl = (ComItextpdfXmpImplXMPMetaImpl *) check_class_cast(xmp, [ComItextpdfXmpImplXMPMetaImpl class]);
  ComItextpdfXmpImplXMPNode *arrayNode = nil;
  ComItextpdfXmpImplXMPNode *currItem = nil;
  
#line 123
  ComItextpdfXmpImplXpathXMPPath *arrayPath = [ComItextpdfXmpImplXpathXMPPathParser expandXPathWithNSString:schemaNS withNSString:arrayName];
  arrayNode = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmpImpl)) getRoot] withComItextpdfXmpImplXpathXMPPath:arrayPath withBoolean:NO withComItextpdfXmpOptionsPropertyOptions:nil];
  if (arrayNode == nil) {
    
#line 127
    return @"";
  }
  else if (![((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([arrayNode getOptions])) isArray] || [((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([arrayNode getOptions])) isArrayAlternate]) {
    
#line 131
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Named property must be non-alternate array" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
  
#line 135
  [ComItextpdfXmpImplXMPUtilsImpl checkSeparatorWithNSString:separator];
  
#line 137
  jchar openQuote = [((NSString *) nil_chk(quotes)) charAtWithInt:0];
  jchar closeQuote = [ComItextpdfXmpImplXMPUtilsImpl checkQuotesWithNSString:quotes withChar:openQuote];
  
#line 143
  JavaLangStringBuffer *catinatedString = [[JavaLangStringBuffer alloc] init];
  
#line 145
  for (id<JavaUtilIterator> it = [((ComItextpdfXmpImplXMPNode *) nil_chk(arrayNode)) iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
    
#line 147
    currItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(currItem)) getOptions])) isCompositeProperty]) {
      
#line 150
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Array items must be simple" withInt:ComItextpdfXmpXMPError_BADPARAM];
    }
    NSString *str = [ComItextpdfXmpImplXMPUtilsImpl applyQuotesWithNSString:[currItem getValue] withChar:openQuote withChar:closeQuote withBoolean:allowCommas];
    
#line 154
    (void) [catinatedString appendWithNSString:str];
    if ([it hasNext]) {
      
#line 157
      (void) [catinatedString appendWithNSString:separator];
    }
  }
  
#line 161
  return [catinatedString description];
}


#line 188
+ (void)separateArrayItemsWithComItextpdfXmpXMPMeta:(id<ComItextpdfXmpXMPMeta>)xmp
                                       withNSString:(NSString *)schemaNS
                                       withNSString:(NSString *)arrayName
                                       withNSString:(NSString *)catedStr
           withComItextpdfXmpOptionsPropertyOptions:(ComItextpdfXmpOptionsPropertyOptions *)arrayOptions
                                        withBoolean:(jboolean)preserveCommas {
  
#line 192
  [ComItextpdfXmpImplParameterAsserts assertSchemaNSWithNSString:schemaNS];
  [ComItextpdfXmpImplParameterAsserts assertArrayNameWithNSString:arrayName];
  if (catedStr == nil) {
    
#line 196
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Parameter must not be null" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
  [ComItextpdfXmpImplParameterAsserts assertImplementationWithComItextpdfXmpXMPMeta:xmp];
  ComItextpdfXmpImplXMPMetaImpl *xmpImpl = (ComItextpdfXmpImplXMPMetaImpl *) check_class_cast(xmp, [ComItextpdfXmpImplXMPMetaImpl class]);
  
#line 202
  ComItextpdfXmpImplXMPNode *arrayNode = [ComItextpdfXmpImplXMPUtilsImpl separateFindCreateArrayWithNSString:schemaNS withNSString:arrayName withComItextpdfXmpOptionsPropertyOptions:arrayOptions withComItextpdfXmpImplXMPMetaImpl:xmpImpl];
  
#line 205
  NSString *itemValue;
  jint itemStart, itemEnd;
  jint nextKind = ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL, charKind = ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL;
  jchar ch = 0, nextChar = 0;
  
#line 210
  itemEnd = 0;
  jint endPos = ((jint) [((NSString *) nil_chk(catedStr)) length]);
  while (itemEnd < endPos) {
    
#line 216
    for (itemStart = itemEnd; itemStart < endPos; itemStart++) {
      
#line 218
      ch = [catedStr charAtWithInt:itemStart];
      charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:ch];
      if (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL || charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
        
#line 222
        break;
      }
    }
    if (itemStart >= endPos) {
      
#line 227
      break;
    }
    
#line 230
    if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
      
#line 234
      for (itemEnd = itemStart; itemEnd < endPos; itemEnd++) {
        
#line 236
        ch = [catedStr charAtWithInt:itemEnd];
        charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:ch];
        
#line 239
        if (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL || charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE ||
#line 240
        (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_COMMA && preserveCommas)) {
          
#line 242
          continue;
        }
        else if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_SPACE) {
          
#line 246
          break;
        }
        else if ((itemEnd + 1) < endPos) {
          
#line 250
          ch = [catedStr charAtWithInt:itemEnd + 1];
          nextKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:ch];
          if (nextKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL || nextKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE ||
#line 253
          (nextKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_COMMA && preserveCommas)) {
            
#line 255
            continue;
          }
        }
        
#line 260
        break;
      }
      
#line 263
      itemValue = [catedStr substring:itemStart endIndex:itemEnd];
    }
    else {
      
#line 272
      jchar openQuote = ch;
      jchar closeQuote = [ComItextpdfXmpImplXMPUtilsImpl getClosingQuoteWithChar:openQuote];
      
#line 275
      itemStart++;
      itemValue = @"";
      
#line 278
      for (itemEnd = itemStart; itemEnd < endPos; itemEnd++) {
        
#line 280
        ch = [catedStr charAtWithInt:itemEnd];
        charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:ch];
        
#line 283
        if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE || ![ComItextpdfXmpImplXMPUtilsImpl isSurroundingQuoteWithChar:ch withChar:openQuote withChar:closeQuote]) {
          
#line 287
          itemValue = JreStrcat("$C", itemValue, ch);
        }
        else {
          
#line 297
          if ((itemEnd + 1) < endPos) {
            
#line 299
            nextChar = [catedStr charAtWithInt:itemEnd + 1];
            nextKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:nextChar];
          }
          else {
            
#line 304
            nextKind = ComItextpdfXmpImplXMPUtilsImpl_UCK_SEMICOLON;
            nextChar = (jint) 0x3B;
          }
          
#line 308
          if (ch == nextChar) {
            
#line 311
            itemValue = JreStrcat("$C", itemValue, ch);
            
#line 313
            itemEnd++;
          }
          else if (![ComItextpdfXmpImplXMPUtilsImpl isClosingingQuoteWithChar:ch withChar:openQuote withChar:closeQuote]) {
            
#line 318
            itemValue = JreStrcat("$C", itemValue, ch);
          }
          else {
            
#line 324
            itemEnd++;
            break;
          }
        }
      }
    }
    
#line 333
    jint foundIndex = -1;
    for (jint oldChild = 1; oldChild <= [((ComItextpdfXmpImplXMPNode *) nil_chk(arrayNode)) getChildrenLength]; oldChild++) {
      
#line 336
      if ([((NSString *) nil_chk(itemValue)) isEqual:[((ComItextpdfXmpImplXMPNode *) nil_chk([arrayNode getChildWithInt:oldChild])) getValue]]) {
        
#line 338
        foundIndex = oldChild;
        break;
      }
    }
    
#line 343
    ComItextpdfXmpImplXMPNode *newItem = nil;
    if (foundIndex < 0) {
      
#line 346
      newItem = [[ComItextpdfXmpImplXMPNode alloc] initWithNSString:ComItextpdfXmpXMPConst_get_ARRAY_ITEM_NAME_() withNSString:itemValue withComItextpdfXmpOptionsPropertyOptions:nil];
      [arrayNode addChildWithComItextpdfXmpImplXMPNode:newItem];
    }
  }
}


#line 362
+ (ComItextpdfXmpImplXMPNode *)separateFindCreateArrayWithNSString:(NSString *)schemaNS
                                                      withNSString:(NSString *)arrayName
                          withComItextpdfXmpOptionsPropertyOptions:(ComItextpdfXmpOptionsPropertyOptions *)arrayOptions
                                 withComItextpdfXmpImplXMPMetaImpl:(ComItextpdfXmpImplXMPMetaImpl *)xmp {
  
#line 365
  arrayOptions = [ComItextpdfXmpImplXMPNodeUtils verifySetOptionsWithComItextpdfXmpOptionsPropertyOptions:arrayOptions withId:nil];
  if (![((ComItextpdfXmpOptionsPropertyOptions *) nil_chk(arrayOptions)) isOnlyArrayOptions]) {
    
#line 368
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Options can only provide array form" withInt:ComItextpdfXmpXMPError_BADOPTIONS];
  }
  
#line 373
  ComItextpdfXmpImplXpathXMPPath *arrayPath = [ComItextpdfXmpImplXpathXMPPathParser expandXPathWithNSString:schemaNS withNSString:arrayName];
  ComItextpdfXmpImplXMPNode *arrayNode = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmp)) getRoot] withComItextpdfXmpImplXpathXMPPath:arrayPath withBoolean:NO withComItextpdfXmpOptionsPropertyOptions:nil];
  if (arrayNode != nil) {
    
#line 379
    ComItextpdfXmpOptionsPropertyOptions *arrayForm = [arrayNode getOptions];
    if (![((ComItextpdfXmpOptionsPropertyOptions *) nil_chk(arrayForm)) isArray] || [arrayForm isArrayAlternate]) {
      
#line 382
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Named property must be non-alternate array" withInt:
#line 383
      ComItextpdfXmpXMPError_BADXPATH];
    }
    if ([arrayOptions equalArrayTypesWithComItextpdfXmpOptionsPropertyOptions:arrayForm]) {
      
#line 387
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Mismatch of specified and existing array form" withInt:
#line 388
      ComItextpdfXmpXMPError_BADXPATH];
    }
  }
  else {
    
#line 395
    arrayNode = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:[xmp getRoot] withComItextpdfXmpImplXpathXMPPath:arrayPath withBoolean:YES withComItextpdfXmpOptionsPropertyOptions:[arrayOptions setArrayWithBoolean:
#line 396
    YES]];
    if (arrayNode == nil) {
      
#line 399
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Failed to create named array" withInt:ComItextpdfXmpXMPError_BADXPATH];
    }
  }
  return arrayNode;
}


#line 427
+ (void)removePropertiesWithComItextpdfXmpXMPMeta:(id<ComItextpdfXmpXMPMeta>)xmp
                                     withNSString:(NSString *)schemaNS
                                     withNSString:(NSString *)propName
                                      withBoolean:(jboolean)doAllProperties
                                      withBoolean:(jboolean)includeAliases {
  
#line 430
  [ComItextpdfXmpImplParameterAsserts assertImplementationWithComItextpdfXmpXMPMeta:xmp];
  ComItextpdfXmpImplXMPMetaImpl *xmpImpl = (ComItextpdfXmpImplXMPMetaImpl *) check_class_cast(xmp, [ComItextpdfXmpImplXMPMetaImpl class]);
  
#line 433
  if (propName != nil && ((jint) [propName length]) > 0) {
    
#line 439
    if (schemaNS == nil || ((jint) [schemaNS length]) == 0) {
      
#line 441
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Property name requires schema namespace" withInt:
#line 442
      ComItextpdfXmpXMPError_BADPARAM];
    }
    
#line 445
    ComItextpdfXmpImplXpathXMPPath *expPath = [ComItextpdfXmpImplXpathXMPPathParser expandXPathWithNSString:schemaNS withNSString:propName];
    
#line 447
    ComItextpdfXmpImplXMPNode *propNode = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmpImpl)) getRoot] withComItextpdfXmpImplXpathXMPPath:expPath withBoolean:NO withComItextpdfXmpOptionsPropertyOptions:nil];
    if (propNode != nil) {
      
#line 450
      if (doAllProperties ||
#line 451
      ![ComItextpdfXmpImplUtils isInternalPropertyWithNSString:[((ComItextpdfXmpImplXpathXMPPathSegment *) nil_chk([((ComItextpdfXmpImplXpathXMPPath *) nil_chk(expPath)) getSegmentWithInt:ComItextpdfXmpImplXpathXMPPath_STEP_SCHEMA])) getName] withNSString:
#line 452
      [((ComItextpdfXmpImplXpathXMPPathSegment *) nil_chk([expPath getSegmentWithInt:ComItextpdfXmpImplXpathXMPPath_STEP_ROOT_PROP])) getName]]) {
        
#line 454
        ComItextpdfXmpImplXMPNode *parent = [propNode getParent];
        [((ComItextpdfXmpImplXMPNode *) nil_chk(parent)) removeChildWithComItextpdfXmpImplXMPNode:propNode];
        if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([parent getOptions])) isSchemaNode] && ![parent hasChildren]) {
          
#line 459
          [((ComItextpdfXmpImplXMPNode *) nil_chk([parent getParent])) removeChildWithComItextpdfXmpImplXMPNode:parent];
        }
      }
    }
  }
  else
#line 465
  if (schemaNS != nil && ((jint) [schemaNS length]) > 0) {
    
#line 473
    ComItextpdfXmpImplXMPNode *schemaNode = [ComItextpdfXmpImplXMPNodeUtils findSchemaNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmpImpl)) getRoot] withNSString:schemaNS withBoolean:NO];
    if (schemaNode != nil) {
      
#line 476
      if ([ComItextpdfXmpImplXMPUtilsImpl removeSchemaChildrenWithComItextpdfXmpImplXMPNode:schemaNode withBoolean:doAllProperties]) {
        
#line 478
        [((ComItextpdfXmpImplXMPNode *) nil_chk([xmpImpl getRoot])) removeChildWithComItextpdfXmpImplXMPNode:schemaNode];
      }
    }
    
#line 482
    if (includeAliases) {
      
#line 490
      IOSObjectArray *aliases = [((id<ComItextpdfXmpXMPSchemaRegistry>) nil_chk([ComItextpdfXmpXMPMetaFactory getSchemaRegistry])) findAliasesWithNSString:schemaNS];
      for (jint i = 0; i < ((IOSObjectArray *) nil_chk(aliases))->size_; i++) {
        
#line 493
        id<ComItextpdfXmpPropertiesXMPAliasInfo> info = IOSObjectArray_Get(aliases, i);
        ComItextpdfXmpImplXpathXMPPath *path = [ComItextpdfXmpImplXpathXMPPathParser expandXPathWithNSString:[((id<ComItextpdfXmpPropertiesXMPAliasInfo>) nil_chk(info)) getNamespace] withNSString:[info getPropName]];
        
#line 496
        ComItextpdfXmpImplXMPNode *actualProp = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:
#line 497
        [xmpImpl getRoot] withComItextpdfXmpImplXpathXMPPath:path withBoolean:NO withComItextpdfXmpOptionsPropertyOptions:nil];
        if (actualProp != nil) {
          
#line 500
          ComItextpdfXmpImplXMPNode *parent = [actualProp getParent];
          [((ComItextpdfXmpImplXMPNode *) nil_chk(parent)) removeChildWithComItextpdfXmpImplXMPNode:actualProp];
        }
      }
    }
  }
  else {
    
#line 512
    for (id<JavaUtilIterator> it = [((ComItextpdfXmpImplXMPNode *) nil_chk([((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmpImpl)) getRoot])) iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
      
#line 514
      ComItextpdfXmpImplXMPNode *schema = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
      if ([ComItextpdfXmpImplXMPUtilsImpl removeSchemaChildrenWithComItextpdfXmpImplXMPNode:schema withBoolean:doAllProperties]) {
        
#line 517
        [it remove];
      }
    }
  }
}


#line 533
+ (void)appendPropertiesWithComItextpdfXmpXMPMeta:(id<ComItextpdfXmpXMPMeta>)source
                        withComItextpdfXmpXMPMeta:(id<ComItextpdfXmpXMPMeta>)destination
                                      withBoolean:(jboolean)doAllProperties
                                      withBoolean:(jboolean)replaceOldValues
                                      withBoolean:(jboolean)deleteEmptyValues {
  
#line 537
  [ComItextpdfXmpImplParameterAsserts assertImplementationWithComItextpdfXmpXMPMeta:source];
  [ComItextpdfXmpImplParameterAsserts assertImplementationWithComItextpdfXmpXMPMeta:destination];
  
#line 540
  ComItextpdfXmpImplXMPMetaImpl *src = (ComItextpdfXmpImplXMPMetaImpl *) check_class_cast(source, [ComItextpdfXmpImplXMPMetaImpl class]);
  ComItextpdfXmpImplXMPMetaImpl *dest = (ComItextpdfXmpImplXMPMetaImpl *) check_class_cast(destination, [ComItextpdfXmpImplXMPMetaImpl class]);
  
#line 543
  for (id<JavaUtilIterator> it = [((ComItextpdfXmpImplXMPNode *) nil_chk([((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(src)) getRoot])) iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
    
#line 545
    ComItextpdfXmpImplXMPNode *sourceSchema = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
    
#line 548
    ComItextpdfXmpImplXMPNode *destSchema = [ComItextpdfXmpImplXMPNodeUtils findSchemaNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(dest)) getRoot] withNSString:
#line 549
    [((ComItextpdfXmpImplXMPNode *) nil_chk(sourceSchema)) getName] withBoolean:NO];
    jboolean createdSchema = NO;
    if (destSchema == nil) {
      
#line 553
      destSchema = [[ComItextpdfXmpImplXMPNode alloc] initWithNSString:[sourceSchema getName] withNSString:[sourceSchema getValue] withComItextpdfXmpOptionsPropertyOptions:
#line 554
      [((ComItextpdfXmpOptionsPropertyOptions *) [[ComItextpdfXmpOptionsPropertyOptions alloc] init]) setSchemaNodeWithBoolean:YES]];
      [((ComItextpdfXmpImplXMPNode *) nil_chk([dest getRoot])) addChildWithComItextpdfXmpImplXMPNode:destSchema];
      createdSchema = YES;
    }
    
#line 560
    for (id<JavaUtilIterator> ic = [sourceSchema iterateChildren]; [((id<JavaUtilIterator>) nil_chk(ic)) hasNext]; ) {
      
#line 562
      ComItextpdfXmpImplXMPNode *sourceProp = (ComItextpdfXmpImplXMPNode *) check_class_cast([ic next], [ComItextpdfXmpImplXMPNode class]);
      if (doAllProperties ||
#line 564
      ![ComItextpdfXmpImplUtils isInternalPropertyWithNSString:[sourceSchema getName] withNSString:[((ComItextpdfXmpImplXMPNode *) nil_chk(sourceProp)) getName]]) {
        
#line 566
        [ComItextpdfXmpImplXMPUtilsImpl appendSubtreeWithComItextpdfXmpImplXMPMetaImpl:
#line 567
        dest withComItextpdfXmpImplXMPNode:sourceProp withComItextpdfXmpImplXMPNode:destSchema withBoolean:replaceOldValues withBoolean:deleteEmptyValues];
      }
    }
    
#line 571
    if (![((ComItextpdfXmpImplXMPNode *) nil_chk(destSchema)) hasChildren] && (createdSchema || deleteEmptyValues)) {
      
#line 574
      [((ComItextpdfXmpImplXMPNode *) nil_chk([dest getRoot])) removeChildWithComItextpdfXmpImplXMPNode:destSchema];
    }
  }
}


#line 591
+ (jboolean)removeSchemaChildrenWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)schemaNode
                                                  withBoolean:(jboolean)doAllProperties {
  for (id<JavaUtilIterator> it = [((ComItextpdfXmpImplXMPNode *) nil_chk(schemaNode)) iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
    
#line 595
    ComItextpdfXmpImplXMPNode *currProp = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
    if (doAllProperties ||
#line 597
    ![ComItextpdfXmpImplUtils isInternalPropertyWithNSString:[schemaNode getName] withNSString:[((ComItextpdfXmpImplXMPNode *) nil_chk(currProp)) getName]]) {
      
#line 599
      [it remove];
    }
  }
  
#line 603
  return ![schemaNode hasChildren];
}


#line 617
+ (void)appendSubtreeWithComItextpdfXmpImplXMPMetaImpl:(ComItextpdfXmpImplXMPMetaImpl *)destXMP
                         withComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)sourceNode
                         withComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)destParent
                                           withBoolean:(jboolean)replaceOldValues
                                           withBoolean:(jboolean)deleteEmptyValues {
  
#line 620
  ComItextpdfXmpImplXMPNode *destNode = [ComItextpdfXmpImplXMPNodeUtils findChildNodeWithComItextpdfXmpImplXMPNode:destParent withNSString:[((ComItextpdfXmpImplXMPNode *) nil_chk(sourceNode)) getName] withBoolean:NO];
  
#line 622
  jboolean valueIsEmpty = NO;
  if (deleteEmptyValues) {
    
#line 625
    valueIsEmpty = [((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([sourceNode getOptions])) isSimple] ?
#line 626
    [sourceNode getValue] == nil || ((jint) [((NSString *) nil_chk([sourceNode getValue])) length]) == 0 :
#line 627
    ![sourceNode hasChildren];
  }
  
#line 630
  if (deleteEmptyValues && valueIsEmpty) {
    
#line 632
    if (destNode != nil) {
      
#line 634
      [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) removeChildWithComItextpdfXmpImplXMPNode:destNode];
    }
  }
  else if (destNode == nil) {
    
#line 640
    [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) addChildWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *) check_class_cast([sourceNode clone], [ComItextpdfXmpImplXMPNode class])];
  }
  else if (replaceOldValues) {
    
#line 645
    [((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(destXMP)) setNodeWithComItextpdfXmpImplXMPNode:destNode withId:[sourceNode getValue] withComItextpdfXmpOptionsPropertyOptions:[sourceNode getOptions] withBoolean:YES];
    [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) removeChildWithComItextpdfXmpImplXMPNode:destNode];
    destNode = (ComItextpdfXmpImplXMPNode *) check_class_cast([sourceNode clone], [ComItextpdfXmpImplXMPNode class]);
    [destParent addChildWithComItextpdfXmpImplXMPNode:destNode];
  }
  else {
    
#line 655
    ComItextpdfXmpOptionsPropertyOptions *sourceForm = [sourceNode getOptions];
    ComItextpdfXmpOptionsPropertyOptions *destForm = [destNode getOptions];
    if (sourceForm != destForm) {
      
#line 659
      return;
    }
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk(sourceForm)) isStruct]) {
      
#line 666
      for (id<JavaUtilIterator> it = [sourceNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
        
#line 668
        ComItextpdfXmpImplXMPNode *sourceField = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
        [ComItextpdfXmpImplXMPUtilsImpl appendSubtreeWithComItextpdfXmpImplXMPMetaImpl:destXMP withComItextpdfXmpImplXMPNode:sourceField withComItextpdfXmpImplXMPNode:destNode withBoolean:
#line 670
        replaceOldValues withBoolean:deleteEmptyValues];
        if (deleteEmptyValues && ![destNode hasChildren]) {
          
#line 673
          [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) removeChildWithComItextpdfXmpImplXMPNode:destNode];
        }
      }
    }
    else if ([sourceForm isArrayAltText]) {
      
#line 682
      for (id<JavaUtilIterator> it = [sourceNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
        
#line 684
        ComItextpdfXmpImplXMPNode *sourceItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
        if (![((ComItextpdfXmpImplXMPNode *) nil_chk(sourceItem)) hasQualifier] ||
#line 686
        ![((NSString *) nil_chk(ComItextpdfXmpXMPConst_get_XML_LANG_())) isEqual:[((ComItextpdfXmpImplXMPNode *) nil_chk([sourceItem getQualifierWithInt:1])) getName]]) {
          
#line 688
          continue;
        }
        
#line 691
        jint destIndex = [ComItextpdfXmpImplXMPNodeUtils lookupLanguageItemWithComItextpdfXmpImplXMPNode:destNode withNSString:
#line 692
        [((ComItextpdfXmpImplXMPNode *) nil_chk([sourceItem getQualifierWithInt:1])) getValue]];
        if (deleteEmptyValues &&
#line 694
        ([sourceItem getValue] == nil ||
#line 695
        ((jint) [((NSString *) nil_chk([sourceItem getValue])) length]) == 0)) {
          
#line 697
          if (destIndex != -1) {
            
#line 699
            [destNode removeChildWithInt:destIndex];
            if (![destNode hasChildren]) {
              
#line 702
              [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) removeChildWithComItextpdfXmpImplXMPNode:destNode];
            }
          }
        }
        else if (destIndex == -1) {
          
#line 709
          if (![((NSString *) nil_chk(ComItextpdfXmpXMPConst_get_X_DEFAULT_())) isEqual:[((ComItextpdfXmpImplXMPNode *) nil_chk([sourceItem getQualifierWithInt:1])) getValue]] ||
#line 710
          ![destNode hasChildren]) {
            
#line 712
            [sourceItem cloneSubtreeWithComItextpdfXmpImplXMPNode:destNode];
          }
          else {
            
#line 716
            ComItextpdfXmpImplXMPNode *destItem = [[ComItextpdfXmpImplXMPNode alloc] initWithNSString:
#line 717
            [sourceItem getName] withNSString:
#line 718
            [sourceItem getValue] withComItextpdfXmpOptionsPropertyOptions:
#line 719
            [sourceItem getOptions]];
            [sourceItem cloneSubtreeWithComItextpdfXmpImplXMPNode:destItem];
            [destNode addChildWithInt:1 withComItextpdfXmpImplXMPNode:destItem];
          }
        }
      }
    }
    else if ([sourceForm isArray]) {
      
#line 732
      for (id<JavaUtilIterator> is = [sourceNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(is)) hasNext]; ) {
        
#line 734
        ComItextpdfXmpImplXMPNode *sourceItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([is next], [ComItextpdfXmpImplXMPNode class]);
        
#line 736
        jboolean match = NO;
        for (id<JavaUtilIterator> id_ = [destNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(id_)) hasNext]; ) {
          
#line 739
          ComItextpdfXmpImplXMPNode *destItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([id_ next], [ComItextpdfXmpImplXMPNode class]);
          if ([ComItextpdfXmpImplXMPUtilsImpl itemValuesMatchWithComItextpdfXmpImplXMPNode:sourceItem withComItextpdfXmpImplXMPNode:destItem]) {
            
#line 742
            match = YES;
          }
        }
        if (!match) {
          
#line 747
          destNode = (ComItextpdfXmpImplXMPNode *) check_class_cast([((ComItextpdfXmpImplXMPNode *) nil_chk(sourceItem)) clone], [ComItextpdfXmpImplXMPNode class]);
          [((ComItextpdfXmpImplXMPNode *) nil_chk(destParent)) addChildWithComItextpdfXmpImplXMPNode:destNode];
        }
      }
    }
  }
}


#line 763
+ (jboolean)itemValuesMatchWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)leftNode
                           withComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)rightNode {
  
#line 765
  ComItextpdfXmpOptionsPropertyOptions *leftForm = [((ComItextpdfXmpImplXMPNode *) nil_chk(leftNode)) getOptions];
  ComItextpdfXmpOptionsPropertyOptions *rightForm = [((ComItextpdfXmpImplXMPNode *) nil_chk(rightNode)) getOptions];
  
#line 768
  if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk(leftForm)) isEqual:rightForm]) {
    
#line 770
    return NO;
  }
  
#line 773
  if ([leftForm getOptions] == 0) {
    
#line 776
    if (![((NSString *) nil_chk([leftNode getValue])) isEqual:[rightNode getValue]]) {
      
#line 778
      return NO;
    }
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([leftNode getOptions])) getHasLanguage] != [((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([rightNode getOptions])) getHasLanguage]) {
      
#line 782
      return NO;
    }
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([leftNode getOptions])) getHasLanguage] &&
#line 785
    ![((NSString *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk([leftNode getQualifierWithInt:1])) getValue])) isEqual:
#line 786
    [((ComItextpdfXmpImplXMPNode *) nil_chk([rightNode getQualifierWithInt:1])) getValue]]) {
      
#line 788
      return NO;
    }
  }
  else if ([leftForm isStruct]) {
    
#line 795
    if ([leftNode getChildrenLength] != [rightNode getChildrenLength]) {
      
#line 797
      return NO;
    }
    
#line 800
    for (id<JavaUtilIterator> it = [leftNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
      
#line 802
      ComItextpdfXmpImplXMPNode *leftField = (ComItextpdfXmpImplXMPNode *) check_class_cast([it next], [ComItextpdfXmpImplXMPNode class]);
      ComItextpdfXmpImplXMPNode *rightField = [ComItextpdfXmpImplXMPNodeUtils findChildNodeWithComItextpdfXmpImplXMPNode:rightNode withNSString:[((ComItextpdfXmpImplXMPNode *) nil_chk(leftField)) getName] withBoolean:
#line 804
      NO];
      if (rightField == nil || ![ComItextpdfXmpImplXMPUtilsImpl itemValuesMatchWithComItextpdfXmpImplXMPNode:leftField withComItextpdfXmpImplXMPNode:rightField]) {
        
#line 807
        return NO;
      }
    }
  }
  else {
    
#line 818
    NSAssert([leftForm isArray], @"com/itextpdf/xmp/impl/XMPUtilsImpl.java:818 condition failed: assert leftForm.isArray();");
    
#line 820
    for (id<JavaUtilIterator> il = [leftNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(il)) hasNext]; ) {
      
#line 822
      ComItextpdfXmpImplXMPNode *leftItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([il next], [ComItextpdfXmpImplXMPNode class]);
      
#line 824
      jboolean match = NO;
      for (id<JavaUtilIterator> ir = [rightNode iterateChildren]; [((id<JavaUtilIterator>) nil_chk(ir)) hasNext]; ) {
        
#line 827
        ComItextpdfXmpImplXMPNode *rightItem = (ComItextpdfXmpImplXMPNode *) check_class_cast([ir next], [ComItextpdfXmpImplXMPNode class]);
        if ([ComItextpdfXmpImplXMPUtilsImpl itemValuesMatchWithComItextpdfXmpImplXMPNode:leftItem withComItextpdfXmpImplXMPNode:rightItem]) {
          
#line 830
          match = YES;
          break;
        }
      }
      if (!match) {
        
#line 836
        return NO;
      }
    }
  }
  return YES;
}


#line 852
+ (void)checkSeparatorWithNSString:(NSString *)separator {
  
#line 854
  jboolean haveSemicolon = NO;
  for (jint i = 0; i < ((jint) [((NSString *) nil_chk(separator)) length]); i++) {
    
#line 857
    jint charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:[separator charAtWithInt:i]];
    if (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_SEMICOLON) {
      
#line 860
      if (haveSemicolon) {
        
#line 862
        @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Separator can have only one semicolon" withInt:
#line 863
        ComItextpdfXmpXMPError_BADPARAM];
      }
      haveSemicolon = YES;
    }
    else if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_SPACE) {
      
#line 869
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Separator can have only spaces and one semicolon" withInt:
#line 870
      ComItextpdfXmpXMPError_BADPARAM];
    }
  }
  if (!haveSemicolon) {
    
#line 875
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Separator must have one semicolon" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
}


#line 891
+ (jchar)checkQuotesWithNSString:(NSString *)quotes
                        withChar:(jchar)openQuote {
  
#line 893
  jchar closeQuote;
  
#line 895
  jint charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:openQuote];
  if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
    
#line 898
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid quoting character" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
  
#line 901
  if (((jint) [((NSString *) nil_chk(quotes)) length]) == 1) {
    
#line 903
    closeQuote = openQuote;
  }
  else {
    
#line 907
    closeQuote = [quotes charAtWithInt:1];
    charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:closeQuote];
    if (charKind != ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
      
#line 911
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Invalid quoting character" withInt:ComItextpdfXmpXMPError_BADPARAM];
    }
  }
  
#line 915
  if (closeQuote != [ComItextpdfXmpImplXMPUtilsImpl getClosingQuoteWithChar:openQuote]) {
    
#line 917
    @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Mismatched quote pair" withInt:ComItextpdfXmpXMPError_BADPARAM];
  }
  return closeQuote;
}


#line 931
+ (jint)classifyCharacterWithChar:(jchar)ch {
  
#line 933
  if ([((NSString *) nil_chk(ComItextpdfXmpImplXMPUtilsImpl_SPACES_)) indexOf:ch] >= 0 || ((jint) 0x2000 <= ch && ch <= (jint) 0x200B)) {
    
#line 935
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_SPACE;
  }
  else if ([((NSString *) nil_chk(ComItextpdfXmpImplXMPUtilsImpl_COMMAS_)) indexOf:ch] >= 0) {
    
#line 939
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_COMMA;
  }
  else if ([((NSString *) nil_chk(ComItextpdfXmpImplXMPUtilsImpl_SEMICOLA_)) indexOf:ch] >= 0) {
    
#line 943
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_SEMICOLON;
  }
  else if ([((NSString *) nil_chk(ComItextpdfXmpImplXMPUtilsImpl_QUOTES_)) indexOf:ch] >= 0 || ((jint) 0x3008 <= ch && ch <= (jint) 0x300F) ||
#line 946
  ((jint) 0x2018 <= ch && ch <= (jint) 0x201F)) {
    
#line 948
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE;
  }
  else if (ch < (jint) 0x0020 || [((NSString *) nil_chk(ComItextpdfXmpImplXMPUtilsImpl_CONTROLS_)) indexOf:ch] >= 0) {
    
#line 952
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_CONTROL;
  }
  else {
    
#line 957
    return ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL;
  }
}


#line 967
+ (jchar)getClosingQuoteWithChar:(jchar)openQuote {
  
#line 969
  switch (openQuote) {
    
#line 971
    case (jint) 0x0022:
    return (jint) 0x0022;
    
#line 976
    case (jint) 0x00AB:
    return (jint) 0x00BB;
    case (jint) 0x00BB:
    return (jint) 0x00AB;
    case (jint) 0x2015:
    return (jint) 0x2015;
    case (jint) 0x2018:
    return (jint) 0x2019;
    case (jint) 0x201A:
    return (jint) 0x201B;
    case (jint) 0x201C:
    return (jint) 0x201D;
    case (jint) 0x201E:
    return (jint) 0x201F;
    case (jint) 0x2039:
    return (jint) 0x203A;
    case (jint) 0x203A:
    return (jint) 0x2039;
    case (jint) 0x3008:
    return (jint) 0x3009;
    case (jint) 0x300A:
    return (jint) 0x300B;
    case (jint) 0x300C:
    return (jint) 0x300D;
    case (jint) 0x300E:
    return (jint) 0x300F;
    case (jint) 0x301D:
    return (jint) 0x301F;
    default:
    return 0;
  }
}


#line 1023
+ (NSString *)applyQuotesWithNSString:(NSString *)item
                             withChar:(jchar)openQuote
                             withChar:(jchar)closeQuote
                          withBoolean:(jboolean)allowCommas {
  
#line 1026
  if (item == nil) {
    
#line 1028
    item = @"";
  }
  
#line 1031
  jboolean prevSpace = NO;
  jint charOffset;
  jint charKind;
  
#line 1048
  jint i;
  for (i = 0; i < ((jint) [((NSString *) nil_chk(item)) length]); i++) {
    
#line 1051
    jchar ch = [item charAtWithInt:i];
    charKind = [ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:ch];
    if (i == 0 && charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
      
#line 1055
      break;
    }
    
#line 1058
    if (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_SPACE) {
      
#line 1061
      if (prevSpace) {
        
#line 1063
        break;
      }
      prevSpace = YES;
    }
    else {
      
#line 1069
      prevSpace = NO;
      if ((charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_SEMICOLON || charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_CONTROL) ||
#line 1071
      (charKind == ComItextpdfXmpImplXMPUtilsImpl_UCK_COMMA && !allowCommas)) {
        
#line 1073
        break;
      }
    }
  }
  
#line 1079
  if (i < ((jint) [item length])) {
    
#line 1088
    JavaLangStringBuffer *newItem = [[JavaLangStringBuffer alloc] initWithInt:((jint) [item length]) + 2];
    jint splitPoint;
    for (splitPoint = 0; splitPoint <= i; splitPoint++) {
      
#line 1092
      if ([ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:[item charAtWithInt:i]] == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE) {
        
#line 1094
        break;
      }
    }
    
#line 1099
    (void) [((JavaLangStringBuffer *) nil_chk([newItem appendWithChar:openQuote])) appendWithNSString:[item substring:0 endIndex:splitPoint]];
    
#line 1101
    for (charOffset = splitPoint; charOffset < ((jint) [item length]); charOffset++) {
      
#line 1103
      (void) [newItem appendWithChar:[item charAtWithInt:charOffset]];
      if ([ComItextpdfXmpImplXMPUtilsImpl classifyCharacterWithChar:[item charAtWithInt:charOffset]] == ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE &&
#line 1105
      [ComItextpdfXmpImplXMPUtilsImpl isSurroundingQuoteWithChar:[item charAtWithInt:charOffset] withChar:openQuote withChar:closeQuote]) {
        
#line 1107
        (void) [newItem appendWithChar:[item charAtWithInt:charOffset]];
      }
    }
    
#line 1111
    (void) [newItem appendWithChar:closeQuote];
    
#line 1113
    item = [newItem description];
  }
  
#line 1116
  return item;
}


#line 1126
+ (jboolean)isSurroundingQuoteWithChar:(jchar)ch
                              withChar:(jchar)openQuote
                              withChar:(jchar)closeQuote {
  
#line 1128
  return ch == openQuote || [ComItextpdfXmpImplXMPUtilsImpl isClosingingQuoteWithChar:ch withChar:openQuote withChar:closeQuote];
}


#line 1138
+ (jboolean)isClosingingQuoteWithChar:(jchar)ch
                             withChar:(jchar)openQuote
                             withChar:(jchar)closeQuote {
  
#line 1140
  return ch == closeQuote || ((openQuote == (jint) 0x301D && ch == (jint) 0x301E) || ch == (jint) 0x301F);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "XMPUtilsImpl", NULL, 0x2, NULL },
    { "catenateArrayItemsWithComItextpdfXmpXMPMeta:withNSString:withNSString:withNSString:withNSString:withBoolean:", "catenateArrayItems", "Ljava.lang.String;", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "separateArrayItemsWithComItextpdfXmpXMPMeta:withNSString:withNSString:withNSString:withComItextpdfXmpOptionsPropertyOptions:withBoolean:", "separateArrayItems", "V", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "separateFindCreateArrayWithNSString:withNSString:withComItextpdfXmpOptionsPropertyOptions:withComItextpdfXmpImplXMPMetaImpl:", "separateFindCreateArray", "Lcom.itextpdf.xmp.impl.XMPNode;", 0xa, "Lcom.itextpdf.xmp.XMPException;" },
    { "removePropertiesWithComItextpdfXmpXMPMeta:withNSString:withNSString:withBoolean:withBoolean:", "removeProperties", "V", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "appendPropertiesWithComItextpdfXmpXMPMeta:withComItextpdfXmpXMPMeta:withBoolean:withBoolean:withBoolean:", "appendProperties", "V", 0x9, "Lcom.itextpdf.xmp.XMPException;" },
    { "removeSchemaChildrenWithComItextpdfXmpImplXMPNode:withBoolean:", "removeSchemaChildren", "Z", 0xa, NULL },
    { "appendSubtreeWithComItextpdfXmpImplXMPMetaImpl:withComItextpdfXmpImplXMPNode:withComItextpdfXmpImplXMPNode:withBoolean:withBoolean:", "appendSubtree", "V", 0xa, "Lcom.itextpdf.xmp.XMPException;" },
    { "itemValuesMatchWithComItextpdfXmpImplXMPNode:withComItextpdfXmpImplXMPNode:", "itemValuesMatch", "Z", 0xa, "Lcom.itextpdf.xmp.XMPException;" },
    { "checkSeparatorWithNSString:", "checkSeparator", "V", 0xa, "Lcom.itextpdf.xmp.XMPException;" },
    { "checkQuotesWithNSString:withChar:", "checkQuotes", "C", 0xa, "Lcom.itextpdf.xmp.XMPException;" },
    { "classifyCharacterWithChar:", "classifyCharacter", "I", 0xa, NULL },
    { "getClosingQuoteWithChar:", "getClosingQuote", "C", 0xa, NULL },
    { "applyQuotesWithNSString:withChar:withChar:withBoolean:", "applyQuotes", "Ljava.lang.String;", 0xa, NULL },
    { "isSurroundingQuoteWithChar:withChar:withChar:", "isSurroundingQuote", "Z", 0xa, NULL },
    { "isClosingingQuoteWithChar:withChar:withChar:", "isClosingingQuote", "Z", 0xa, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "UCK_NORMAL_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_NORMAL },
    { "UCK_SPACE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_SPACE },
    { "UCK_COMMA_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_COMMA },
    { "UCK_SEMICOLON_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_SEMICOLON },
    { "UCK_QUOTE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_QUOTE },
    { "UCK_CONTROL_", NULL, 0x1a, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPUtilsImpl_UCK_CONTROL },
    { "SPACES_", NULL, 0x1a, "Ljava.lang.String;", &ComItextpdfXmpImplXMPUtilsImpl_SPACES_,  },
    { "COMMAS_", NULL, 0x1a, "Ljava.lang.String;", &ComItextpdfXmpImplXMPUtilsImpl_COMMAS_,  },
    { "SEMICOLA_", NULL, 0x1a, "Ljava.lang.String;", &ComItextpdfXmpImplXMPUtilsImpl_SEMICOLA_,  },
    { "QUOTES_", NULL, 0x1a, "Ljava.lang.String;", &ComItextpdfXmpImplXMPUtilsImpl_QUOTES_,  },
    { "CONTROLS_", NULL, 0x1a, "Ljava.lang.String;", &ComItextpdfXmpImplXMPUtilsImpl_CONTROLS_,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplXMPUtilsImpl = { "XMPUtilsImpl", "com.itextpdf.xmp.impl", NULL, 0x1, 16, methods, 11, fields, 0, NULL};
  return &_ComItextpdfXmpImplXMPUtilsImpl;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/XMPIteratorImpl.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/XMPIteratorImpl.java"

#include "IOSClass.h"
#include "com/itextpdf/xmp/XMPError.h"
#include "com/itextpdf/xmp/XMPException.h"
#include "com/itextpdf/xmp/XMPMetaFactory.h"
#include "com/itextpdf/xmp/XMPSchemaRegistry.h"
#include "com/itextpdf/xmp/impl/QName.h"
#include "com/itextpdf/xmp/impl/XMPIteratorImpl.h"
#include "com/itextpdf/xmp/impl/XMPMetaImpl.h"
#include "com/itextpdf/xmp/impl/XMPNode.h"
#include "com/itextpdf/xmp/impl/XMPNodeUtils.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPath.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPathParser.h"
#include "com/itextpdf/xmp/impl/xpath/XMPPathSegment.h"
#include "com/itextpdf/xmp/options/IteratorOptions.h"
#include "com/itextpdf/xmp/options/PropertyOptions.h"
#include "com/itextpdf/xmp/properties/XMPPropertyInfo.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Collections.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/NoSuchElementException.h"


#line 57
@implementation ComItextpdfXmpImplXMPIteratorImpl


#line 80
- (instancetype)initWithComItextpdfXmpImplXMPMetaImpl:(ComItextpdfXmpImplXMPMetaImpl *)xmp
                                         withNSString:(NSString *)schemaNS
                                         withNSString:(NSString *)propPath
             withComItextpdfXmpOptionsIteratorOptions:(ComItextpdfXmpOptionsIteratorOptions *)options {
  if (self = [super init]) {
    baseNS_ =
#line 62
    nil;
    skipSiblings__ =
#line 64
    NO;
    skipSubtree__ =
#line 66
    NO;
    nodeIterator_ =
#line 68
    nil;
    
#line 84
    self->options_ = options != nil ? options : [[ComItextpdfXmpOptionsIteratorOptions alloc] init];
    
#line 87
    ComItextpdfXmpImplXMPNode *startNode = nil;
    
#line 88
    NSString *initialPath = nil;
    
#line 89
    jboolean baseSchema = schemaNS != nil && ((jint) [schemaNS length]) > 0;
    
#line 90
    jboolean baseProperty = propPath != nil && ((jint) [propPath length]) > 0;
    
#line 92
    if (!baseSchema && !baseProperty) {
      
#line 95
      startNode = [((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmp)) getRoot];
    }
    else if (baseSchema && baseProperty) {
      
#line 100
      ComItextpdfXmpImplXpathXMPPath *path = [ComItextpdfXmpImplXpathXMPPathParser expandXPathWithNSString:schemaNS withNSString:propPath];
      
#line 103
      ComItextpdfXmpImplXpathXMPPath *basePath = [[ComItextpdfXmpImplXpathXMPPath alloc] init];
      for (jint i = 0; i < [((ComItextpdfXmpImplXpathXMPPath *) nil_chk(path)) size] - 1; i++) {
        
#line 106
        [basePath addWithComItextpdfXmpImplXpathXMPPathSegment:[path getSegmentWithInt:i]];
      }
      
#line 109
      startNode = [ComItextpdfXmpImplXMPNodeUtils findNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmp)) getRoot] withComItextpdfXmpImplXpathXMPPath:path withBoolean:NO withComItextpdfXmpOptionsPropertyOptions:nil];
      baseNS_ = schemaNS;
      initialPath = [basePath description];
    }
    else if (baseSchema && !baseProperty) {
      
#line 116
      startNode = [ComItextpdfXmpImplXMPNodeUtils findSchemaNodeWithComItextpdfXmpImplXMPNode:[((ComItextpdfXmpImplXMPMetaImpl *) nil_chk(xmp)) getRoot] withNSString:schemaNS withBoolean:NO];
    }
    else {
      
#line 121
      @throw [[ComItextpdfXmpXMPException alloc] initWithNSString:@"Schema namespace URI is required" withInt:ComItextpdfXmpXMPError_BADSCHEMA];
    }
    
#line 126
    if (startNode != nil) {
      
#line 128
      if (![self->options_ isJustChildren]) {
        
#line 130
        nodeIterator_ = [[ComItextpdfXmpImplXMPIteratorImpl_NodeIterator alloc] initWithComItextpdfXmpImplXMPIteratorImpl:self withComItextpdfXmpImplXMPNode:startNode withNSString:initialPath withInt:1];
      }
      else {
        
#line 134
        nodeIterator_ = [[ComItextpdfXmpImplXMPIteratorImpl_NodeIteratorChildren alloc] initWithComItextpdfXmpImplXMPIteratorImpl:self withComItextpdfXmpImplXMPNode:startNode withNSString:initialPath];
      }
    }
    else {
      
#line 140
      nodeIterator_ = [((id<JavaUtilList>) nil_chk(JavaUtilCollections_get_EMPTY_LIST_())) iterator];
    }
  }
  return self;
}


#line 148
- (void)skipSubtree {
  
#line 150
  self->skipSubtree__ = YES;
}


#line 157
- (void)skipSiblings {
  
#line 159
  [self skipSubtree];
  self->skipSiblings__ = YES;
}


#line 167
- (jboolean)hasNext {
  
#line 169
  return [((id<JavaUtilIterator>) nil_chk(nodeIterator_)) hasNext];
}


#line 176
- (id)next {
  
#line 178
  return [((id<JavaUtilIterator>) nil_chk(nodeIterator_)) next];
}


#line 185
- (void)remove {
  
#line 187
  @throw [[JavaLangUnsupportedOperationException alloc] initWithNSString:@"The XMPIterator does not support remove()."];
}


#line 194
- (ComItextpdfXmpOptionsIteratorOptions *)getOptions {
  
#line 196
  return options_;
}


#line 203
- (NSString *)getBaseNS {
  
#line 205
  return baseNS_;
}


#line 212
- (void)setBaseNSWithNSString:(NSString *)baseNS {
  
#line 214
  self->baseNS_ = baseNS;
}

- (void)copyAllFieldsTo:(ComItextpdfXmpImplXMPIteratorImpl *)other {
  [super copyAllFieldsTo:other];
  other->baseNS_ = baseNS_;
  other->nodeIterator_ = nodeIterator_;
  other->options_ = options_;
  other->skipSiblings__ = skipSiblings__;
  other->skipSubtree__ = skipSubtree__;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfXmpImplXMPMetaImpl:withNSString:withNSString:withComItextpdfXmpOptionsIteratorOptions:", "XMPIteratorImpl", NULL, 0x1, "Lcom.itextpdf.xmp.XMPException;" },
    { "skipSubtree", NULL, "V", 0x1, NULL },
    { "skipSiblings", NULL, "V", 0x1, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
    { "next", NULL, "Ljava.lang.Object;", 0x1, NULL },
    { "remove", NULL, "V", 0x1, NULL },
    { "getOptions", NULL, "Lcom.itextpdf.xmp.options.IteratorOptions;", 0x4, NULL },
    { "getBaseNS", NULL, "Ljava.lang.String;", 0x4, NULL },
    { "setBaseNSWithNSString:", "setBaseNS", "V", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "options_", NULL, 0x2, "Lcom.itextpdf.xmp.options.IteratorOptions;", NULL,  },
    { "baseNS_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "skipSiblings__", "skipSiblings", 0x4, "Z", NULL,  },
    { "skipSubtree__", "skipSubtree", 0x4, "Z", NULL,  },
    { "nodeIterator_", NULL, 0x2, "Ljava.util.Iterator;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplXMPIteratorImpl = { "XMPIteratorImpl", "com.itextpdf.xmp.impl", NULL, 0x1, 9, methods, 5, fields, 0, NULL};
  return &_ComItextpdfXmpImplXMPIteratorImpl;
}

@end

@implementation ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_$1


#line 473
- (NSString *)getNamespace {
  
#line 475
  if (![((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(val$node_)) getOptions])) isSchemaNode]) {
    
#line 478
    ComItextpdfXmpImplQName *qname = [[ComItextpdfXmpImplQName alloc] initWithNSString:[val$node_ getName]];
    return [((id<ComItextpdfXmpXMPSchemaRegistry>) nil_chk([ComItextpdfXmpXMPMetaFactory getSchemaRegistry])) getNamespaceURIWithNSString:[qname getPrefix]];
  }
  else {
    
#line 483
    return val$baseNS_;
  }
}


#line 487
- (NSString *)getPath {
  return val$path_;
}


#line 492
- (NSString *)getValue {
  
#line 494
  return val$value_;
}


#line 497
- (ComItextpdfXmpOptionsPropertyOptions *)getOptions {
  
#line 499
  return [((ComItextpdfXmpImplXMPNode *) nil_chk(val$node_)) getOptions];
}


#line 502
- (NSString *)getLanguage {
  
#line 505
  return nil;
}

- (instancetype)initWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)capture$0
                                     withNSString:(NSString *)capture$1
                                     withNSString:(NSString *)capture$2
                                     withNSString:(NSString *)capture$3 {
  val$node_ = capture$0;
  val$baseNS_ = capture$1;
  val$path_ = capture$2;
  val$value_ = capture$3;
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getNamespace", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getPath", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getValue", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getOptions", NULL, "Lcom.itextpdf.xmp.options.PropertyOptions;", 0x1, NULL },
    { "getLanguage", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "initWithComItextpdfXmpImplXMPNode:withNSString:withNSString:withNSString:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$node_", NULL, 0x1012, "Lcom.itextpdf.xmp.impl.XMPNode;", NULL,  },
    { "val$baseNS_", NULL, 0x1012, "Ljava.lang.String;", NULL,  },
    { "val$path_", NULL, 0x1012, "Ljava.lang.String;", NULL,  },
    { "val$value_", NULL, 0x1012, "Ljava.lang.String;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_$1 = { "$1", "com.itextpdf.xmp.impl", "XMPIteratorImpl$NodeIterator", 0x8000, 6, methods, 4, fields, 0, NULL};
  return &_ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_$1;
}

@end


#line 228
@implementation ComItextpdfXmpImplXMPIteratorImpl_NodeIterator


#line 256
- (instancetype)initWithComItextpdfXmpImplXMPIteratorImpl:(ComItextpdfXmpImplXMPIteratorImpl *)outer$ {
  this$0_ = outer$;
  if (self = [super init]) {
    state_ =
#line 238
    ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_NODE;
    childrenIterator_ =
#line 244
    nil;
    index_ =
#line 246
    0;
    subIterator_ =
#line 248
    [((id<JavaUtilList>) nil_chk(JavaUtilCollections_get_EMPTY_LIST_())) iterator];
    returnProperty_ =
#line 250
    nil;
  }
  return self;
}


#line 268
- (instancetype)initWithComItextpdfXmpImplXMPIteratorImpl:(ComItextpdfXmpImplXMPIteratorImpl *)outer$
                            withComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)visitedNode
                                             withNSString:(NSString *)parentPath
                                                  withInt:(jint)index {
  this$0_ = outer$;
  if (self = [super init]) {
    state_ =
#line 238
    ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_NODE;
    childrenIterator_ =
#line 244
    nil;
    index_ =
#line 246
    0;
    subIterator_ =
#line 248
    [((id<JavaUtilList>) nil_chk(JavaUtilCollections_get_EMPTY_LIST_())) iterator];
    returnProperty_ =
#line 250
    nil;
    
#line 270
    self->visitedNode_ = visitedNode;
    
#line 271
    self->state_ = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_NODE;
    
#line 272
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(visitedNode)) getOptions])) isSchemaNode]) {
      
#line 274
      [outer$ setBaseNSWithNSString:[visitedNode getName]];
    }
    
#line 278
    path_ = [self accumulatePathWithComItextpdfXmpImplXMPNode:visitedNode withNSString:parentPath withInt:index];
  }
  return self;
}


#line 287
- (jboolean)hasNext {
  
#line 289
  if (returnProperty_ != nil) {
    
#line 292
    return YES;
  }
  
#line 296
  if (state_ == ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_NODE) {
    
#line 298
    return [self reportNode];
  }
  else if (state_ == ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_CHILDREN) {
    
#line 302
    if (childrenIterator_ == nil) {
      
#line 304
      childrenIterator_ = [((ComItextpdfXmpImplXMPNode *) nil_chk(visitedNode_)) iterateChildren];
    }
    
#line 307
    jboolean hasNext = [self iterateChildrenWithJavaUtilIterator:childrenIterator_];
    
#line 309
    if (!hasNext && [((ComItextpdfXmpImplXMPNode *) nil_chk(visitedNode_)) hasQualifier] && ![((ComItextpdfXmpOptionsIteratorOptions *) nil_chk([this$0_ getOptions])) isOmitQualifiers]) {
      
#line 311
      state_ = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_QUALIFIER;
      childrenIterator_ = nil;
      hasNext = [self hasNext];
    }
    return hasNext;
  }
  else {
    
#line 319
    if (childrenIterator_ == nil) {
      
#line 321
      childrenIterator_ = [((ComItextpdfXmpImplXMPNode *) nil_chk(visitedNode_)) iterateQualifier];
    }
    
#line 324
    return [self iterateChildrenWithJavaUtilIterator:childrenIterator_];
  }
}


#line 333
- (jboolean)reportNode {
  
#line 335
  state_ = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_CHILDREN;
  if ([((ComItextpdfXmpImplXMPNode *) nil_chk(visitedNode_)) getParent] != nil &&
#line 337
  (![((ComItextpdfXmpOptionsIteratorOptions *) nil_chk([this$0_ getOptions])) isJustLeafnodes] || ![visitedNode_ hasChildren])) {
    
#line 339
    returnProperty_ = [self createPropertyInfoWithComItextpdfXmpImplXMPNode:visitedNode_ withNSString:[this$0_ getBaseNS] withNSString:path_];
    return YES;
  }
  else {
    
#line 344
    return [self hasNext];
  }
}


#line 354
- (jboolean)iterateChildrenWithJavaUtilIterator:(id<JavaUtilIterator>)iterator {
  
#line 356
  if (this$0_->skipSiblings__) {
    
#line 359
    this$0_->skipSiblings__ = NO;
    subIterator_ = [((id<JavaUtilList>) nil_chk(JavaUtilCollections_get_EMPTY_LIST_())) iterator];
  }
  
#line 365
  if ((![((id<JavaUtilIterator>) nil_chk(subIterator_)) hasNext]) && [((id<JavaUtilIterator>) nil_chk(iterator)) hasNext]) {
    
#line 367
    ComItextpdfXmpImplXMPNode *child = (ComItextpdfXmpImplXMPNode *) check_class_cast([iterator next], [ComItextpdfXmpImplXMPNode class]);
    index_++;
    subIterator_ = [[ComItextpdfXmpImplXMPIteratorImpl_NodeIterator alloc] initWithComItextpdfXmpImplXMPIteratorImpl:this$0_ withComItextpdfXmpImplXMPNode:child withNSString:path_ withInt:index_];
  }
  
#line 372
  if ([subIterator_ hasNext]) {
    
#line 374
    returnProperty_ = (id<ComItextpdfXmpPropertiesXMPPropertyInfo>) check_protocol_cast([subIterator_ next], @protocol(ComItextpdfXmpPropertiesXMPPropertyInfo));
    return YES;
  }
  else {
    
#line 379
    return NO;
  }
}


#line 391
- (id)next {
  
#line 393
  if ([self hasNext]) {
    
#line 395
    id<ComItextpdfXmpPropertiesXMPPropertyInfo> result = returnProperty_;
    returnProperty_ = nil;
    return result;
  }
  else {
    
#line 401
    @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:@"There are no more nodes to return"];
  }
}


#line 410
- (void)remove {
  
#line 412
  @throw [[JavaLangUnsupportedOperationException alloc] init];
}


#line 422
- (NSString *)accumulatePathWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)currNode
                                             withNSString:(NSString *)parentPath
                                                  withInt:(jint)currentIndex {
  
#line 424
  NSString *separator;
  NSString *segmentName;
  if ([((ComItextpdfXmpImplXMPNode *) nil_chk(currNode)) getParent] == nil || [((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([currNode getOptions])) isSchemaNode]) {
    
#line 428
    return nil;
  }
  else if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk([currNode getParent])) getOptions])) isArray]) {
    
#line 432
    separator = @"";
    segmentName = JreStrcat("C$C", '[', [NSString valueOfInt:currentIndex], ']');
  }
  else {
    
#line 437
    separator = @"/";
    segmentName = [currNode getName];
  }
  
#line 442
  if (parentPath == nil || ((jint) [parentPath length]) == 0) {
    
#line 444
    return segmentName;
  }
  else if ([((ComItextpdfXmpOptionsIteratorOptions *) nil_chk([this$0_ getOptions])) isJustLeafname]) {
    
#line 448
    return ![((NSString *) nil_chk(segmentName)) hasPrefix:@"?"] ?
#line 449
    segmentName :
#line 450
    [segmentName substring:1];
  }
  else {
    
#line 454
    return JreStrcat("$$$", parentPath, separator, segmentName);
  }
}


#line 466
- (id<ComItextpdfXmpPropertiesXMPPropertyInfo>)createPropertyInfoWithComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)node
                                                                                  withNSString:(NSString *)baseNS
                                                                                  withNSString:(NSString *)path {
  NSString *value = [((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(node)) getOptions])) isSchemaNode] ? nil : [node getValue];
  
#line 471
  return [[ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_$1 alloc] initWithComItextpdfXmpImplXMPNode:node withNSString:baseNS withNSString:path withNSString:value];
}


#line 514
- (id<JavaUtilIterator>)getChildrenIterator {
  
#line 516
  return childrenIterator_;
}


#line 523
- (void)setChildrenIteratorWithJavaUtilIterator:(id<JavaUtilIterator>)childrenIterator {
  
#line 525
  self->childrenIterator_ = childrenIterator;
}


#line 532
- (id<ComItextpdfXmpPropertiesXMPPropertyInfo>)getReturnProperty {
  
#line 534
  return returnProperty_;
}


#line 541
- (void)setReturnPropertyWithComItextpdfXmpPropertiesXMPPropertyInfo:(id<ComItextpdfXmpPropertiesXMPPropertyInfo>)returnProperty {
  
#line 543
  self->returnProperty_ = returnProperty;
}

- (void)copyAllFieldsTo:(ComItextpdfXmpImplXMPIteratorImpl_NodeIterator *)other {
  [super copyAllFieldsTo:other];
  other->childrenIterator_ = childrenIterator_;
  other->index_ = index_;
  other->path_ = path_;
  other->returnProperty_ = returnProperty_;
  other->state_ = state_;
  other->subIterator_ = subIterator_;
  other->visitedNode_ = visitedNode_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfXmpImplXMPIteratorImpl:", "NodeIterator", NULL, 0x1, NULL },
    { "initWithComItextpdfXmpImplXMPIteratorImpl:withComItextpdfXmpImplXMPNode:withNSString:withInt:", "NodeIterator", NULL, 0x1, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
    { "reportNode", NULL, "Z", 0x4, NULL },
    { "iterateChildrenWithJavaUtilIterator:", "iterateChildren", "Z", 0x2, NULL },
    { "next", NULL, "Ljava.lang.Object;", 0x1, NULL },
    { "remove", NULL, "V", 0x1, NULL },
    { "accumulatePathWithComItextpdfXmpImplXMPNode:withNSString:withInt:", "accumulatePath", "Ljava.lang.String;", 0x4, NULL },
    { "createPropertyInfoWithComItextpdfXmpImplXMPNode:withNSString:withNSString:", "createPropertyInfo", "Lcom.itextpdf.xmp.properties.XMPPropertyInfo;", 0x4, NULL },
    { "getChildrenIterator", NULL, "Ljava.util.Iterator;", 0x4, NULL },
    { "setChildrenIteratorWithJavaUtilIterator:", "setChildrenIterator", "V", 0x4, NULL },
    { "getReturnProperty", NULL, "Lcom.itextpdf.xmp.properties.XMPPropertyInfo;", 0x4, NULL },
    { "setReturnPropertyWithComItextpdfXmpPropertiesXMPPropertyInfo:", "setReturnProperty", "V", 0x4, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lcom.itextpdf.xmp.impl.XMPIteratorImpl;", NULL,  },
    { "ITERATE_NODE_", NULL, 0x1c, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_NODE },
    { "ITERATE_CHILDREN_", NULL, 0x1c, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_CHILDREN },
    { "ITERATE_QUALIFIER_", NULL, 0x1c, "I", NULL, .constantValue.asInt = ComItextpdfXmpImplXMPIteratorImpl_NodeIterator_ITERATE_QUALIFIER },
    { "state_", NULL, 0x2, "I", NULL,  },
    { "visitedNode_", NULL, 0x2, "Lcom.itextpdf.xmp.impl.XMPNode;", NULL,  },
    { "path_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "childrenIterator_", NULL, 0x2, "Ljava.util.Iterator;", NULL,  },
    { "index_", NULL, 0x2, "I", NULL,  },
    { "subIterator_", NULL, 0x2, "Ljava.util.Iterator;", NULL,  },
    { "returnProperty_", NULL, 0x2, "Lcom.itextpdf.xmp.properties.XMPPropertyInfo;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplXMPIteratorImpl_NodeIterator = { "NodeIterator", "com.itextpdf.xmp.impl", "XMPIteratorImpl", 0x2, 13, methods, 11, fields, 0, NULL};
  return &_ComItextpdfXmpImplXMPIteratorImpl_NodeIterator;
}

@end


#line 554
@implementation ComItextpdfXmpImplXMPIteratorImpl_NodeIteratorChildren


#line 569
- (instancetype)initWithComItextpdfXmpImplXMPIteratorImpl:(ComItextpdfXmpImplXMPIteratorImpl *)outer$
                            withComItextpdfXmpImplXMPNode:(ComItextpdfXmpImplXMPNode *)parentNode
                                             withNSString:(NSString *)parentPath {
  this$1_ = outer$;
  if (self = [super initWithComItextpdfXmpImplXMPIteratorImpl:outer$]) {
    index_NodeIteratorChildren_ =
#line 561
    0;
    
#line 571
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(parentNode)) getOptions])) isSchemaNode]) {
      
#line 573
      [outer$ setBaseNSWithNSString:[parentNode getName]];
    }
    
#line 575
    self->parentPath_ = [self accumulatePathWithComItextpdfXmpImplXMPNode:parentNode withNSString:parentPath withInt:1];
    
#line 577
    childrenIterator_NodeIteratorChildren_ = [parentNode iterateChildren];
  }
  return self;
}


#line 586
- (jboolean)hasNext {
  
#line 588
  if ([self getReturnProperty] != nil) {
    
#line 591
    return YES;
  }
  else if (this$1_->skipSiblings__) {
    
#line 595
    return NO;
  }
  else if ([((id<JavaUtilIterator>) nil_chk(childrenIterator_NodeIteratorChildren_)) hasNext]) {
    
#line 599
    ComItextpdfXmpImplXMPNode *child = (ComItextpdfXmpImplXMPNode *) check_class_cast([childrenIterator_NodeIteratorChildren_ next], [ComItextpdfXmpImplXMPNode class]);
    index_NodeIteratorChildren_++;
    
#line 602
    NSString *path = nil;
    if ([((ComItextpdfXmpOptionsPropertyOptions *) nil_chk([((ComItextpdfXmpImplXMPNode *) nil_chk(child)) getOptions])) isSchemaNode]) {
      
#line 605
      [this$1_ setBaseNSWithNSString:[child getName]];
    }
    else if ([child getParent] != nil) {
      
#line 610
      path = [self accumulatePathWithComItextpdfXmpImplXMPNode:child withNSString:parentPath_ withInt:index_NodeIteratorChildren_];
    }
    
#line 614
    if (![((ComItextpdfXmpOptionsIteratorOptions *) nil_chk([this$1_ getOptions])) isJustLeafnodes] || ![child hasChildren]) {
      
#line 616
      [self setReturnPropertyWithComItextpdfXmpPropertiesXMPPropertyInfo:[self createPropertyInfoWithComItextpdfXmpImplXMPNode:child withNSString:[this$1_ getBaseNS] withNSString:path]];
      return YES;
    }
    else {
      
#line 621
      return [self hasNext];
    }
  }
  else {
    
#line 626
    return NO;
  }
}

- (void)copyAllFieldsTo:(ComItextpdfXmpImplXMPIteratorImpl_NodeIteratorChildren *)other {
  [super copyAllFieldsTo:other];
  other->childrenIterator_NodeIteratorChildren_ = childrenIterator_NodeIteratorChildren_;
  other->index_NodeIteratorChildren_ = index_NodeIteratorChildren_;
  other->parentPath_ = parentPath_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComItextpdfXmpImplXMPIteratorImpl:withComItextpdfXmpImplXMPNode:withNSString:", "NodeIteratorChildren", NULL, 0x1, NULL },
    { "hasNext", NULL, "Z", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$1_", NULL, 0x1012, "Lcom.itextpdf.xmp.impl.XMPIteratorImpl;", NULL,  },
    { "parentPath_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
    { "childrenIterator_NodeIteratorChildren_", "childrenIterator", 0x2, "Ljava.util.Iterator;", NULL,  },
    { "index_NodeIteratorChildren_", "index", 0x2, "I", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplXMPIteratorImpl_NodeIteratorChildren = { "NodeIteratorChildren", "com.itextpdf.xmp.impl", "XMPIteratorImpl", 0x2, 2, methods, 4, fields, 0, NULL};
  return &_ComItextpdfXmpImplXMPIteratorImpl_NodeIteratorChildren;
}

@end

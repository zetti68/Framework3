//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/ByteBuffer.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/xmp/impl/ByteBuffer.java"

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/xmp/impl/ByteBuffer.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"


#line 43
@implementation ComItextpdfXmpImplByteBuffer


#line 56
- (instancetype)initWithInt:(jint)initialCapacity {
  if (self = [super init]) {
    encoding_ =
#line 50
    nil;
    
#line 58
    self->buffer_ = [IOSByteArray arrayWithLength:initialCapacity];
    
#line 59
    self->length__ = 0;
  }
  return self;
}


#line 66
- (instancetype)initWithByteArray:(IOSByteArray *)buffer {
  if (self = [super init]) {
    encoding_ =
#line 50
    nil;
    
#line 68
    self->buffer_ = buffer;
    
#line 69
    self->length__ = ((IOSByteArray *) nil_chk(buffer))->size_;
  }
  return self;
}


#line 77
- (instancetype)initWithByteArray:(IOSByteArray *)buffer
                          withInt:(jint)length {
  if (self = [super init]) {
    encoding_ =
#line 50
    nil;
    
#line 79
    if (length > ((IOSByteArray *) nil_chk(buffer))->size_) {
      
#line 81
      @throw [[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:@"Valid length exceeds the buffer length."];
    }
    
#line 83
    self->buffer_ = buffer;
    
#line 84
    self->length__ = length;
  }
  return self;
}


#line 94
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  if (self = [super init]) {
    encoding_ =
#line 50
    nil;
    
#line 97
    jint chunk = 16384;
    
#line 98
    self->length__ = 0;
    self->buffer_ = [IOSByteArray arrayWithLength:chunk];
    
#line 101
    jint read;
    
#line 102
    while ((read = [((JavaIoInputStream *) nil_chk(inArg)) readWithByteArray:self->buffer_ withInt:self->length__ withInt:chunk]) > 0) {
      
#line 104
      self->length__ += read;
      if (read == chunk) {
        
#line 107
        [self ensureCapacityWithInt:length__ + chunk];
      }
      else {
        
#line 111
        break;
      }
    }
  }
  return self;
}


#line 122
- (instancetype)initWithByteArray:(IOSByteArray *)buffer
                          withInt:(jint)offset
                          withInt:(jint)length {
  if (self = [super init]) {
    encoding_ =
#line 50
    nil;
    
#line 124
    if (length > ((IOSByteArray *) nil_chk(buffer))->size_ - offset) {
      
#line 126
      @throw [[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:@"Valid length exceeds the buffer length."];
    }
    
#line 128
    self->buffer_ = [IOSByteArray arrayWithLength:length];
    [JavaLangSystem arraycopyWithId:buffer withInt:offset withId:self->buffer_ withInt:0 withInt:length];
    
#line 130
    self->length__ = length;
  }
  return self;
}


#line 137
- (JavaIoInputStream *)getByteStream {
  
#line 139
  return [[JavaIoByteArrayInputStream alloc] initWithByteArray:buffer_ withInt:0 withInt:length__];
}


#line 147
- (jint)length {
  
#line 149
  return length__;
}


#line 167
- (jbyte)byteAtWithInt:(jint)index {
  
#line 169
  if (index < length__) {
    
#line 171
    return IOSByteArray_Get(nil_chk(buffer_), index);
  }
  else {
    
#line 175
    @throw [[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"The index exceeds the valid buffer area"];
  }
}


#line 184
- (jint)charAtWithInt:(jint)index {
  
#line 186
  if (index < length__) {
    
#line 188
    return IOSByteArray_Get(nil_chk(buffer_), index) & (jint) 0xFF;
  }
  else {
    
#line 192
    @throw [[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"The index exceeds the valid buffer area"];
  }
}


#line 201
- (void)appendWithByte:(jbyte)b {
  
#line 203
  [self ensureCapacityWithInt:length__ + 1];
  *IOSByteArray_GetRef(nil_chk(buffer_), length__++) = b;
}


#line 215
- (void)appendWithByteArray:(IOSByteArray *)bytes
                    withInt:(jint)offset
                    withInt:(jint)len {
  
#line 217
  [self ensureCapacityWithInt:length__ + len];
  [JavaLangSystem arraycopyWithId:bytes withInt:offset withId:buffer_ withInt:length__ withInt:len];
  length__ += len;
}


#line 227
- (void)appendWithByteArray:(IOSByteArray *)bytes {
  
#line 229
  [self appendWithByteArray:bytes withInt:0 withInt:((IOSByteArray *) nil_chk(bytes))->size_];
}


#line 237
- (void)appendWithComItextpdfXmpImplByteBuffer:(ComItextpdfXmpImplByteBuffer *)anotherBuffer {
  
#line 239
  [self appendWithByteArray:((ComItextpdfXmpImplByteBuffer *) nil_chk(anotherBuffer))->buffer_ withInt:0 withInt:anotherBuffer->length__];
}


#line 250
- (NSString *)getEncoding {
  
#line 252
  if (encoding_ == nil) {
    
#line 255
    if (length__ < 2) {
      
#line 258
      encoding_ = @"UTF-8";
    }
    else if (IOSByteArray_Get(nil_chk(buffer_), 0) == 0) {
      
#line 267
      if (length__ < 4 || IOSByteArray_Get(buffer_, 1) != 0) {
        
#line 269
        encoding_ = @"UTF-16BE";
      }
      else if ((IOSByteArray_Get(buffer_, 2) & (jint) 0xFF) == (jint) 0xFE && (IOSByteArray_Get(buffer_, 3) & (jint) 0xFF) == (jint) 0xFF) {
        
#line 273
        encoding_ = @"UTF-32BE";
      }
      else {
        
#line 277
        encoding_ = @"UTF-32";
      }
    }
    else if ((IOSByteArray_Get(buffer_, 0) & (jint) 0xFF) < (jint) 0x80) {
      
#line 286
      if (IOSByteArray_Get(buffer_, 1) != 0) {
        
#line 288
        encoding_ = @"UTF-8";
      }
      else if (length__ < 4 || IOSByteArray_Get(buffer_, 2) != 0) {
        
#line 292
        encoding_ = @"UTF-16LE";
      }
      else {
        
#line 296
        encoding_ = @"UTF-32LE";
      }
    }
    else {
      
#line 307
      if ((IOSByteArray_Get(buffer_, 0) & (jint) 0xFF) == (jint) 0xEF) {
        
#line 309
        encoding_ = @"UTF-8";
      }
      else if ((IOSByteArray_Get(buffer_, 0) & (jint) 0xFF) == (jint) 0xFE) {
        
#line 313
        encoding_ = @"UTF-16";
      }
      else if (length__ < 4 || IOSByteArray_Get(buffer_, 2) != 0) {
        
#line 317
        encoding_ = @"UTF-16";
      }
      else {
        
#line 321
        encoding_ = @"UTF-32";
      }
    }
  }
  
#line 326
  return encoding_;
}


#line 336
- (void)ensureCapacityWithInt:(jint)requestedLength {
  
#line 338
  if (requestedLength > ((IOSByteArray *) nil_chk(buffer_))->size_) {
    
#line 340
    IOSByteArray *oldBuf = buffer_;
    buffer_ = [IOSByteArray arrayWithLength:oldBuf->size_ * 2];
    [JavaLangSystem arraycopyWithId:oldBuf withInt:0 withId:buffer_ withInt:0 withInt:oldBuf->size_];
  }
}

- (void)copyAllFieldsTo:(ComItextpdfXmpImplByteBuffer *)other {
  [super copyAllFieldsTo:other];
  other->buffer_ = buffer_;
  other->encoding_ = encoding_;
  other->length__ = length__;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:", "ByteBuffer", NULL, 0x1, NULL },
    { "initWithByteArray:", "ByteBuffer", NULL, 0x1, NULL },
    { "initWithByteArray:withInt:", "ByteBuffer", NULL, 0x1, NULL },
    { "initWithJavaIoInputStream:", "ByteBuffer", NULL, 0x1, "Ljava.io.IOException;" },
    { "initWithByteArray:withInt:withInt:", "ByteBuffer", NULL, 0x1, NULL },
    { "getByteStream", NULL, "Ljava.io.InputStream;", 0x1, NULL },
    { "length", NULL, "I", 0x1, NULL },
    { "byteAtWithInt:", "byteAt", "B", 0x1, NULL },
    { "charAtWithInt:", "charAt", "I", 0x1, NULL },
    { "appendWithByte:", "append", "V", 0x1, NULL },
    { "appendWithByteArray:withInt:withInt:", "append", "V", 0x1, NULL },
    { "appendWithByteArray:", "append", "V", 0x1, NULL },
    { "appendWithComItextpdfXmpImplByteBuffer:", "append", "V", 0x1, NULL },
    { "getEncoding", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "ensureCapacityWithInt:", "ensureCapacity", "V", 0x2, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "buffer_", NULL, 0x2, "[B", NULL,  },
    { "length__", "length", 0x2, "I", NULL,  },
    { "encoding_", NULL, 0x2, "Ljava.lang.String;", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfXmpImplByteBuffer = { "ByteBuffer", "com.itextpdf.xmp.impl", NULL, 0x1, 15, methods, 3, fields, 0, NULL};
  return &_ComItextpdfXmpImplByteBuffer;
}

@end

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/awt/geom/gl/Crossing.java
//

#line 1 "/Users/Zetzsche/Development/SimarisCurves/com.itextpdf/src/com/itextpdf/awt/geom/gl/Crossing.java"

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "com/itextpdf/awt/geom/PathIterator.h"
#include "com/itextpdf/awt/geom/Rectangle2D.h"
#include "com/itextpdf/awt/geom/Shape.h"
#include "com/itextpdf/awt/geom/gl/Crossing.h"
#include "java/lang/Math.h"


#line 29
@implementation ComItextpdfAwtGeomGlCrossing


#line 57
+ (jint)solveQuadWithDoubleArray:(IOSDoubleArray *)eqn
                 withDoubleArray:(IOSDoubleArray *)res {
  
#line 58
  jdouble a = IOSDoubleArray_Get(nil_chk(eqn), 2);
  jdouble b = IOSDoubleArray_Get(eqn, 1);
  jdouble c = IOSDoubleArray_Get(eqn, 0);
  jint rc = 0;
  if (a == 0.0) {
    if (b == 0.0) {
      return -1;
    }
    *IOSDoubleArray_GetRef(nil_chk(res), rc++) = -c / b;
  }
  else {
    
#line 68
    jdouble d = b * b - 4.0 * a * c;
    
#line 70
    if (d < 0.0) {
      return 0;
    }
    d = [JavaLangMath sqrtWithDouble:d];
    *IOSDoubleArray_GetRef(nil_chk(res), rc++) = (-b + d) / (a * 2.0);
    
#line 76
    if (d != 0.0) {
      *IOSDoubleArray_GetRef(res, rc++) = (-b - d) / (a * 2.0);
    }
  }
  return [ComItextpdfAwtGeomGlCrossing fixRootsWithDoubleArray:res withInt:rc];
}


#line 89
+ (jint)solveCubicWithDoubleArray:(IOSDoubleArray *)eqn
                  withDoubleArray:(IOSDoubleArray *)res {
  
#line 90
  jdouble d = IOSDoubleArray_Get(nil_chk(eqn), 3);
  if (d == 0) {
    return [ComItextpdfAwtGeomGlCrossing solveQuadWithDoubleArray:eqn withDoubleArray:res];
  }
  jdouble a = IOSDoubleArray_Get(eqn, 2) / d;
  jdouble b = IOSDoubleArray_Get(eqn, 1) / d;
  jdouble c = IOSDoubleArray_Get(eqn, 0) / d;
  jint rc = 0;
  
#line 99
  jdouble Q = (a * a - 3.0 * b) / 9.0;
  jdouble R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
  jdouble Q3 = Q * Q * Q;
  jdouble R2 = R * R;
  jdouble n = -a / 3.0;
  
#line 105
  if (R2 < Q3) {
    jdouble t = [JavaLangMath acosWithDouble:R / [JavaLangMath sqrtWithDouble:Q3]] / 3.0;
    jdouble p = 2.0 * JavaLangMath_PI / 3.0;
    jdouble m = -2.0 * [JavaLangMath sqrtWithDouble:Q];
    *IOSDoubleArray_GetRef(nil_chk(res), rc++) = m * [JavaLangMath cosWithDouble:t] + n;
    *IOSDoubleArray_GetRef(res, rc++) = m * [JavaLangMath cosWithDouble:t + p] + n;
    *IOSDoubleArray_GetRef(res, rc++) = m * [JavaLangMath cosWithDouble:t - p] + n;
  }
  else {
    jdouble A = [JavaLangMath powWithDouble:[JavaLangMath absWithDouble:R] + [JavaLangMath sqrtWithDouble:R2 - Q3] withDouble:1.0 / 3.0];
    if (R > 0.0) {
      A = -A;
    }
    
#line 119
    if (-ComItextpdfAwtGeomGlCrossing_ROOT_DELTA < A && A < ComItextpdfAwtGeomGlCrossing_ROOT_DELTA) {
      *IOSDoubleArray_GetRef(nil_chk(res), rc++) = n;
    }
    else {
      
#line 122
      jdouble B = Q / A;
      *IOSDoubleArray_GetRef(nil_chk(res), rc++) = A + B + n;
      
#line 125
      jdouble delta = R2 - Q3;
      if (-ComItextpdfAwtGeomGlCrossing_ROOT_DELTA < delta && delta < ComItextpdfAwtGeomGlCrossing_ROOT_DELTA) {
        *IOSDoubleArray_GetRef(res, rc++) = -(A + B) / 2.0 + n;
      }
    }
  }
  
#line 132
  return [ComItextpdfAwtGeomGlCrossing fixRootsWithDoubleArray:res withInt:rc];
}


#line 141
+ (jint)fixRootsWithDoubleArray:(IOSDoubleArray *)res
                        withInt:(jint)rc {
  
#line 142
  jint tc = 0;
  for (jint i = 0; i < rc; i++) {
    {
      for (jint j = i + 1; j < rc; j++) {
        if ([ComItextpdfAwtGeomGlCrossing isZeroWithDouble:IOSDoubleArray_Get(nil_chk(res), i) - IOSDoubleArray_Get(res, j)]) {
          goto break_out;
        }
      }
      *IOSDoubleArray_GetRef(nil_chk(res), tc++) = IOSDoubleArray_Get(res, i);
    }
    break_out: ;
  }
  
#line 153
  return tc;
}


#line 367
+ (jint)crossLineWithDouble:(jdouble)x1
                 withDouble:(jdouble)y1
                 withDouble:(jdouble)x2
                 withDouble:(jdouble)y2
                 withDouble:(jdouble)x
                 withDouble:(jdouble)y {
  
#line 370
  if ((x < x1 && x < x2) ||
#line 371
  (x > x1 && x > x2) ||
#line 372
  (y > y1 && y > y2) ||
#line 373
  (x1 == x2)) {
    
#line 375
    return 0;
  }
  
#line 379
  if (y < y1 && y < y2) {
  }
  else {
    if ((y2 - y1) * (x - x1) / (x2 - x1) <= y - y1) {
      
#line 384
      return 0;
    }
  }
  
#line 389
  if (x == x1) {
    return x1 < x2 ? 0 : -1;
  }
  
#line 394
  if (x == x2) {
    return x1 < x2 ? 1 : 0;
  }
  
#line 399
  return x1 < x2 ? 1 : -1;
}


#line 405
+ (jint)crossQuadWithDouble:(jdouble)x1
                 withDouble:(jdouble)y1
                 withDouble:(jdouble)cx
                 withDouble:(jdouble)cy
                 withDouble:(jdouble)x2
                 withDouble:(jdouble)y2
                 withDouble:(jdouble)x
                 withDouble:(jdouble)y {
  
#line 408
  if ((x < x1 && x < cx && x < x2) ||
#line 409
  (x > x1 && x > cx && x > x2) ||
#line 410
  (y > y1 && y > cy && y > y2) ||
#line 411
  (x1 == cx && cx == x2)) {
    
#line 413
    return 0;
  }
  
#line 417
  if (y < y1 && y < cy && y < y2 && x != x1 && x != x2) {
    if (x1 < x2) {
      return x1 < x && x < x2 ? 1 : 0;
    }
    return x2 < x && x < x1 ? -1 : 0;
  }
  
#line 425
  ComItextpdfAwtGeomGlCrossing_QuadCurve *c = [[ComItextpdfAwtGeomGlCrossing_QuadCurve alloc] initWithDouble:x1 withDouble:y1 withDouble:cx withDouble:cy withDouble:x2 withDouble:y2];
  jdouble px = x - x1;
  jdouble py = y - y1;
  IOSDoubleArray *res = [IOSDoubleArray arrayWithLength:3];
  jint rc = [c solvePointWithDoubleArray:res withDouble:px];
  
#line 431
  return [c crossWithDoubleArray:res withInt:rc withDouble:py withDouble:py];
}


#line 437
+ (jint)crossCubicWithDouble:(jdouble)x1
                  withDouble:(jdouble)y1
                  withDouble:(jdouble)cx1
                  withDouble:(jdouble)cy1
                  withDouble:(jdouble)cx2
                  withDouble:(jdouble)cy2
                  withDouble:(jdouble)x2
                  withDouble:(jdouble)y2
                  withDouble:(jdouble)x
                  withDouble:(jdouble)y {
  
#line 440
  if ((x < x1 && x < cx1 && x < cx2 && x < x2) ||
#line 441
  (x > x1 && x > cx1 && x > cx2 && x > x2) ||
#line 442
  (y > y1 && y > cy1 && y > cy2 && y > y2) ||
#line 443
  (x1 == cx1 && cx1 == cx2 && cx2 == x2)) {
    
#line 445
    return 0;
  }
  
#line 449
  if (y < y1 && y < cy1 && y < cy2 && y < y2 && x != x1 && x != x2) {
    if (x1 < x2) {
      return x1 < x && x < x2 ? 1 : 0;
    }
    return x2 < x && x < x1 ? -1 : 0;
  }
  
#line 457
  ComItextpdfAwtGeomGlCrossing_CubicCurve *c = [[ComItextpdfAwtGeomGlCrossing_CubicCurve alloc] initWithDouble:x1 withDouble:y1 withDouble:cx1 withDouble:cy1 withDouble:cx2 withDouble:cy2 withDouble:x2 withDouble:y2];
  jdouble px = x - x1;
  jdouble py = y - y1;
  IOSDoubleArray *res = [IOSDoubleArray arrayWithLength:3];
  jint rc = [c solvePointWithDoubleArray:res withDouble:px];
  return [c crossWithDoubleArray:res withInt:rc withDouble:py withDouble:py];
}


#line 468
+ (jint)crossPathWithComItextpdfAwtGeomPathIterator:(id<ComItextpdfAwtGeomPathIterator>)p
                                         withDouble:(jdouble)x
                                         withDouble:(jdouble)y {
  
#line 469
  jint cross = 0;
  jdouble mx, my, cx, cy;
  mx = my = cx = cy = 0.0;
  IOSDoubleArray *coords = [IOSDoubleArray arrayWithLength:6];
  
#line 474
  while (![((id<ComItextpdfAwtGeomPathIterator>) nil_chk(p)) isDone]) {
    switch ([p currentSegmentWithDoubleArray:coords]) {
      case ComItextpdfAwtGeomPathIterator_SEG_MOVETO:
      if (cx != mx || cy != my) {
        cross += [ComItextpdfAwtGeomGlCrossing crossLineWithDouble:cx withDouble:cy withDouble:mx withDouble:my withDouble:x withDouble:y];
      }
      mx = cx = IOSDoubleArray_Get(coords, 0);
      my = cy = IOSDoubleArray_Get(coords, 1);
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_LINETO:
      cross += [ComItextpdfAwtGeomGlCrossing crossLineWithDouble:cx withDouble:cy withDouble:cx = IOSDoubleArray_Get(coords, 0) withDouble:cy = IOSDoubleArray_Get(coords, 1) withDouble:x withDouble:y];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_QUADTO:
      cross += [ComItextpdfAwtGeomGlCrossing crossQuadWithDouble:cx withDouble:cy withDouble:IOSDoubleArray_Get(coords, 0) withDouble:IOSDoubleArray_Get(coords, 1) withDouble:cx = IOSDoubleArray_Get(coords, 2) withDouble:cy = IOSDoubleArray_Get(coords, 3) withDouble:x withDouble:y];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_CUBICTO:
      cross += [ComItextpdfAwtGeomGlCrossing crossCubicWithDouble:cx withDouble:cy withDouble:IOSDoubleArray_Get(coords, 0) withDouble:IOSDoubleArray_Get(coords, 1) withDouble:IOSDoubleArray_Get(coords, 2) withDouble:IOSDoubleArray_Get(coords, 3) withDouble:cx = IOSDoubleArray_Get(coords, 4) withDouble:cy = IOSDoubleArray_Get(coords, 5) withDouble:x withDouble:y];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_CLOSE:
      if (cy != my || cx != mx) {
        cross += [ComItextpdfAwtGeomGlCrossing crossLineWithDouble:cx withDouble:cy withDouble:cx = mx withDouble:cy = my withDouble:x withDouble:y];
      }
      break;
    }
    
#line 500
    if (x == cx && y == cy) {
      cross = 0;
      cy = my;
      break;
    }
    [p next];
  }
  if (cy != my) {
    cross += [ComItextpdfAwtGeomGlCrossing crossLineWithDouble:cx withDouble:cy withDouble:mx withDouble:my withDouble:x withDouble:y];
  }
  return cross;
}


#line 516
+ (jint)crossShapeWithComItextpdfAwtGeomShape:(id<ComItextpdfAwtGeomShape>)s
                                   withDouble:(jdouble)x
                                   withDouble:(jdouble)y {
  
#line 517
  if (![((ComItextpdfAwtGeomRectangle2D *) nil_chk([((id<ComItextpdfAwtGeomShape>) nil_chk(s)) getBounds2D])) containsWithDouble:x withDouble:y]) {
    return 0;
  }
  return [ComItextpdfAwtGeomGlCrossing crossPathWithComItextpdfAwtGeomPathIterator:[s getPathIteratorWithComItextpdfAwtGeomAffineTransform:nil] withDouble:x withDouble:y];
}


#line 526
+ (jboolean)isZeroWithDouble:(jdouble)val {
  return -ComItextpdfAwtGeomGlCrossing_DELTA < val && val < ComItextpdfAwtGeomGlCrossing_DELTA;
}


#line 533
+ (void)sortBoundWithDoubleArray:(IOSDoubleArray *)bound
                         withInt:(jint)bc {
  
#line 534
  for (jint i = 0; i < bc - 4; i += 4) {
    jint k = i;
    for (jint j = i + 4; j < bc; j += 4) {
      if (IOSDoubleArray_Get(nil_chk(bound), k) > IOSDoubleArray_Get(bound, j)) {
        k = j;
      }
    }
    if (k != i) {
      jdouble tmp = IOSDoubleArray_Get(nil_chk(bound), i);
      *IOSDoubleArray_GetRef(bound, i) = IOSDoubleArray_Get(bound, k);
      *IOSDoubleArray_GetRef(bound, k) = tmp;
      tmp = IOSDoubleArray_Get(bound, i + 1);
      *IOSDoubleArray_GetRef(bound, i + 1) = IOSDoubleArray_Get(bound, k + 1);
      *IOSDoubleArray_GetRef(bound, k + 1) = tmp;
      tmp = IOSDoubleArray_Get(bound, i + 2);
      *IOSDoubleArray_GetRef(bound, i + 2) = IOSDoubleArray_Get(bound, k + 2);
      *IOSDoubleArray_GetRef(bound, k + 2) = tmp;
      tmp = IOSDoubleArray_Get(bound, i + 3);
      *IOSDoubleArray_GetRef(bound, i + 3) = IOSDoubleArray_Get(bound, k + 3);
      *IOSDoubleArray_GetRef(bound, k + 3) = tmp;
    }
  }
}

+ (jint)crossBoundWithDoubleArray:(IOSDoubleArray *)bound
                          withInt:(jint)bc
                       withDouble:(jdouble)py1
                       withDouble:(jdouble)py2 {
  
#line 564
  if (bc == 0) {
    return 0;
  }
  
#line 569
  jint up = 0;
  jint down = 0;
  for (jint i = 2; i < bc; i += 4) {
    if (IOSDoubleArray_Get(nil_chk(bound), i) < py1) {
      up++;
      continue;
    }
    if (IOSDoubleArray_Get(bound, i) > py2) {
      down++;
      continue;
    }
    return ComItextpdfAwtGeomGlCrossing_CROSSING;
  }
  
#line 584
  if (down == 0) {
    return 0;
  }
  
#line 588
  if (up != 0) {
    
#line 590
    [ComItextpdfAwtGeomGlCrossing sortBoundWithDoubleArray:bound withInt:bc];
    jboolean sign = IOSDoubleArray_Get(nil_chk(bound), 2) > py2;
    for (jint i = 6; i < bc; i += 4) {
      jboolean sign2 = IOSDoubleArray_Get(bound, i) > py2;
      if (sign != sign2 && IOSDoubleArray_Get(bound, i + 1) != IOSDoubleArray_Get(bound, i - 3)) {
        return ComItextpdfAwtGeomGlCrossing_CROSSING;
      }
      sign = sign2;
    }
  }
  return ComItextpdfAwtGeomGlCrossing_UNKNOWN;
}


#line 606
+ (jint)intersectLineWithDouble:(jdouble)x1
                     withDouble:(jdouble)y1
                     withDouble:(jdouble)x2
                     withDouble:(jdouble)y2
                     withDouble:(jdouble)rx1
                     withDouble:(jdouble)ry1
                     withDouble:(jdouble)rx2
                     withDouble:(jdouble)ry2 {
  
#line 609
  if ((rx2 < x1 && rx2 < x2) ||
#line 610
  (rx1 > x1 && rx1 > x2) ||
#line 611
  (ry1 > y1 && ry1 > y2)) {
    
#line 613
    return 0;
  }
  
#line 617
  if (ry2 < y1 && ry2 < y2) {
  }
  else {
    
#line 621
    if (x1 == x2) {
      return ComItextpdfAwtGeomGlCrossing_CROSSING;
    }
    
#line 626
    jdouble bx1, bx2;
    if (x1 < x2) {
      bx1 = x1 < rx1 ? rx1 : x1;
      bx2 = x2 < rx2 ? x2 : rx2;
    }
    else {
      
#line 631
      bx1 = x2 < rx1 ? rx1 : x2;
      bx2 = x1 < rx2 ? x1 : rx2;
    }
    jdouble k = (y2 - y1) / (x2 - x1);
    jdouble by1 = k * (bx1 - x1) + y1;
    jdouble by2 = k * (bx2 - x1) + y1;
    
#line 639
    if (by1 < ry1 && by2 < ry1) {
      return 0;
    }
    
#line 644
    if (by1 > ry2 && by2 > ry2) {
    }
    else {
      
#line 646
      return ComItextpdfAwtGeomGlCrossing_CROSSING;
    }
  }
  
#line 651
  if (x1 == x2) {
    return 0;
  }
  
#line 656
  if (rx1 == x1) {
    return x1 < x2 ? 0 : -1;
  }
  
#line 661
  if (rx1 == x2) {
    return x1 < x2 ? 1 : 0;
  }
  
#line 665
  if (x1 < x2) {
    return x1 < rx1 && rx1 < x2 ? 1 : 0;
  }
  return x2 < rx1 && rx1 < x1 ? -1 : 0;
}


#line 675
+ (jint)intersectQuadWithDouble:(jdouble)x1
                     withDouble:(jdouble)y1
                     withDouble:(jdouble)cx
                     withDouble:(jdouble)cy
                     withDouble:(jdouble)x2
                     withDouble:(jdouble)y2
                     withDouble:(jdouble)rx1
                     withDouble:(jdouble)ry1
                     withDouble:(jdouble)rx2
                     withDouble:(jdouble)ry2 {
  
#line 678
  if ((rx2 < x1 && rx2 < cx && rx2 < x2) ||
#line 679
  (rx1 > x1 && rx1 > cx && rx1 > x2) ||
#line 680
  (ry1 > y1 && ry1 > cy && ry1 > y2)) {
    
#line 682
    return 0;
  }
  
#line 686
  if (ry2 < y1 && ry2 < cy && ry2 < y2 && rx1 != x1 && rx1 != x2) {
    if (x1 < x2) {
      return x1 < rx1 && rx1 < x2 ? 1 : 0;
    }
    return x2 < rx1 && rx1 < x1 ? -1 : 0;
  }
  
#line 694
  ComItextpdfAwtGeomGlCrossing_QuadCurve *c = [[ComItextpdfAwtGeomGlCrossing_QuadCurve alloc] initWithDouble:x1 withDouble:y1 withDouble:cx withDouble:cy withDouble:x2 withDouble:y2];
  jdouble px1 = rx1 - x1;
  jdouble py1 = ry1 - y1;
  jdouble px2 = rx2 - x1;
  jdouble py2 = ry2 - y1;
  
#line 700
  IOSDoubleArray *res1 = [IOSDoubleArray arrayWithLength:3];
  IOSDoubleArray *res2 = [IOSDoubleArray arrayWithLength:3];
  jint rc1 = [c solvePointWithDoubleArray:res1 withDouble:px1];
  jint rc2 = [c solvePointWithDoubleArray:res2 withDouble:px2];
  
#line 706
  if (rc1 == 0 && rc2 == 0) {
    return 0;
  }
  
#line 711
  jdouble minX = px1 - ComItextpdfAwtGeomGlCrossing_DELTA;
  jdouble maxX = px2 + ComItextpdfAwtGeomGlCrossing_DELTA;
  IOSDoubleArray *bound = [IOSDoubleArray arrayWithLength:28];
  jint bc = 0;
  
#line 716
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res1 withInt:rc1 withDouble:minX withDouble:maxX withBoolean:NO withInt:0];
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res2 withInt:rc2 withDouble:minX withDouble:maxX withBoolean:NO withInt:1];
  
#line 719
  rc2 = [c solveExtremWithDoubleArray:res2];
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res2 withInt:rc2 withDouble:minX withDouble:maxX withBoolean:YES withInt:2];
  
#line 722
  if (rx1 < x1 && x1 < rx2) {
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 4;
  }
  if (rx1 < x2 && x2 < rx2) {
    *IOSDoubleArray_GetRef(bound, bc++) = 1.0;
    *IOSDoubleArray_GetRef(bound, bc++) = c->ax_;
    *IOSDoubleArray_GetRef(bound, bc++) = c->ay_;
    *IOSDoubleArray_GetRef(bound, bc++) = 5;
  }
  
#line 736
  jint cross = [ComItextpdfAwtGeomGlCrossing crossBoundWithDoubleArray:bound withInt:bc withDouble:py1 withDouble:py2];
  if (cross != ComItextpdfAwtGeomGlCrossing_UNKNOWN) {
    return cross;
  }
  return [c crossWithDoubleArray:res1 withInt:rc1 withDouble:py1 withDouble:py2];
}


#line 746
+ (jint)intersectCubicWithDouble:(jdouble)x1
                      withDouble:(jdouble)y1
                      withDouble:(jdouble)cx1
                      withDouble:(jdouble)cy1
                      withDouble:(jdouble)cx2
                      withDouble:(jdouble)cy2
                      withDouble:(jdouble)x2
                      withDouble:(jdouble)y2
                      withDouble:(jdouble)rx1
                      withDouble:(jdouble)ry1
                      withDouble:(jdouble)rx2
                      withDouble:(jdouble)ry2 {
  
#line 749
  if ((rx2 < x1 && rx2 < cx1 && rx2 < cx2 && rx2 < x2) ||
#line 750
  (rx1 > x1 && rx1 > cx1 && rx1 > cx2 && rx1 > x2) ||
#line 751
  (ry1 > y1 && ry1 > cy1 && ry1 > cy2 && ry1 > y2)) {
    
#line 753
    return 0;
  }
  
#line 757
  if (ry2 < y1 && ry2 < cy1 && ry2 < cy2 && ry2 < y2 && rx1 != x1 && rx1 != x2) {
    if (x1 < x2) {
      return x1 < rx1 && rx1 < x2 ? 1 : 0;
    }
    return x2 < rx1 && rx1 < x1 ? -1 : 0;
  }
  
#line 765
  ComItextpdfAwtGeomGlCrossing_CubicCurve *c = [[ComItextpdfAwtGeomGlCrossing_CubicCurve alloc] initWithDouble:x1 withDouble:y1 withDouble:cx1 withDouble:cy1 withDouble:cx2 withDouble:cy2 withDouble:x2 withDouble:y2];
  jdouble px1 = rx1 - x1;
  jdouble py1 = ry1 - y1;
  jdouble px2 = rx2 - x1;
  jdouble py2 = ry2 - y1;
  
#line 771
  IOSDoubleArray *res1 = [IOSDoubleArray arrayWithLength:3];
  IOSDoubleArray *res2 = [IOSDoubleArray arrayWithLength:3];
  jint rc1 = [c solvePointWithDoubleArray:res1 withDouble:px1];
  jint rc2 = [c solvePointWithDoubleArray:res2 withDouble:px2];
  
#line 777
  if (rc1 == 0 && rc2 == 0) {
    return 0;
  }
  
#line 781
  jdouble minX = px1 - ComItextpdfAwtGeomGlCrossing_DELTA;
  jdouble maxX = px2 + ComItextpdfAwtGeomGlCrossing_DELTA;
  
#line 785
  IOSDoubleArray *bound = [IOSDoubleArray arrayWithLength:40];
  jint bc = 0;
  
#line 788
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res1 withInt:rc1 withDouble:minX withDouble:maxX withBoolean:NO withInt:0];
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res2 withInt:rc2 withDouble:minX withDouble:maxX withBoolean:NO withInt:1];
  
#line 791
  rc2 = [c solveExtremXWithDoubleArray:res2];
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res2 withInt:rc2 withDouble:minX withDouble:maxX withBoolean:YES withInt:2];
  rc2 = [c solveExtremYWithDoubleArray:res2];
  bc = [c addBoundWithDoubleArray:bound withInt:bc withDoubleArray:res2 withInt:rc2 withDouble:minX withDouble:maxX withBoolean:YES withInt:4];
  
#line 796
  if (rx1 < x1 && x1 < rx2) {
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 0.0;
    *IOSDoubleArray_GetRef(bound, bc++) = 6;
  }
  if (rx1 < x2 && x2 < rx2) {
    *IOSDoubleArray_GetRef(bound, bc++) = 1.0;
    *IOSDoubleArray_GetRef(bound, bc++) = c->ax_;
    *IOSDoubleArray_GetRef(bound, bc++) = c->ay_;
    *IOSDoubleArray_GetRef(bound, bc++) = 7;
  }
  
#line 810
  jint cross = [ComItextpdfAwtGeomGlCrossing crossBoundWithDoubleArray:bound withInt:bc withDouble:py1 withDouble:py2];
  if (cross != ComItextpdfAwtGeomGlCrossing_UNKNOWN) {
    return cross;
  }
  return [c crossWithDoubleArray:res1 withInt:rc1 withDouble:py1 withDouble:py2];
}


#line 820
+ (jint)intersectPathWithComItextpdfAwtGeomPathIterator:(id<ComItextpdfAwtGeomPathIterator>)p
                                             withDouble:(jdouble)x
                                             withDouble:(jdouble)y
                                             withDouble:(jdouble)w
                                             withDouble:(jdouble)h {
  
#line 822
  jint cross = 0;
  jint count;
  jdouble mx, my, cx, cy;
  mx = my = cx = cy = 0.0;
  IOSDoubleArray *coords = [IOSDoubleArray arrayWithLength:6];
  
#line 828
  jdouble rx1 = x;
  jdouble ry1 = y;
  jdouble rx2 = x + w;
  jdouble ry2 = y + h;
  
#line 833
  while (![((id<ComItextpdfAwtGeomPathIterator>) nil_chk(p)) isDone]) {
    count = 0;
    switch ([p currentSegmentWithDoubleArray:coords]) {
      case ComItextpdfAwtGeomPathIterator_SEG_MOVETO:
      if (cx != mx || cy != my) {
        count = [ComItextpdfAwtGeomGlCrossing intersectLineWithDouble:cx withDouble:cy withDouble:mx withDouble:my withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
      }
      mx = cx = IOSDoubleArray_Get(coords, 0);
      my = cy = IOSDoubleArray_Get(coords, 1);
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_LINETO:
      count = [ComItextpdfAwtGeomGlCrossing intersectLineWithDouble:cx withDouble:cy withDouble:cx = IOSDoubleArray_Get(coords, 0) withDouble:cy = IOSDoubleArray_Get(coords, 1) withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_QUADTO:
      count = [ComItextpdfAwtGeomGlCrossing intersectQuadWithDouble:cx withDouble:cy withDouble:IOSDoubleArray_Get(coords, 0) withDouble:IOSDoubleArray_Get(coords, 1) withDouble:cx = IOSDoubleArray_Get(coords, 2) withDouble:cy = IOSDoubleArray_Get(coords, 3) withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_CUBICTO:
      count = [ComItextpdfAwtGeomGlCrossing intersectCubicWithDouble:cx withDouble:cy withDouble:IOSDoubleArray_Get(coords, 0) withDouble:IOSDoubleArray_Get(coords, 1) withDouble:IOSDoubleArray_Get(coords, 2) withDouble:IOSDoubleArray_Get(coords, 3) withDouble:cx = IOSDoubleArray_Get(coords, 4) withDouble:cy = IOSDoubleArray_Get(coords, 5) withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
      break;
      case ComItextpdfAwtGeomPathIterator_SEG_CLOSE:
      if (cy != my || cx != mx) {
        count = [ComItextpdfAwtGeomGlCrossing intersectLineWithDouble:cx withDouble:cy withDouble:mx withDouble:my withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
      }
      cx = mx;
      cy = my;
      break;
    }
    if (count == ComItextpdfAwtGeomGlCrossing_CROSSING) {
      return ComItextpdfAwtGeomGlCrossing_CROSSING;
    }
    cross += count;
    [p next];
  }
  if (cy != my) {
    count = [ComItextpdfAwtGeomGlCrossing intersectLineWithDouble:cx withDouble:cy withDouble:mx withDouble:my withDouble:rx1 withDouble:ry1 withDouble:rx2 withDouble:ry2];
    if (count == ComItextpdfAwtGeomGlCrossing_CROSSING) {
      return ComItextpdfAwtGeomGlCrossing_CROSSING;
    }
    cross += count;
  }
  return cross;
}


#line 879
+ (jint)intersectShapeWithComItextpdfAwtGeomShape:(id<ComItextpdfAwtGeomShape>)s
                                       withDouble:(jdouble)x
                                       withDouble:(jdouble)y
                                       withDouble:(jdouble)w
                                       withDouble:(jdouble)h {
  
#line 880
  if (![((ComItextpdfAwtGeomRectangle2D *) nil_chk([((id<ComItextpdfAwtGeomShape>) nil_chk(s)) getBounds2D])) intersectsWithDouble:x withDouble:y withDouble:w withDouble:h]) {
    return 0;
  }
  return [ComItextpdfAwtGeomGlCrossing intersectPathWithComItextpdfAwtGeomPathIterator:[s getPathIteratorWithComItextpdfAwtGeomAffineTransform:nil] withDouble:x withDouble:y withDouble:w withDouble:h];
}


#line 889
+ (jboolean)isInsideNonZeroWithInt:(jint)cross {
  
#line 890
  return cross != 0;
}


#line 896
+ (jboolean)isInsideEvenOddWithInt:(jint)cross {
  
#line 897
  return (cross & 1) != 0;
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "solveQuadWithDoubleArray:withDoubleArray:", "solveQuad", "I", 0x9, NULL },
    { "solveCubicWithDoubleArray:withDoubleArray:", "solveCubic", "I", 0x9, NULL },
    { "fixRootsWithDoubleArray:withInt:", "fixRoots", "I", 0x8, NULL },
    { "crossLineWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "crossLine", "I", 0x9, NULL },
    { "crossQuadWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "crossQuad", "I", 0x9, NULL },
    { "crossCubicWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "crossCubic", "I", 0x9, NULL },
    { "crossPathWithComItextpdfAwtGeomPathIterator:withDouble:withDouble:", "crossPath", "I", 0x9, NULL },
    { "crossShapeWithComItextpdfAwtGeomShape:withDouble:withDouble:", "crossShape", "I", 0x9, NULL },
    { "isZeroWithDouble:", "isZero", "Z", 0x9, NULL },
    { "sortBoundWithDoubleArray:withInt:", "sortBound", "V", 0x8, NULL },
    { "crossBoundWithDoubleArray:withInt:withDouble:withDouble:", "crossBound", "I", 0x8, NULL },
    { "intersectLineWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "intersectLine", "I", 0x9, NULL },
    { "intersectQuadWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "intersectQuad", "I", 0x9, NULL },
    { "intersectCubicWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "intersectCubic", "I", 0x9, NULL },
    { "intersectPathWithComItextpdfAwtGeomPathIterator:withDouble:withDouble:withDouble:withDouble:", "intersectPath", "I", 0x9, NULL },
    { "intersectShapeWithComItextpdfAwtGeomShape:withDouble:withDouble:withDouble:withDouble:", "intersectShape", "I", 0x9, NULL },
    { "isInsideNonZeroWithInt:", "isInsideNonZero", "Z", 0x9, NULL },
    { "isInsideEvenOddWithInt:", "isInsideEvenOdd", "Z", 0x9, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DELTA_", NULL, 0x18, "D", NULL, .constantValue.asDouble = ComItextpdfAwtGeomGlCrossing_DELTA },
    { "ROOT_DELTA_", NULL, 0x18, "D", NULL, .constantValue.asDouble = ComItextpdfAwtGeomGlCrossing_ROOT_DELTA },
    { "CROSSING_", NULL, 0x19, "I", NULL, .constantValue.asInt = ComItextpdfAwtGeomGlCrossing_CROSSING },
    { "UNKNOWN_", NULL, 0x18, "I", NULL, .constantValue.asInt = ComItextpdfAwtGeomGlCrossing_UNKNOWN },
  };
  static const J2ObjcClassInfo _ComItextpdfAwtGeomGlCrossing = { "Crossing", "com.itextpdf.awt.geom.gl", NULL, 0x1, 19, methods, 4, fields, 0, NULL};
  return &_ComItextpdfAwtGeomGlCrossing;
}

@end


#line 159
@implementation ComItextpdfAwtGeomGlCrossing_QuadCurve


#line 164
- (instancetype)initWithDouble:(jdouble)x1
                    withDouble:(jdouble)y1
                    withDouble:(jdouble)cx
                    withDouble:(jdouble)cy
                    withDouble:(jdouble)x2
                    withDouble:(jdouble)y2 {
  if (self = [super init]) {
    
#line 165
    ax_ = x2 - x1;
    
#line 166
    ay_ = y2 - y1;
    
#line 167
    bx_ = cx - x1;
    
#line 168
    by_ = cy - y1;
    
#line 170
    Bx_ = bx_ + bx_;
    
#line 171
    Ax_ = ax_ - Bx_;
    
#line 173
    By_ = by_ + by_;
    
#line 174
    Ay_ = ay_ - By_;
  }
  return self;
}


#line 177
- (jint)crossWithDoubleArray:(IOSDoubleArray *)res
                     withInt:(jint)rc
                  withDouble:(jdouble)py1
                  withDouble:(jdouble)py2 {
  
#line 178
  jint cross = 0;
  
#line 180
  for (jint i = 0; i < rc; i++) {
    jdouble t = IOSDoubleArray_Get(nil_chk(res), i);
    
#line 184
    if (t < -ComItextpdfAwtGeomGlCrossing_DELTA || t > 1 + ComItextpdfAwtGeomGlCrossing_DELTA) {
      continue;
    }
    
#line 188
    if (t < ComItextpdfAwtGeomGlCrossing_DELTA) {
      if (py1 < 0.0 && (bx_ != 0.0 ? bx_ : ax_ - bx_) < 0.0) {
        cross--;
      }
      continue;
    }
    
#line 195
    if (t > 1 - ComItextpdfAwtGeomGlCrossing_DELTA) {
      if (py1 < ay_ && (ax_ != bx_ ? ax_ - bx_ : bx_) > 0.0) {
        cross++;
      }
      continue;
    }
    
#line 202
    jdouble ry = t * (t * Ay_ + By_);
    
#line 204
    if (ry > py2) {
      jdouble rxt = t * Ax_ + bx_;
      
#line 207
      if (rxt > -ComItextpdfAwtGeomGlCrossing_DELTA && rxt < ComItextpdfAwtGeomGlCrossing_DELTA) {
        continue;
      }
      cross += rxt > 0.0 ? 1 : -1;
    }
  }
  
#line 214
  return cross;
}


#line 217
- (jint)solvePointWithDoubleArray:(IOSDoubleArray *)res
                       withDouble:(jdouble)px {
  
#line 218
  IOSDoubleArray *eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ -px, Bx_, Ax_ } count:3];
  return [ComItextpdfAwtGeomGlCrossing solveQuadWithDoubleArray:eqn withDoubleArray:res];
}


#line 222
- (jint)solveExtremWithDoubleArray:(IOSDoubleArray *)res {
  
#line 223
  jint rc = 0;
  if (Ax_ != 0.0) {
    *IOSDoubleArray_GetRef(nil_chk(res), rc++) = -Bx_ / (Ax_ + Ax_);
  }
  if (Ay_ != 0.0) {
    *IOSDoubleArray_GetRef(nil_chk(res), rc++) = -By_ / (Ay_ + Ay_);
  }
  return rc;
}


#line 233
- (jint)addBoundWithDoubleArray:(IOSDoubleArray *)bound
                        withInt:(jint)bc
                withDoubleArray:(IOSDoubleArray *)res
                        withInt:(jint)rc
                     withDouble:(jdouble)minX
                     withDouble:(jdouble)maxX
                    withBoolean:(jboolean)changeId
                        withInt:(jint)id_ {
  
#line 234
  for (jint i = 0; i < rc; i++) {
    jdouble t = IOSDoubleArray_Get(nil_chk(res), i);
    if (t > -ComItextpdfAwtGeomGlCrossing_DELTA && t < 1 + ComItextpdfAwtGeomGlCrossing_DELTA) {
      jdouble rx = t * (t * Ax_ + Bx_);
      if (minX <= rx && rx <= maxX) {
        *IOSDoubleArray_GetRef(nil_chk(bound), bc++) = t;
        *IOSDoubleArray_GetRef(bound, bc++) = rx;
        *IOSDoubleArray_GetRef(bound, bc++) = t * (t * Ay_ + By_);
        *IOSDoubleArray_GetRef(bound, bc++) = id_;
        if (changeId) {
          id_++;
        }
      }
    }
  }
  return bc;
}

- (void)copyAllFieldsTo:(ComItextpdfAwtGeomGlCrossing_QuadCurve *)other {
  [super copyAllFieldsTo:other];
  other->Ax_ = Ax_;
  other->Ay_ = Ay_;
  other->Bx_ = Bx_;
  other->By_ = By_;
  other->ax_ = ax_;
  other->ay_ = ay_;
  other->bx_ = bx_;
  other->by_ = by_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "QuadCurve", NULL, 0x1, NULL },
    { "crossWithDoubleArray:withInt:withDouble:withDouble:", "cross", "I", 0x0, NULL },
    { "solvePointWithDoubleArray:withDouble:", "solvePoint", "I", 0x0, NULL },
    { "solveExtremWithDoubleArray:", "solveExtrem", "I", 0x0, NULL },
    { "addBoundWithDoubleArray:withInt:withDoubleArray:withInt:withDouble:withDouble:withBoolean:withInt:", "addBound", "I", 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "ax_", NULL, 0x0, "D", NULL,  },
    { "ay_", NULL, 0x0, "D", NULL,  },
    { "bx_", NULL, 0x0, "D", NULL,  },
    { "by_", NULL, 0x0, "D", NULL,  },
    { "Ax_", NULL, 0x0, "D", NULL,  },
    { "Ay_", NULL, 0x0, "D", NULL,  },
    { "Bx_", NULL, 0x0, "D", NULL,  },
    { "By_", NULL, 0x0, "D", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfAwtGeomGlCrossing_QuadCurve = { "QuadCurve", "com.itextpdf.awt.geom.gl", "Crossing", 0x9, 5, methods, 8, fields, 0, NULL};
  return &_ComItextpdfAwtGeomGlCrossing_QuadCurve;
}

@end


#line 257
@implementation ComItextpdfAwtGeomGlCrossing_CubicCurve


#line 263
- (instancetype)initWithDouble:(jdouble)x1
                    withDouble:(jdouble)y1
                    withDouble:(jdouble)cx1
                    withDouble:(jdouble)cy1
                    withDouble:(jdouble)cx2
                    withDouble:(jdouble)cy2
                    withDouble:(jdouble)x2
                    withDouble:(jdouble)y2 {
  if (self = [super init]) {
    
#line 264
    ax_ = x2 - x1;
    
#line 265
    ay_ = y2 - y1;
    
#line 266
    bx_ = cx1 - x1;
    
#line 267
    by_ = cy1 - y1;
    
#line 268
    cx_ = cx2 - x1;
    
#line 269
    cy_ = cy2 - y1;
    
#line 271
    Cx_ = bx_ + bx_ + bx_;
    
#line 272
    Bx_ = cx_ + cx_ + cx_ - Cx_ - Cx_;
    
#line 273
    Ax_ = ax_ - Bx_ - Cx_;
    
#line 275
    Cy_ = by_ + by_ + by_;
    
#line 276
    By_ = cy_ + cy_ + cy_ - Cy_ - Cy_;
    
#line 277
    Ay_ = ay_ - By_ - Cy_;
    
#line 279
    Ax3_ = Ax_ + Ax_ + Ax_;
    
#line 280
    Bx2_ = Bx_ + Bx_;
  }
  return self;
}


#line 283
- (jint)crossWithDoubleArray:(IOSDoubleArray *)res
                     withInt:(jint)rc
                  withDouble:(jdouble)py1
                  withDouble:(jdouble)py2 {
  
#line 284
  jint cross = 0;
  for (jint i = 0; i < rc; i++) {
    jdouble t = IOSDoubleArray_Get(nil_chk(res), i);
    
#line 289
    if (t < -ComItextpdfAwtGeomGlCrossing_DELTA || t > 1 + ComItextpdfAwtGeomGlCrossing_DELTA) {
      continue;
    }
    
#line 293
    if (t < ComItextpdfAwtGeomGlCrossing_DELTA) {
      if (py1 < 0.0 && (bx_ != 0.0 ? bx_ : (cx_ != bx_ ? cx_ - bx_ : ax_ - cx_)) < 0.0) {
        cross--;
      }
      continue;
    }
    
#line 300
    if (t > 1 - ComItextpdfAwtGeomGlCrossing_DELTA) {
      if (py1 < ay_ && (ax_ != cx_ ? ax_ - cx_ : (cx_ != bx_ ? cx_ - bx_ : bx_)) > 0.0) {
        cross++;
      }
      continue;
    }
    
#line 307
    jdouble ry = t * (t * (t * Ay_ + By_) + Cy_);
    
#line 309
    if (ry > py2) {
      jdouble rxt = t * (t * Ax3_ + Bx2_) + Cx_;
      
#line 312
      if (rxt > -ComItextpdfAwtGeomGlCrossing_DELTA && rxt < ComItextpdfAwtGeomGlCrossing_DELTA) {
        rxt = t * (Ax3_ + Ax3_) + Bx2_;
        
#line 315
        if (rxt < -ComItextpdfAwtGeomGlCrossing_DELTA || rxt > ComItextpdfAwtGeomGlCrossing_DELTA) {
          
#line 317
          continue;
        }
        rxt = ax_;
      }
      cross += rxt > 0.0 ? 1 : -1;
    }
  }
  
#line 325
  return cross;
}


#line 328
- (jint)solvePointWithDoubleArray:(IOSDoubleArray *)res
                       withDouble:(jdouble)px {
  
#line 329
  IOSDoubleArray *eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ -px, Cx_, Bx_, Ax_ } count:4];
  return [ComItextpdfAwtGeomGlCrossing solveCubicWithDoubleArray:eqn withDoubleArray:res];
}


#line 333
- (jint)solveExtremXWithDoubleArray:(IOSDoubleArray *)res {
  
#line 334
  IOSDoubleArray *eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ Cx_, Bx2_, Ax3_ } count:3];
  return [ComItextpdfAwtGeomGlCrossing solveQuadWithDoubleArray:eqn withDoubleArray:res];
}


#line 338
- (jint)solveExtremYWithDoubleArray:(IOSDoubleArray *)res {
  
#line 339
  IOSDoubleArray *eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ Cy_, By_ + By_, Ay_ + Ay_ + Ay_ } count:3];
  return [ComItextpdfAwtGeomGlCrossing solveQuadWithDoubleArray:eqn withDoubleArray:res];
}


#line 343
- (jint)addBoundWithDoubleArray:(IOSDoubleArray *)bound
                        withInt:(jint)bc
                withDoubleArray:(IOSDoubleArray *)res
                        withInt:(jint)rc
                     withDouble:(jdouble)minX
                     withDouble:(jdouble)maxX
                    withBoolean:(jboolean)changeId
                        withInt:(jint)id_ {
  
#line 344
  for (jint i = 0; i < rc; i++) {
    jdouble t = IOSDoubleArray_Get(nil_chk(res), i);
    if (t > -ComItextpdfAwtGeomGlCrossing_DELTA && t < 1 + ComItextpdfAwtGeomGlCrossing_DELTA) {
      jdouble rx = t * (t * (t * Ax_ + Bx_) + Cx_);
      if (minX <= rx && rx <= maxX) {
        *IOSDoubleArray_GetRef(nil_chk(bound), bc++) = t;
        *IOSDoubleArray_GetRef(bound, bc++) = rx;
        *IOSDoubleArray_GetRef(bound, bc++) = t * (t * (t * Ay_ + By_) + Cy_);
        *IOSDoubleArray_GetRef(bound, bc++) = id_;
        if (changeId) {
          id_++;
        }
      }
    }
  }
  return bc;
}

- (void)copyAllFieldsTo:(ComItextpdfAwtGeomGlCrossing_CubicCurve *)other {
  [super copyAllFieldsTo:other];
  other->Ax_ = Ax_;
  other->Ax3_ = Ax3_;
  other->Ay_ = Ay_;
  other->Bx_ = Bx_;
  other->Bx2_ = Bx2_;
  other->By_ = By_;
  other->Cx_ = Cx_;
  other->Cy_ = Cy_;
  other->ax_ = ax_;
  other->ay_ = ay_;
  other->bx_ = bx_;
  other->by_ = by_;
  other->cx_ = cx_;
  other->cy_ = cy_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "CubicCurve", NULL, 0x1, NULL },
    { "crossWithDoubleArray:withInt:withDouble:withDouble:", "cross", "I", 0x0, NULL },
    { "solvePointWithDoubleArray:withDouble:", "solvePoint", "I", 0x0, NULL },
    { "solveExtremXWithDoubleArray:", "solveExtremX", "I", 0x0, NULL },
    { "solveExtremYWithDoubleArray:", "solveExtremY", "I", 0x0, NULL },
    { "addBoundWithDoubleArray:withInt:withDoubleArray:withInt:withDouble:withDouble:withBoolean:withInt:", "addBound", "I", 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "ax_", NULL, 0x0, "D", NULL,  },
    { "ay_", NULL, 0x0, "D", NULL,  },
    { "bx_", NULL, 0x0, "D", NULL,  },
    { "by_", NULL, 0x0, "D", NULL,  },
    { "cx_", NULL, 0x0, "D", NULL,  },
    { "cy_", NULL, 0x0, "D", NULL,  },
    { "Ax_", NULL, 0x0, "D", NULL,  },
    { "Ay_", NULL, 0x0, "D", NULL,  },
    { "Bx_", NULL, 0x0, "D", NULL,  },
    { "By_", NULL, 0x0, "D", NULL,  },
    { "Cx_", NULL, 0x0, "D", NULL,  },
    { "Cy_", NULL, 0x0, "D", NULL,  },
    { "Ax3_", NULL, 0x0, "D", NULL,  },
    { "Bx2_", NULL, 0x0, "D", NULL,  },
  };
  static const J2ObjcClassInfo _ComItextpdfAwtGeomGlCrossing_CubicCurve = { "CubicCurve", "com.itextpdf.awt.geom.gl", "Crossing", 0x9, 6, methods, 14, fields, 0, NULL};
  return &_ComItextpdfAwtGeomGlCrossing_CubicCurve;
}

@end
